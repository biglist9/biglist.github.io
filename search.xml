<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>时间复杂度分析的递归树法</title>
      <link href="2020/12/05/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E7%9A%84%E9%80%92%E5%BD%92%E6%A0%91%E6%B3%95/"/>
      <url>2020/12/05/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E7%9A%84%E9%80%92%E5%BD%92%E6%A0%91%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ol><li>分析每一步核心操作的时间复杂度</li><li>分析树高：最大树高和最小树高</li><li>计算每层复杂度，全加起来</li></ol><h3 id="实战1-快速排序"><a href="#实战1-快速排序" class="headerlink" title="实战1:快速排序"></a>实战1:快速排序</h3><ol><li>分割算法是O(n)</li><li>树高最大最小都是 logn，所以O(logn)</li></ol><h3 id="实战2：斐波那契数列"><a href="#实战2：斐波那契数列" class="headerlink" title="实战2：斐波那契数列:"></a>实战2：斐波那契数列:</h3><ol><li>加和算法1</li><li>节点数为倍增。 通项为2^h</li><li>高度最高n，最低n/2.相当于求等比数列前n项和。所以结果2^n,指数级</li></ol><h3 id="实战3-全排列"><a href="#实战3-全排列" class="headerlink" title="实战3:全排列"></a>实战3:全排列</h3><ol><li>核心为将每一项交换到最后一个位置，<code>O（n）</code></li><li>每层树枝-1，所以每层通项是<code>n*n-1*n-2...n-h</code>。</li><li>最后一层为一个，所以是n！。求和不好求但是知道该算法大于n！</li></ol><h3 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h3><p>1 个细胞的生命周期是 3 小时，1 小时分裂一次。求 n 小时后，容器内有多少细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。<br>思路：f(n) = 2 * f(n-1) - 【n时刻点死掉的细胞数量】<br>而在【n时刻点死掉的细胞数量】就是【n-3时刻点新分裂的细胞数量】;【n-3时刻点新分裂的细胞数量】就是【n-4时刻点的细胞数总数】，即f(n-4)</p><p>故递推公式：f(n) = 2 * f(n-1) - f(n-4)，类似斐波那契数列，为指数级</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法思想</title>
      <link href="2020/12/04/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
      <url>2020/12/04/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。</p><h4 id="解决问题步骤"><a href="#解决问题步骤" class="headerlink" title="解决问题步骤"></a>解决问题步骤</h4><p>第一步，当我们看到这类问题的时候，首先要联想到贪心算法：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。<br>第二步，我们尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。<br>第三步，我们举几个例子看下贪心算法产生的结果是否是最优的。</p><h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><p>我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n），所以糖果只能分配给一部分孩子。每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。问题是，如何分配糖果，能尽可能满足最多数量的孩子？</p><p>我们可以把这个问题抽象成，从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的。这个问题的限制值就是糖果个数 m。我们现在来看看如何用贪心算法来解决。对于一个孩子来说，如果小的糖果可以满足，我们就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。另一方面，对糖果大小需求小的孩子更容易被满足，所以，我们可以从需求小的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。</p><p>我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案</p><h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><p>这个问题在我们的日常生活中更加普遍。假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p><p>在生活中，我们肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。<br>在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思路。直觉告诉我们，这种处理方法就是最好的。</p><h4 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h4><p>假设我们有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？<br><img src="tanxin.jpg"></p><p>比如任务调度、教师排课等等问题。<br>这个问题的解决思路是这样的：我们假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。<br>我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。</p><h4 id="用贪心算法实现霍夫曼编码"><a href="#用贪心算法实现霍夫曼编码" class="headerlink" title="用贪心算法实现霍夫曼编码"></a>用贪心算法实现霍夫曼编码</h4><p>假设我有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？</p><p>假设我们通过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。不过，还有没有更加节省空间的存储方式呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(000)、b(001)、c(010)、d(011)、e(100)、f(101)</span><br></pre></td></tr></table></figure><p>霍夫曼编码就要登场了。霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在 20%～90% 之间。如何给不同频率的字符选择不同长度的编码呢？根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。<br>但是，霍夫曼编码是不等长的，每次应该读取 1 位还是 2 位、3 位等等来解压缩呢？这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况<br>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。</p><p><img src="huofuman.jpg"></p><p>我们把每个字符看作一个节点，并且附带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。<br>分治算法是一种处理问题的思想，递归是一种编程技巧。实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ul><li>分解：将原问题分解成一系列子问题；</li><li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li><li>合并：将子问题的结果合并成原问题。</li></ul><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ul><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li></ul><h4 id="分治算法应用举例分析"><a href="#分治算法应用举例分析" class="headerlink" title="分治算法应用举例分析"></a>分治算法应用举例分析</h4><ol><li>假设有n个数据，期望数据从小到大排序，那完全有序的数据的有序度就是n(n-1)/2。逆序度等于0；相反，倒序排序的数据的有序度就是0，逆序度是n(n-1)/2。除了这两中极端情况外，我们通过计算有序对或逆序对的个数，来表示数据的有序度或逆序度。 </li><li>现在问：如何编程求出数组中的数据有序对个数或逆序对个数？</li><li>最简单的办法：拿每个数字和他后面的数字比较，看有几个比它小。将比它小的数字个数记作k，通过这样的方式，把每个数字都考察一遍后，对每个数字对应的k值求和，最后得到的总和就是逆序对个数。但时间复杂度是O(n^2)。</li><li>用分治算法，套用分治的思想，将书中分成前后两半A1和A2，分别两者中的逆序对数，然后在计算A1和A2之间的逆序对个数k3。那整个数组的逆序对个数就是k1+k2+k3。</li><li>要快速计算出两个子问题A1和A2之间的逆序对个数需要借助归并排序算法。</li></ol><p>归并排序算法有个非常关键的操作，即将两个有序的小数组，合并成一个有序的数组。实际上，在合并的过程中，就可以计算这两个小数组的逆序对个数。每次合并操作，都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数。</p><h4 id="求两个数的最大共因子（欧几里得算法）"><a href="#求两个数的最大共因子（欧几里得算法）" class="headerlink" title="求两个数的最大共因子（欧几里得算法）"></a>求两个数的最大共因子（欧几里得算法）</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分治算法</span></span><br><span class="line"><span class="comment"> * 逻辑：</span></span><br><span class="line"><span class="comment"> * (1) 找出基线条件，这种条件必须尽可能简单。</span></span><br><span class="line"><span class="comment"> * (2) 不断将问题分解（或者说缩小规模），直到符合基线条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dc</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大公因子（欧几里得算法）</span></span><br><span class="line"><span class="comment">     * 可以引申到-客厅长宽固定，问选择多大的正方形地砖，可以正好铺满客厅</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">greatestCommonFactor</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$a</span> &lt; <span class="variable">$b</span>) &#123;</span><br><span class="line">            <span class="variable">$c</span> = <span class="variable">$a</span>;</span><br><span class="line">            <span class="variable">$a</span> = <span class="variable">$b</span>;</span><br><span class="line">            <span class="variable">$b</span> = <span class="variable">$c</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$a</span> % <span class="variable">$b</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$c</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$b</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$n</span> = <span class="keyword">$this</span>-&gt;greatestCommonFactor(<span class="variable">$c</span>, <span class="variable">$b</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dd((<span class="keyword">new</span> dc())-&gt;greatestCommonFactor(<span class="number">160</span>, <span class="number">56</span>));</span><br></pre></td></tr></table></figure><h4 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h4><ol><li>假设，给10GB的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有10GB，而我们的机器的内存可能只有2,3GB这样子，无法一次性加载到内存，也就无法通过单纯地使用快排，归并等基础算法来解决。</li><li>要解决这种数据量大到内装不下的问题，我们就可以利用分治的思想，将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后在将小数据集合合并成大数据集合，实际上利用这种分治的处理思路，不仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</li></ol><h4 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h4><p>采用分治思想的算法包括：</p><ol><li>快速排序算法</li><li>合并排序算法</li><li>桶排序算法</li><li>基数排序算法</li><li>二分查找算法</li><li>利用递归树求解算法复杂度的思想</li><li>分布式数据库利用分片技术做数据处理</li><li>MapReduce模型处理思想</li></ol><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>深度优先搜索算法利用的是回溯算法思想。这个算法思想非常简单，但是应用却非常广泛。它除了用来指导像深度优先搜索这种经典的算法设计之外，还可以用在很多实际的软件开发场景中，比如正则表达式匹配、编译原理中的语法分析等。很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。<br>回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p><h4 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 八皇后问题</span></span><br><span class="line"><span class="comment"> * 有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子</span></span><br><span class="line"><span class="comment"> * Class queen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queen</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//全局或成员变量,下标表示行,值表示queen存储在哪一列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$result</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">cal8queens</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$row</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 8个棋子都放置好了，打印结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$row</span> == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;printQueens();</span><br><span class="line">            <span class="comment">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一行都有8中放法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$column</span> = <span class="number">0</span>; <span class="variable">$column</span> &lt; <span class="number">8</span>; ++<span class="variable">$column</span>) &#123;</span><br><span class="line">            <span class="comment">// 有些放法不满足要求</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isOk(<span class="variable">$row</span>, <span class="variable">$column</span>)) &#123;</span><br><span class="line">                <span class="comment">// 第row行的棋子放到了column列</span></span><br><span class="line">                <span class="keyword">$this</span>-&gt;result[<span class="variable">$row</span>] = <span class="variable">$column</span>;</span><br><span class="line">                <span class="comment">// 考察下一行</span></span><br><span class="line">                <span class="keyword">$this</span>-&gt;cal8queens(<span class="variable">$row</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">isOk</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$row</span>, <span class="keyword">int</span> <span class="variable">$column</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$leftUp</span> = <span class="variable">$column</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="variable">$rightUp</span> = <span class="variable">$column</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 逐行往上考察每一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="variable">$row</span> - <span class="number">1</span>; <span class="variable">$i</span> &gt;= <span class="number">0</span>; --<span class="variable">$i</span>) &#123;</span><br><span class="line">            <span class="comment">// 第i行的column列有棋子吗</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;result[<span class="variable">$i</span>] == <span class="variable">$column</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 考察左上对角线：第i行leftUp列有棋子吗</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$leftUp</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">$this</span>-&gt;result[<span class="variable">$i</span>] == <span class="variable">$leftUp</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 考察右上对角线：第i行rightUp列有棋子吗</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$rightUp</span> &lt; <span class="number">8</span> &amp;&amp; <span class="keyword">$this</span>-&gt;result[<span class="variable">$i</span>] == <span class="variable">$rightUp</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --<span class="variable">$leftUp</span>;</span><br><span class="line">            ++<span class="variable">$rightUp</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出一个二维矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">printQueens</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$row</span> = <span class="number">0</span>; <span class="variable">$row</span> &lt; <span class="number">8</span>; ++<span class="variable">$row</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="variable">$column</span> = <span class="number">0</span>; <span class="variable">$column</span> &lt; <span class="number">8</span>; ++<span class="variable">$column</span>) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;result[<span class="variable">$row</span>] == <span class="variable">$column</span> ? <span class="string">&quot;Q &quot;</span> : <span class="string">&quot;* &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Queen())-&gt;cal8queens(<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h4><p>这个问题的经典解法是动态规划，但是也可以使用回溯算法，实现简单，但是没有那么高效。</p><p>0-1 背包问题有很多变体，这里介绍一种比较基础的。有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？<br>我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">backpack</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$maxW</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span></span><br><span class="line">    <span class="comment">// w背包重量；items表示每个物品的重量；itemCount表示物品个数</span></span><br><span class="line">    <span class="comment">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span></span><br><span class="line">    <span class="comment">// f(0, 0, a, 10, 100)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$i</span>, <span class="keyword">int</span> <span class="variable">$cw</span>, <span class="keyword">array</span> <span class="variable">$items</span>, <span class="keyword">int</span> <span class="variable">$itemCount</span>, <span class="keyword">int</span> <span class="variable">$w</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// cw==w表示装满了;i==n表示已经考察完所有的物品</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$cw</span> == <span class="variable">$w</span> || <span class="variable">$i</span> == <span class="variable">$itemCount</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$cw</span> &gt; <span class="keyword">$this</span>-&gt;maxW) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;maxW = <span class="variable">$cw</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归调用表示不选择当前物品，直接考虑下一个（第 i+1 个），故 cw 不更新</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;f(<span class="variable">$i</span> + <span class="number">1</span>, <span class="variable">$cw</span>, <span class="variable">$items</span>, <span class="variable">$itemCount</span>, <span class="variable">$w</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$cw</span> + <span class="variable">$items</span>[<span class="variable">$i</span>] &lt;= <span class="variable">$w</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示选择了当前物品，故考虑下一个时，cw 通过入参更新为 cw + items[i]</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;f(<span class="variable">$i</span> + <span class="number">1</span>, <span class="variable">$cw</span> + <span class="variable">$items</span>[<span class="variable">$i</span>], <span class="variable">$items</span>, <span class="variable">$itemCount</span>, <span class="variable">$w</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。为了方便讲解，我假设正则表达式中只包含<code>“*”和“?”</code>这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p><p>我们依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</p><p>如果遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span>[] pattern; <span class="comment">// 正则表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> plen; <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    <span class="keyword">this</span>.plen = plen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123; <span class="comment">// 文本串及长度</span></span><br><span class="line">    matched = <span class="keyword">false</span>;</span><br><span class="line">    rmatch(<span class="number">0</span>, <span class="number">0</span>, text, tlen);</span><br><span class="line">    <span class="keyword">return</span> matched;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span>; <span class="comment">// 如果已经匹配了，就不要继续递归了</span></span><br><span class="line">    <span class="keyword">if</span> (pj == plen) &#123; <span class="comment">// 正则表达式到结尾了</span></span><br><span class="line">      <span class="keyword">if</span> (ti == tlen) matched = <span class="keyword">true</span>; <span class="comment">// 文本串也到结尾了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pattern[pj] == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">// *匹配任意个字符</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) &#123;</span><br><span class="line">        rmatch(ti+k, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] == <span class="string">&#x27;?&#x27;</span>) &#123; <span class="comment">// ?匹配0个或者1个字符</span></span><br><span class="line">      rmatch(ti, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="comment">// 纯字符匹配才行</span></span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯算法的思想简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>一个模型三个特征<br>“一个模型” 指的是动态规划适合解决的问题的模型。把这个模型定义为“多阶段决策最优解模型”。<br>“三个特征”分别是最优子结构、无后效性和重复子问题。</p><ol><li>最优子结构<br> 最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来</li><li>无后效性<br> 无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</li><li>重复子问题<br> 如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</li></ol><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="状态转移表法"><a href="#状态转移表法" class="headerlink" title="状态转移表法"></a>状态转移表法</h5><p>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码<br>先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了</p><h5 id="状态转移方程法"><a href="#状态转移方程法" class="headerlink" title="状态转移方程法"></a>状态转移方程法</h5><p>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。<br>状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。有两种代码实现方法，一种是递归加“备忘录”，另一种是迭代递推。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_dist(i, j) &#x3D; w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))</span><br></pre></td></tr></table></figure><h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><p>我们把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。</p><h3 id="四种算法思想比较分析"><a href="#四种算法思想比较分析" class="headerlink" title="四种算法思想比较分析"></a>四种算法思想比较分析</h3><p>那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型</p><p>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p><p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。</p><p>其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php 实现单链表以及链表反转等操作</title>
      <link href="2020/12/02/php-%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E4%BB%A5%E5%8F%8A%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E7%AD%89%E6%93%8D%E4%BD%9C/"/>
      <url>2020/12/02/php-%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E4%BB%A5%E5%8F%8A%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E7%AD%89%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存淘汰的三种策略"><a href="#缓存淘汰的三种策略" class="headerlink" title="缓存淘汰的三种策略"></a>缓存淘汰的三种策略</h2><ul><li>先进先出策略 FIFO（First In，First Out）</li><li>最少使用策略 LFU（Least Frequently Used）</li><li>最近最少使用策略 LRU（Least Recently Used）</li></ul><p>可以考虑用链表进行实现。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><h3 id="链表分类"><a href="#链表分类" class="headerlink" title="链表分类"></a>链表分类</h3><ul><li>单链表</li><li>双向链表</li><li>循环链表：循环链表也很简单。它跟单链表唯一的区别就在尾结点</li></ul><h3 id="数组与链表的对比"><a href="#数组与链表的对比" class="headerlink" title="数组与链表的对比"></a>数组与链表的对比</h3><table><thead><tr><th align="center">时间复杂度</th><th align="center">数组</th><th align="center">链表</th></tr></thead><tbody><tr><td align="center">插入、删除</td><td align="center"><code>O(n)</code></td><td align="center"><code>O(1)</code></td></tr><tr><td align="center">随机访问</td><td align="center"><code>O(1)</code></td><td align="center"><code>O(n)</code></td></tr></tbody></table><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-SingleLinkedListNode-php-定义节点信息"><a href="#1-SingleLinkedListNode-php-定义节点信息" class="headerlink" title="1. SingleLinkedListNode.php 定义节点信息"></a>1. SingleLinkedListNode.php 定义节点信息</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点中的数据域</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点中的指针域，指向下一个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> SingleLinkedListNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SingleLinkedListNode constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> null $data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$data</span> = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;data = <span class="variable">$data</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SingleLinkedList-php-定义链表"><a href="#2-SingleLinkedList-php-定义链表" class="headerlink" title="2. SingleLinkedList.php 定义链表"></a>2. SingleLinkedList.php 定义链表</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单链表头结点（哨兵节点）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> SingleLinkedListNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$head</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单链表长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化单链表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * SingleLinkedList constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> null $head</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$head</span> = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="variable">$head</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;head = <span class="keyword">new</span> SingleLinkedListNode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;head = <span class="variable">$head</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据 采用头插法 插入新数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $data</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SingleLinkedListNode|bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;insertDataAfter(<span class="keyword">$this</span>-&gt;head, <span class="variable">$data</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> SingleLinkedListNode $node</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delete</span>(<span class="params">SingleLinkedListNode <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="variable">$node</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取待删除节点的前置节点</span></span><br><span class="line">        <span class="variable">$preNode</span> = <span class="keyword">$this</span>-&gt;getPreNode(<span class="variable">$node</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$preNode</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改指针指向</span></span><br><span class="line">        <span class="variable">$preNode</span>-&gt;next = <span class="variable">$node</span>-&gt;next;</span><br><span class="line">        <span class="keyword">unset</span>(<span class="variable">$node</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引获取节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $index</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SingleLinkedListNode|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getNodeByIndex</span>(<span class="params"><span class="variable">$index</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$index</span> &gt;= <span class="keyword">$this</span>-&gt;length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$cur</span> = <span class="keyword">$this</span>-&gt;head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$index</span>; ++<span class="variable">$i</span>) &#123;</span><br><span class="line">            <span class="variable">$cur</span> = <span class="variable">$cur</span>-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$cur</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某个节点的前置节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> SingleLinkedListNode $node</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SingleLinkedListNode|bool|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPreNode</span>(<span class="params">SingleLinkedListNode <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="variable">$node</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$curNode</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line">        <span class="variable">$preNode</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line">        <span class="comment">// 遍历找到前置节点 要用全等判断是否是同一个对象</span></span><br><span class="line">        <span class="comment">// http://php.net/manual/zh/language.oop5.object-comparison.php</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$curNode</span> !== <span class="variable">$node</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$curNode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$preNode</span> = <span class="variable">$curNode</span>;</span><br><span class="line">            <span class="variable">$curNode</span> = <span class="variable">$curNode</span>-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$preNode</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出单链表 当data的数据为可输出类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">printList</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="keyword">$this</span>-&gt;head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$curNode</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line">        <span class="comment">// 防止链表带环，控制遍历次数</span></span><br><span class="line">        <span class="variable">$listLength</span> = <span class="keyword">$this</span>-&gt;getLength();</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$curNode</span>-&gt;next != <span class="literal">null</span> &amp;&amp; <span class="variable">$listLength</span>--) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$curNode</span>-&gt;next-&gt;data . <span class="string">&#x27; -&gt; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$curNode</span> = <span class="variable">$curNode</span>-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;NULL&#x27;</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出单链表 当data的数据为可输出类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">printListSimple</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="keyword">$this</span>-&gt;head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$curNode</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$curNode</span>-&gt;next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$curNode</span>-&gt;next-&gt;data . <span class="string">&#x27; -&gt; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$curNode</span> = <span class="variable">$curNode</span>-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;NULL&#x27;</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在某个节点后插入新的节点 (直接插入数据)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> SingleLinkedListNode $originNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>                      $data</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SingleLinkedListNode|bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insertDataAfter</span>(<span class="params">SingleLinkedListNode <span class="variable">$originNode</span>, <span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果originNode为空，插入失败</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="variable">$originNode</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建单链表节点</span></span><br><span class="line">        <span class="variable">$newNode</span> = <span class="keyword">new</span> SingleLinkedListNode();</span><br><span class="line">        <span class="comment">// 新节点的数据</span></span><br><span class="line">        <span class="variable">$newNode</span>-&gt;data = <span class="variable">$data</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新节点的下一个节点为源节点的下一个节点</span></span><br><span class="line">        <span class="variable">$newNode</span>-&gt;next = <span class="variable">$originNode</span>-&gt;next;</span><br><span class="line">        <span class="comment">// 在originNode后插入newNode</span></span><br><span class="line">        <span class="variable">$originNode</span>-&gt;next = <span class="variable">$newNode</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链表长度++</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;length++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$newNode</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在某个节点前插入新的节点（很少使用）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> SingleLinkedListNode $originNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>                      $data</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SingleLinkedListNode|bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insertDataBefore</span>(<span class="params">SingleLinkedListNode <span class="variable">$originNode</span>, <span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果originNode为空，插入失败</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="variable">$originNode</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先找到originNode的前置节点，然后通过insertDataAfter插入</span></span><br><span class="line">        <span class="variable">$preNode</span> = <span class="keyword">$this</span>-&gt;getPreNode(<span class="variable">$originNode</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;insertDataAfter(<span class="variable">$preNode</span>, <span class="variable">$data</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在某个节点后插入新的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> SingleLinkedListNode $originNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> SingleLinkedListNode $node</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SingleLinkedListNode|bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insertNodeAfter</span>(<span class="params">SingleLinkedListNode <span class="variable">$originNode</span>, SingleLinkedListNode <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果originNode为空，插入失败</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="variable">$originNode</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$node</span>-&gt;next = <span class="variable">$originNode</span>-&gt;next;</span><br><span class="line">        <span class="variable">$originNode</span>-&gt;next = <span class="variable">$node</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;length++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$node</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个有环的链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buildHasCircleList</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$data</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        <span class="variable">$node0</span> = <span class="keyword">new</span> SingleLinkedListNode(<span class="variable">$data</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="variable">$node1</span> = <span class="keyword">new</span> SingleLinkedListNode(<span class="variable">$data</span>[<span class="number">1</span>]);</span><br><span class="line">        <span class="variable">$node2</span> = <span class="keyword">new</span> SingleLinkedListNode(<span class="variable">$data</span>[<span class="number">2</span>]);</span><br><span class="line">        <span class="variable">$node3</span> = <span class="keyword">new</span> SingleLinkedListNode(<span class="variable">$data</span>[<span class="number">3</span>]);</span><br><span class="line">        <span class="variable">$node4</span> = <span class="keyword">new</span> SingleLinkedListNode(<span class="variable">$data</span>[<span class="number">4</span>]);</span><br><span class="line">        <span class="variable">$node5</span> = <span class="keyword">new</span> SingleLinkedListNode(<span class="variable">$data</span>[<span class="number">5</span>]);</span><br><span class="line">        <span class="variable">$node6</span> = <span class="keyword">new</span> SingleLinkedListNode(<span class="variable">$data</span>[<span class="number">6</span>]);</span><br><span class="line">        <span class="variable">$node7</span> = <span class="keyword">new</span> SingleLinkedListNode(<span class="variable">$data</span>[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;insertNodeAfter(<span class="keyword">$this</span>-&gt;head, <span class="variable">$node0</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;insertNodeAfter(<span class="variable">$node0</span>, <span class="variable">$node1</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;insertNodeAfter(<span class="variable">$node1</span>, <span class="variable">$node2</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;insertNodeAfter(<span class="variable">$node2</span>, <span class="variable">$node3</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;insertNodeAfter(<span class="variable">$node3</span>, <span class="variable">$node4</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;insertNodeAfter(<span class="variable">$node4</span>, <span class="variable">$node5</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;insertNodeAfter(<span class="variable">$node5</span>, <span class="variable">$node6</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;insertNodeAfter(<span class="variable">$node6</span>, <span class="variable">$node7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$node7</span>-&gt;next = <span class="variable">$node4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-定义工具类"><a href="#3-定义工具类" class="headerlink" title="3. 定义工具类"></a>3. 定义工具类</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListTool</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单链表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数设置$list</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * SingleLinkedListAlgo constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> SingleLinkedList $list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">SingleLinkedList <span class="variable">$list</span> = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;list = <span class="variable">$list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置单链表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> SingleLinkedList $list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setList</span>(<span class="params">SingleLinkedList <span class="variable">$list</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;list = <span class="variable">$list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单链表反转</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 三个指针反转</span></span><br><span class="line"><span class="comment">     * preNode 指向前一个结点</span></span><br><span class="line"><span class="comment">     * curNode 指向当前结点</span></span><br><span class="line"><span class="comment">     * remainNode 指向当前结点的下一个节点（保存未逆序的链表，为了在断开curNode的next指针后能找到后续节点）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list || <span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list-&gt;head || <span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$preNode</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable">$curNode</span> = <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next;</span><br><span class="line">        <span class="variable">$remainNode</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存头结点，稍后指向反转后的链表</span></span><br><span class="line">        <span class="variable">$headNode</span> = <span class="keyword">$this</span>-&gt;list-&gt;head;</span><br><span class="line">        <span class="comment">// 断开头结点的next指针</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$curNode</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$remainNode</span> = <span class="variable">$curNode</span>-&gt;next;</span><br><span class="line">            <span class="variable">$curNode</span>-&gt;next = <span class="variable">$preNode</span>;</span><br><span class="line">            <span class="variable">$preNode</span> = <span class="variable">$curNode</span>;</span><br><span class="line">            <span class="variable">$curNode</span> = <span class="variable">$remainNode</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头结点指向反转后的链表</span></span><br><span class="line">        <span class="variable">$headNode</span>-&gt;next = <span class="variable">$preNode</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断链表是否有环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 快慢指针判断是否有环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">checkCircle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list || <span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list-&gt;head || <span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$slow</span> = <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next;</span><br><span class="line">        <span class="variable">$fast</span> = <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$fast</span> != <span class="literal">null</span> &amp;&amp; <span class="variable">$fast</span>-&gt;next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$fast</span> = <span class="variable">$fast</span>-&gt;next-&gt;next;</span><br><span class="line">            <span class="variable">$slow</span> = <span class="variable">$slow</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果慢指针跟快指针相遇了说明有环</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$slow</span> === <span class="variable">$fast</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个有序链表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> SingleLinkedList $listA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> SingleLinkedList $listB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SingleLinkedList|SingleLinkedListNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">mergerSortedList</span>(<span class="params">SingleLinkedList <span class="variable">$listA</span>, SingleLinkedList <span class="variable">$listB</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="variable">$listA</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$listB</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="variable">$listB</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$listA</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$pListA</span> = <span class="variable">$listA</span>-&gt;head-&gt;next;</span><br><span class="line">        <span class="variable">$pListB</span> = <span class="variable">$listB</span>-&gt;head-&gt;next;</span><br><span class="line">        <span class="variable">$newList</span> = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        <span class="variable">$newHead</span> = <span class="variable">$newList</span>-&gt;head;</span><br><span class="line">        <span class="variable">$newRootNode</span> = <span class="variable">$newHead</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$pListA</span> != <span class="literal">null</span> &amp;&amp; <span class="variable">$pListB</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$pListA</span>-&gt;data &lt;= <span class="variable">$pListB</span>-&gt;data) &#123;</span><br><span class="line">                <span class="variable">$newRootNode</span>-&gt;next = <span class="variable">$pListA</span>;</span><br><span class="line">                <span class="variable">$pListA</span> = <span class="variable">$pListA</span>-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$newRootNode</span>-&gt;next = <span class="variable">$pListB</span>;</span><br><span class="line">                <span class="variable">$pListB</span> = <span class="variable">$pListB</span>-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$newRootNode</span> = <span class="variable">$newRootNode</span>-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果第一个链表未处理完，拼接到新链表后面</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$pListA</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$newRootNode</span>-&gt;next = <span class="variable">$pListA</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果第二个链表未处理完，拼接到新链表后面</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$pListB</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$newRootNode</span>-&gt;next = <span class="variable">$pListB</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$newList</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除链表倒数第n个结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $index</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteLastKth</span>(<span class="params"><span class="variable">$index</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list || <span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list-&gt;head || <span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$i</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="variable">$slow</span> = <span class="keyword">$this</span>-&gt;list-&gt;head;</span><br><span class="line">        <span class="variable">$fast</span> = <span class="keyword">$this</span>-&gt;list-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$fast</span> != <span class="literal">null</span> &amp;&amp; <span class="variable">$i</span> &lt; <span class="variable">$index</span>) &#123;</span><br><span class="line">            <span class="variable">$fast</span> = <span class="variable">$fast</span>-&gt;next;</span><br><span class="line">            ++<span class="variable">$i</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="variable">$fast</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$pre</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$fast</span>-&gt;next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$pre</span> = <span class="variable">$slow</span>;</span><br><span class="line">            <span class="variable">$slow</span> = <span class="variable">$slow</span>-&gt;next;</span><br><span class="line">            <span class="variable">$fast</span> = <span class="variable">$fast</span>-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="variable">$pre</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next = <span class="variable">$slow</span>-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$pre</span>-&gt;next = <span class="variable">$pre</span>-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找中间节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 快慢指针遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SingleLinkedListNode|bool|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">findMiddleNode</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list || <span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list-&gt;head || <span class="literal">null</span> == <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$slow</span> = <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next;</span><br><span class="line">        <span class="variable">$fast</span> = <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$fast</span> != <span class="literal">null</span> &amp;&amp; <span class="variable">$fast</span>-&gt;next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$fast</span> = <span class="variable">$fast</span>-&gt;next-&gt;next;</span><br><span class="line">            <span class="variable">$slow</span> = <span class="variable">$slow</span>-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$slow</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查是否回文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;list-&gt;getLength() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$pre</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable">$slow</span> = <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next;</span><br><span class="line">        <span class="variable">$fast</span> = <span class="keyword">$this</span>-&gt;list-&gt;head-&gt;next;</span><br><span class="line">        <span class="variable">$remainNode</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找单链表中点 以及 反转前半部分链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$fast</span> != <span class="literal">null</span> &amp;&amp; <span class="variable">$fast</span>-&gt;next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$fast</span> = <span class="variable">$fast</span>-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 单链表反转关键代码 三个指针</span></span><br><span class="line">            <span class="variable">$remainNode</span> = <span class="variable">$slow</span>-&gt;next;</span><br><span class="line">            <span class="variable">$slow</span>-&gt;next = <span class="variable">$pre</span>;</span><br><span class="line">            <span class="variable">$pre</span> = <span class="variable">$slow</span>;</span><br><span class="line">            <span class="variable">$slow</span> = <span class="variable">$remainNode</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 链表长度为偶数的情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$fast</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$slow</span> = <span class="variable">$slow</span>-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始逐个比较</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$slow</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$slow</span>-&gt;data != <span class="variable">$pre</span>-&gt;data) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$slow</span> = <span class="variable">$slow</span>-&gt;next;</span><br><span class="line">            <span class="variable">$pre</span> = <span class="variable">$pre</span>-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树</title>
      <link href="2020/12/01/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2020/12/01/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>二叉查找树是常用的一种二叉树，他支持快速插入，删除，查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是O(logn)</p><p>在很多书籍中，但凡讲到平衡二叉查找树，就会那红黑树做为例子。在工程中，很多用到平衡二叉查找树的地方都会用红黑树。</p><h3 id="一，什么是“平衡二叉查找树”"><a href="#一，什么是“平衡二叉查找树”" class="headerlink" title="一，什么是“平衡二叉查找树”"></a>一，什么是“平衡二叉查找树”</h3><ol><li><p>定义：二叉树中任意一个节点的左右子树的高度相差不能大于1。<br>所以：完全二叉树，满二叉树都是平衡二叉树，非完全二叉树也有可能是平衡二叉树。</p></li><li><p>平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。</p></li><li><p>发明平衡二叉查找树这类数据结构的初衷是解决普通二叉查找树在频繁的插入，删除等动态更新的情况下，出现时间复杂度退化的问题。<br>所以，平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”，比较“平衡”，不要出现左子树很高，右子树很矮的情况。这样就能让整颗树的高度相对低一些，相应的插入，删除，查找等操作的效率高一些。</p></li><li><p>若设计一个新的平衡二叉查找树，只要树的高度不比log2n大很多（如树的高度仍然是对数量级的），尽管它不符合严格的平衡二叉查找树的定义，但它仍然可以被认为是一个合格的平衡二叉查找树。</p></li></ol><h3 id="二，如何定义一棵“红黑树”"><a href="#二，如何定义一棵“红黑树”" class="headerlink" title="二，如何定义一棵“红黑树”"></a>二，如何定义一棵“红黑树”</h3><ol><li>平衡二叉查找树有很多，如：Splay Tree(伸展树)，Treap（树堆）等，但是我们提到平衡二叉查找树，听到的基本都是红黑树。他的出境率甚至要高于“平衡二叉查找树”这几个字，甚至在有些时刻，默认平衡二叉查找树就是红黑树</li><li>红黑树：英文“Red-Black-Tree”，简称R-B Tree，有如下特性：<br>它是一种不严格的平衡二叉查找树。<br>红黑树中的节点，一类别标记为黑色，一类被标记为红色。<ul><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL）,也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，即红色节点都是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li></ul></li><li>二叉查找树很多操作的性能都跟树的高度成正比，一课极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是log2n,所以要证明红黑树是近似平衡的，我们只需要分析，红黑树的高度是否比较稳定地趋近log2n就好<br>。</li><li>红黑树的高度分析<br>①：首先，若将红色节点从红黑树中去除，那单纯包含黑色节点的红黑树的高度比包含相同节点个数的完全二叉树的高度要小。所以去掉红色节点的“黑树”的高度也不会超过log2n。<br>②：在红黑树中，红色节点不能相邻，即有一个红色节点就要至少有一个黑色节点，将它更其他红色节点隔开。<br>红黑树中包含最多黑色节点的路径不会超过log2n,所以加入红色节点之后，最长路径不会超过2log2n，即，红黑树的高度近似2log2n<br>③：红黑树的高度只比高度平衡的AVL树的高度（log2n）仅仅大了一倍，在性能上下降的并不多。</li></ol><h3 id="三，工程中大家都喜欢用红黑树这种平衡二叉查找树的原因："><a href="#三，工程中大家都喜欢用红黑树这种平衡二叉查找树的原因：" class="headerlink" title="三，工程中大家都喜欢用红黑树这种平衡二叉查找树的原因："></a>三，工程中大家都喜欢用红黑树这种平衡二叉查找树的原因：</h3><p>①：Treap，Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现概率不大，但是对于单次操作时间非常敏感的场景来讲，它们不适用。<br>②：AVL树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利有弊，AVL树为了维持这种高度平衡，要付出更多代价，每次插入，删除都要做调整，就比较复杂，耗时。所以有频繁的插入，删除操作的数据集合，使用AVL树的代价就有点高了。<br>③：红黑树只是做到了近似平衡，并不是严格的平衡，所以维护平衡的成本上，要比AVL树低。<br>所以，红黑树的插入，删除，查找各种操作性能都比较稳定。对于工程应用来说，结果状态可控可预期。</p><h3 id="四，思考题"><a href="#四，思考题" class="headerlink" title="四，思考题"></a>四，思考题</h3><p>动态数据结构支持动态的数据插入、删除、查找操作，除了红黑树，我们前面还学习过哪些呢？能对比一下各自的优势、劣势，以及应用场景吗？</p><ul><li>散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。 </li><li>跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。 </li><li>红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署升级策略</title>
      <link href="2020/11/30/%E9%83%A8%E7%BD%B2%E5%8D%87%E7%BA%A7%E7%AD%96%E7%95%A5/"/>
      <url>2020/11/30/%E9%83%A8%E7%BD%B2%E5%8D%87%E7%BA%A7%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="停机部署"><a href="#停机部署" class="headerlink" title="停机部署"></a>停机部署</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>停机部署其实是最简单粗暴的方式，就是简单地把现有版本的服务停机，然后部署新的版本。在一些时候，我们必需使用这样的方式来部署或升级多个服务。比如，新版本中的服务使用到了和老版本完全不兼容的数据表的设计。这个时候，我们对生产有两个变更，一个是数据库，另一个是服务，而且新老版本互不兼容，所以只能使用停机部署的方式。<br>这种方式的优势是，在部署过程中不会出现新老版本同时在线的情况，所有状态完全一致。停机部署主要是为了新版本的一致性问题。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>这种方式最不好的问题就是会停机，对用户的影响会很大。所以，一般来说，这种部署方式需要事前挂公告，选择一个用户访问少的时间段来做。</p><h3 id="蓝绿部署"><a href="#蓝绿部署" class="headerlink" title="蓝绿部署"></a>蓝绿部署</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>蓝绿部署与停机部署最大的不同是，其在生产线上部署相同数量的新的服务，然后当新的服务测试确认 OK 后，把流量切到新的服务这边来。蓝绿部署比停机部署好的地方是，它无需停机。<br>我们可以看到这种部署方式，就是我们说的预发环境。在我以前的金融公司里，也经常用这种方式，生产线上有两套相同的集群，一套是 Prod 是真实服务的，另一套是 Stage 是预发环境，发布发 Stage，然后把流量切到 Stage 这边，于是 Stage 就成了 Prod，而之前的 Prod 则成了 Stage。有点像换页似的。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>这种方式的优点是没有停机，实时发布和升级，也避免有新旧版本同时在线的问题。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>这种部署的问题就是有点浪费，因为需要使用双倍的资源（不过，这只是在物理机时代，在云计算时代没事，因为虚拟机部署完就可以释放了）。另外，如果我们的服务中有状态，比如一些缓存什么的，停机部署和蓝绿部署都会有问题。</p><h3 id="滚动部署"><a href="#滚动部署" class="headerlink" title="滚动部署"></a>滚动部署</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>滚动部署策略是指通过逐个替换应用的所有实例，来缓慢发布应用的一个新版本。通常过程如下：在负载调度后有个版本 A 的应用实例池，一个版本 B 的实例部署成功，可以响应请求时，该实例被加入到池中。然后，版本 A 的一个实例从池中删除并下线。<br>这种部署方式直接对现有的服务进行升级，虽然便于操作，而且在缓慢地更新的过程中，对于有状态的服务也是比较友好的，状态可以在更新中慢慢重建起来。但是，这种部署的问题也是比较多的。</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>在发布过程中，会出现新老两个版本同时在线的情况，同一用户的请求可能在新老版中切换而导致问题。<br>我们的新版程序没有在生产线上经过验证就上线了。<br>在整个过程中，生产环境处于一个新老更替的中间状态，如果有问题要回滚就有点麻烦了。<br>如果在升级过程中，需要做别的一些运维工作，我们还要判断哪些结点是老版本的，哪些结点是新版本的。这太痛苦了。<br>因为新老版本的代码同时在线，所以其依赖的服务需要同时处理两个版本的请求，这可能会带来兼容性问题。<br>而且，我们无法让流量在新老版本中切换。</p><h3 id="灰度部署（金丝雀）"><a href="#灰度部署（金丝雀）" class="headerlink" title="灰度部署（金丝雀）"></a>灰度部署（金丝雀）</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>灰度部署又叫金丝雀部署。其得名来源于矿井中的金丝雀–17 世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱。而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为 “ 瓦斯检测指标 “，以便在危险状况下紧急撤离。<br>灰度部署是指逐渐将生产环境流量从老版本切换到新版本。通常流量是按比例分配的。例如 90% 的请求流向老版本，10% 的流向新版本。然后没有发现问题，就逐步扩大新版本上的流量，减少老版本上的流量。<br>除了切流量外，对于多租户的平台，例如云计算平台，灰度部署也可以将一些新的版本先部署到一些用户上，如果没有问题，扩大部署，直到全部用户。一般的策略是，从内部用户开始，然后是一般用户，最后是大客户。<br>这个技术大多数用于缺少足够测试，或者缺少可靠测试，或者对新版本的稳定性缺乏信心的情况下。<br>把一部分用户切到新版上来，然后看一下有没有问题。如果没有问题就继续扩大升级，直到全部升级完成。</p><h4 id="AB-测试"><a href="#AB-测试" class="headerlink" title="AB 测试"></a>AB 测试</h4><p>AB 测试和蓝绿部署或是金丝雀灰度部署完全是不一样的。<br>AB 测试是同时上线两个版本，然后做相关的比较。是用来测试应用功能表现的方法，例如可用性、受欢迎程度、可见性等。<br>蓝绿部署是为了不停机，灰度部署是对新版本的质量没信心。而 AB 测试是对新版的功能没信心。注意，一个是质量，一个是功能。<br>比如，网站 UI 大改版，推荐算法的更新，流程的改变，我们不知道新的版本否会得到用户青睐或是能得到更好的用户体验，我们需要收集一定的用户数据才能知道。<br>于是我们需要在生产线上发布两个版本，拉一部分用户过来当小白鼠，然后通过科学的观测得出来相关的结论。AB 测试旨在通过科学的实验设计、采样样本代表性、流量分割与小流量测试等方式来获得具有代表性的实验结论，并确信该结论在推广到全部流量时可信。<br>我们可以看到 AB 测试，其包含了灰度发布的功能。也就是说，我们的观测如果只是观测有没有 bug，那就是灰度发布了。当然，如果我们复杂一点，要观测用户的一些数据指标，这完全也可能做成自动化的，如果新版本数据好，就自动化地切一点流量过来，如果不行，就换一批用户（样本）再试试。<br>对于灰度发布或是 AB 测试可以使用下面的技术来选择用户。</p><ul><li>浏览器 cookie。</li><li>查询参数。</li><li>地理位置。</li><li>技术支持，如浏览器版本、屏幕尺寸、操作系统等。</li><li>客户端语言。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>部署应用有很多种方法，实际采用哪种方式取决于需求和预算。当发布到开发或者模拟环境时，停机或者滚动部署是一个好选择，因为干净和快速。当发布到生产环境时，滚动部署或者蓝绿部署通常是一个好选择，但新平台的主流程测试是必须的。<br>蓝绿部署也不错，但需要额外的资源。如果应用缺乏测试或者对软件的功能和稳定性影响缺乏信心，那么可以使用金丝雀部署或者 AB 测试发布。如果业务需要根据地理位置、语言、操作系统或者浏览器特征等参数来给一些特定的用户测试，那么可以采用 AB 测试技术</p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL Server层</title>
      <link href="2020/11/25/MySQL-Server%E5%B1%82/"/>
      <url>2020/11/25/MySQL-Server%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p><img src="mysql.jpg"></p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。<br>即：这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接</p><p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p><p>解决方案：</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端</p><p>查询缓存往往弊大于利。<br>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存</p><p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure><p>MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>对 SQL 语句做解析<br>先进行【词法解析】需要识别出里面的字符串分别是什么，代表什么，例如 输入的”select”这个关键字识别出来，这是一个查询语句。也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”<br>然后进行【语法解析】语法分析器会根据语法规则，判断输入的 SQL 语句是否满足 MySQL 语法，如果不对 就会收到“You have an error in your SQL syntax”的错误提醒</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>开始执行的时候，要先判断一下对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)<br>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口</p><p>对于没有索引的字段查询</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端</li></ol><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的</p><p>可以在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL日志模块</title>
      <link href="2020/11/25/MySQL%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/"/>
      <url>2020/11/25/MySQL%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>redo log（重做日志）和 binlog（归档日志）</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本<br>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间</p><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写<br><img src="redoLog.jpg"></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。<br>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。<br>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe</p><h3 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h3><p>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力</p><p>这两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</li></ol><p>InnoDB 引擎在执行 update 语句时的内部流程</p><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p><img src="update.jpg"></p><h4 id="两段提交"><a href="#两段提交" class="headerlink" title="两段提交"></a>两段提交</h4><p>binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备</p><p>redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><p>即物理日志 redo log 和逻辑日志 binlog。redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。<br>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之常见设计模式</title>
      <link href="2020/11/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/11/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><hr><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>单例模式在内存中只有一个实例，减少了内存开支，特别是一个频繁操作，性能又无法优化的对象。<br>减少性能开销，如读取配置、产生其他依赖对象时，启动一个对象，永久驻留内存。<br>可以避免一个对象的多重占用，例如一个写文件动作。<br>可以设置系统全局访问点，优化和共享资源访问。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>单例模式一般没有接口，无法扩展。<br>无法测试，如果代码未完成则无法测试，且因没有接口所以无法mock。<br>单例模式与单一职责原则有冲突，类应只关心内部实现，而不关心外部如何调用。</p><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><p>要求生成唯一序列号的环境。<br>整个项目中需要一个共享访问点或共享数据，如页面访问计数器。<br>创建消耗资源过多的对象。<br>需要定义大量静态常量和静态方法的环境。</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>有上限的多例模式，可以定义内部列表存储实例，然后根据条件返回某实例。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><hr><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。<br>在工厂方法模式中，抽象产品类Product负责定义产品的共性，实现对事物最抽象的定义；<br>Creator为抽象创建类， 也就是抽象工厂， 具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>良好的封装性，代码接口清晰，调用者只需要知道产品约束字符串就可以。<br>扩展性高，增加产品时，只需要修改工厂类或扩展一个工厂类。<br>屏蔽产品类，例如切换数据库。<br>典型的解耦框架，只知道抽象类，符合迪米特法则；只依赖产品抽象，符合依赖倒置原则；使用子类替换父类，符合里氏替换原则。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在new一个对象的地方都可以使用，尤其是复杂对象时。<br>需要灵活、可扩展框架时可使用，如邮件，支持POP3、IMAP、HTTP。<br>可用在异构项目中。<br>测试驱动开发的框架下，模拟一个类。</p><h4 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h4><p>简单工厂模式：去掉继承抽象类，并在工厂创建对象方法前增加static关键字；<br>多工厂模式：每个产品对应一个创建工厂，好处是职责清洗符合单一职责原则，但不宜扩展和维护，一般新增一个协调类，来封装子工厂。<br>替代单例模式：工厂内设置静态对象。<br>延迟加载：保存特定对象在工厂，需要时直接返回，如数据库最大连接数对象。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><hr><p>定义：为创建一组相关或相互依赖的对象提供一个接口，而且无须指定他们的具体类。在场景类中，没有任何一个方法与实现类有关系。<br>产品族：指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如不同品牌的电视机。<br>产品等级结构：产品的继承结构，如抽象类是电视机，其子类有海尔电视机、海信电视机。</p><p>有N个产品族，在抽象工厂类中就应该有N个创建方法。<br>有M个产品等级就应该有M个实现工厂类，在每个实现工厂中，实现不同产品族的生产任务。</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>封装性，每个产品的实现类不需要高层模块关心，只需关心接口抽象。<br>产品族内的约束为非公开状态，具体约束实在工厂内实现，高层无须关心。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>产品族扩展非常困难，例如新增一个品牌产品，要在所有工厂方法中新增创建产品方法。</p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>一个对象族或是一组没有任何关系的对象都有相同的约束，则可以使用抽象工厂模式。在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，涉及不同操作系统，可以使用抽象工厂模式进行设计。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><hr><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>基本方法：就是基本操作，是有子类实现的方法，并且在模板方法中被调用。<br>模板方法：可以有一个或几个，实现对基本方法的调度，完成固定逻辑。</p><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><p>封装不变部分，扩展可变部分<br>提取公共部分代码，便于维护<br>行为有父类控制，子类实现</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>如果具体实现过多，需要开发人员话时间去理清关系。</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>多个子类有公有方法，并且逻辑基本相同<br>重要、复杂的算法，可以把核心算法设计为模板方法，周边则有子类实现<br>.NET中重写控件事件就是模板方法模式</p><h4 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h4><p>可以设置一个钩子方法，从而使子类控制流程走向。</p><h3 id="建造者模式（创建型模式）"><a href="#建造者模式（创建型模式）" class="headerlink" title="建造者模式（创建型模式）"></a>建造者模式（创建型模式）</h3><hr><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>也叫生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，如制造汽车需要发动机、轮胎。<br>构成角色：<br>Product产品类：通常是实现了模板方法模式，有模板方法和基本方法。<br>Builder抽象建造者：规范产品的组建，一般是由子类实现。<br>ConcreteBuilder具体建造者：实现抽象类定义的所有方法，并且返回一个组建好的对象。<br>Director导演类：负责安排已有模块的顺序，然后告诉Builder开始建造。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>封装性，客户端不用关心产品内部组成的细节。<br>建造者独立，容易扩展。<br>便于控制细节风险，因为建造者是独立的，因此可对建造过程细化。</p><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>相同方法，不同执行顺序，产生不同的事件结果。<br>多个部件，都可以装配到一个对象，但产生结果不同时。<br>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能。<br>建造者模式关注的是零件类型和装配顺序，这是与工厂方法模式的最大不同地方。</p><h3 id="代理模式（结构型模式）"><a href="#代理模式（结构型模式）" class="headerlink" title="代理模式（结构型模式）"></a>代理模式（结构型模式）</h3><hr><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>为其他对象提供一种代理以控制这个对象的访问，并由代理对象控制对原对象的引用。</p><h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><p>职责清晰，降低耦合，真实角色只关心自己业务逻辑，不用关心相关但非本职的事务，都通过后期代理完成。<br>高扩展性，保护目标对象，真实角色可随时发生变化，但依赖接口，所以代理类可不做任何修改。</p><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>造成请求速度变慢。<br>代理类需要额外工作，增加系统复杂度。</p><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><p>动态代理：AOP面向切面编程就是通过动态代理模式实现的。<br>远程代理：远程调用操作。<br>保护代理：保护一个对象的访问，可以给不同用户提供不同权限。<br>缓冲代理，为莫以目标操作的结果提供临时存储空间，多个客户端共享。<br>防火墙代理：保护目标不让恶意用户接近。<br>同步代理：同步化，使几个用户能同时使用一个对象而没有冲突。<br>智能引用代理，当一个对象被引用时，提供额外的操作。<br>虚拟代理，如果要创建一个资源消耗大的对象，可以先创建一个代理表示，等需要时才真正创建。</p><h3 id="原型模式（结构型模式）"><a href="#原型模式（结构型模式）" class="headerlink" title="原型模式（结构型模式）"></a>原型模式（结构型模式）</h3><hr><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>用原型实例指定创建对象的种类(自身类型)，并且通过拷贝这些原型创建新的对象。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>性能优良，是在内存中二进制流的拷贝，比直接new一个对象性能好很多。<br>逃避构造函数约束，这是优点也是缺点。</p><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><p>资源优化场景，如类初始化需要消化非常多的资源。<br>性能和安全要求的场景，通过new创建需要非常繁琐的数据准备或访问权限。<br>一个对象多个修改者的场景。<br>注意：原型模式，构造函数是不会执行的。</p><h3 id="中介者模式（行为型模式）"><a href="#中介者模式（行为型模式）" class="headerlink" title="中介者模式（行为型模式）"></a>中介者模式（行为型模式）</h3><hr><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，起到中转和协调作用，从而使其耦合松散，而且可独立改变他们之间的交互。<br>组成角色：<br>Mediator抽象中介者角色，定义统一的接口，用于各同事角色之间的通信。<br>Concrete Mediator具体中介者角色，通过协调各同事角色实现协作行为，必须依赖各个同事角色。<br>Colleague同事角色，都知道中介者角色，通过中介者协作。</p><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>减少类间依赖，把原本一对多的依赖变成一对一的依赖。</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>中介者会膨胀的很大，而且逻辑复杂，同事类越多，中介者就越复杂。</p><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><p>类图中出现了蜘蛛网状接口，使用中介者模式变成星型结构。<br>MVC框架，Controller就是一个中介者。<br>聊天室</p><h4 id="最佳实践："><a href="#最佳实践：" class="headerlink" title="最佳实践："></a>最佳实践：</h4><p>N个对象之间产生了相互依赖关系。<br>多个对象有依赖关系，但是需求不确定，采用中介者模式，可降低变更引起的风险。</p><h3 id="命令模式（行为型模式）"><a href="#命令模式（行为型模式）" class="headerlink" title="命令模式（行为型模式）"></a>命令模式（行为型模式）</h3><hr><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。<br>组成角色：<br>Receive接收者角色，最终执行的方法。<br>Command抽象命令角色，需要执行的所有命令都在这里生命。<br>Invoker调用者角色，接收到命令，并执行命令。<br>Client客户角色，发出一个具体的命令并确定其接受者。<br>ConcreteCommand具体命令角色，定义一个接受者和行为的弱耦合，负责调用接受者相应方法。</p><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><p>新的命令可以很容易的加入到系统中。<br>类间解耦，调用者和接收者之间没有任何依赖关系，调用者只需要调用Command抽象类的execute方法就可以，不需要知道具体执行者。<br>可扩展性，Command的子类可以非常容易的扩展，高层不产生要种的代码耦合。<br>可以比较容易的设计一个命令队列和组合命令，命令模式可以结合责任链模式，实现命令族解析任务；可以结合模板方法模式，则可减少Command子类的膨胀问题。</p><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>如果有N个命令，则需要创建N个Command子类。</p><h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><p>系统需要支持命令的撤销。<br>系统需要在不同的时间指定请求、将请求排队。<br>如果系统需要将所有操作记录日志，以便崩溃时从日志恢复。<br>如果需要执行回调。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><hr><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，知道有对象处理它为止。<br>涉及角色：<br>Handler抽象处理者角色，定义一个处理请求的接口。<br>ConcreteHandler具体处理者角色，具体处理者接受到请求后，可以选择处理，或传给下一个处理者。<br>抽象处理者二个职责：<br>定义一个请求的处理方法handleMessage，是唯一对外开放的方法；<br>定义一个链的编排属性setNext，设置下一个处理者；<br>具体处理者涉及两个类：Request类负责封装请求，Response负责封装链中返回的结果。</p><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><p>将请求和处理分开，双方可互不相识，两者解耦，提高系统灵活性。</p><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><p>性能问题，每个请求都是从链头遍历到链尾。<br>调试不方便，采用了类似递归的方式，调试的时候逻辑可能比较复杂。</p><h4 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h4><p>一个系统的审批需要多个对象才能完成处理的情况下，例如请假系统。<br>代码中存在多个if-else语句的情况下，可以考虑使用责任链模式来对代码进行重构。</p><h3 id="装饰模式（结构型模式）"><a href="#装饰模式（结构型模式）" class="headerlink" title="装饰模式（结构型模式）"></a>装饰模式（结构型模式）</h3><hr><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h4><p>动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更加灵活。<br>涉及角色：<br>Component抽象构件，是一个接口或抽象类，定义最核心的对象，也就是最原始的对象。<br>ConcreteComponent具体构件，要装饰的对象。<br>Decorator抽象装饰角色，有一个执行抽象构件的属性，若只有一个装饰类则无需此类。<br>ConcreteDecorator具体装饰角色，负责对原始对象进行装饰。</p><h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><p>装饰类和被装饰类可以独立发展，而不会互相耦合。<br>装饰模式是继承关系的一个替代方案。<br>装饰模式可以动态地扩展一个实现类的功能。<br>可以通过不同装饰类，创建出不同的组合。</p><h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><p>多层装饰提高了系统的复杂度。</p><h4 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h4><p>需要扩展一个类的功能，或者给一个类增加附加功能。<br>需要动态给一个对象增加功能，这些功能可以再动态地撤销。<br>需要为一批的兄弟类进行改装或加装功能，首选装饰模式。</p><h3 id="策略模式（行为型模式）"><a href="#策略模式（行为型模式）" class="headerlink" title="策略模式（行为型模式）"></a>策略模式（行为型模式）</h3><hr><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h4><p>也叫政策模式，定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。<br>涉及角色：<br>Context封装角色，也叫上下文角色，承上启下，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。<br>Strategy抽象策略角色，定义每个策略或算法必须具有的方法和属性的接口。<br>ConcreteStrategy具体策略角色，实现抽象策略的操作，含有具体算法。<br>和代理模式区别，在于Context封装角色和被封装的策略类不是用的同一个接口。</p><h4 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h4><p>算法可以自由切换。<br>避免使用多重条件判断。<br>扩展性良好，如List中IComparer实现排序一样，可轻松增加一个策略，其他都不用修改。</p><h4 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h4><p>策略类数量增多。<br>所有的策略类都需要对外暴露。</p><h4 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h4><p>多个类只有在算法或行为上稍有不同的场景。<br>算法需要自由切换的场景，如经常变化的业务场景。<br>需要屏蔽算法规则的场景。</p><h3 id="适配器模式（结构型模式）"><a href="#适配器模式（结构型模式）" class="headerlink" title="适配器模式（结构型模式）"></a>适配器模式（结构型模式）</h3><hr><h4 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h4><p>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。<br>又叫做变压器模式，也叫做包装模式。<br>涉及角色：<br>Target目标角色，该角色定义把其他类转换为何种接口，也就是我们期望接口。<br>Adaptee源角色，被转换的类。<br>Adapter适配器角色，通过继承或类关联的方式，把源角色转换为目标角色。</p><h4 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h4><p>可以让两个没有任何关系的类在一起运行。<br>增加了类的透明性<br>提高了类的复用度<br>灵活性好，想用就用不想用就卸载。</p><h4 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h4><p>采用了多继承，带来了高耦合。</p><h4 id="应用场景-9"><a href="#应用场景-9" class="headerlink" title="应用场景"></a>应用场景</h4><p>有动机修改一个已经投产中的接口时，适配器模式可能就是最合适的。<br>适配器模式是提供给正在运行的项目使用，项目设计时不要考虑。<br>对象是适配器，和类适配器的区别是，类适配器是类间继承，对象适配器是对象的合成关系，也就是关联关系。</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><hr><h4 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h4><p>它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。<br>组成角色<br>Iterator抽象迭代器：负责定义访问和遍历元素的接口。<br>ConcreteIterator具体迭代器：实现迭代器接口，完成元素遍历。<br>Aggregate抽象容器：容器角色负责提供创建具体迭代器角色的接口。<br>ConcreteAggregate具体容器：实现容器接口，创建出容纳迭代器的对象。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><hr><h4 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h4><p>合成模式，部分整体模式，将对象组合成树形结构表示部分整体的层次结构，使得用户对单个对象和组合对象的使用具有一致性。<br>组成角色：<br>Component抽象构件角色，定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。<br>Leaf叶子构件，叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。<br>Composite树枝构件，它的作用是组合树枝节点和叶子节点形成一个树形结构。</p><h4 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h4><p>高层模块调用简单，节点自由增加。</p><h4 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h4><p>直接使用实现类，违法依赖倒置原则。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。<br>从一个整体中能够独立出部分模块或功能的场景。<br>注意，只要是树形结构，就可以考虑组合模式。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><hr><h4 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h4><p>也叫发布订阅模式，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。<br>组成角色：<br>Subject抽象被观察者，定义必须实现的职责，必须能够动态增加、取消观察者。并通知观察者。<br>Observer抽象观察者，观察者收到消息后，进行update操作，对接收到的信息进行处理。<br>ConcreteSubject具体被观察者，定义自己的业务逻辑，同时定义对哪些事件进行通知。<br>ConcreteObserver具体观察者，每个观察者在接收到消息后的处理反应是不同的，有各自处理方法。</p><h4 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h4><p>观察者和被观察者之间是抽象耦合<br>建立一套触发机制，符合单一职责原则。</p><h4 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h4><p>多个观察者，开发和调试负责，一个卡壳会影响整体执行效率。</p><h4 id="应用场景-10"><a href="#应用场景-10" class="headerlink" title="应用场景"></a>应用场景</h4><p>关联行为场景，关联行为是可拆分的。<br>事件多级触发场景。<br>跨系统的消息交换场景，如消息队列的处理机制。<br>注意：<br>广播链问题，多级关联<br>异步处理，如果处理时间较长，可以使用异步</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>文件系统，新增文件通知目录管理器增加该目录<br>广播收音机，电台是被观察者，收音机是观察者。</p><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><hr><h4 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h4><p>也叫外观模式，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，门面模式提供一个高层次的接口，使得子系统更易于使用。<br>组成角色：</p><p>Facade门面角色，客户端调用这个角色，此角色知晓子系统所有的功能和责任。无实际业务逻辑，只做跳板。<br>SubSystem子系统角色，可以同时又一个或者多个子系统，对于子系统门面角色只是另外一个客户端而已。</p><h4 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h4><p>减少系统的相互依赖，所有的依赖都是对门面对象的依赖，与子系统无关。<br>提高了灵活性，不管内部如何变化，只要不影响门面对象，任你自由活动。<br>提高安全性，只能访问门面角色内的方法。</p><h4 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h4><p>不符合开闭原则</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>为一个复杂的模块或子系统提供一个供外界访问的接口<br>子系统相对独立的情况，外界对子系统的访问只要黑箱操作即可<br>一般一个系统只需要一个门面，如果超过200行建议拆成多个门面<br>门面角色中不能有任何分支逻辑、顺寻执行逻辑否则会引子系统必须依赖门面才能被访问的问题。</p><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><hr><h4 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h4><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存，使对象可恢复到原来保存的状态。<br>组成角色：<br>Originator发起人角色，负责创建和恢复备忘录数据。<br>Memento备忘录角色，负责存储Originator发起人角色内部状态。<br>Caretaker备忘录管理员角色，对备忘录进行保存、管理和提供备忘录。</p><h4 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h4><p>需要保存和恢复数据的相关状态场景。<br>提供一个可回滚的操作，如CTRL+Z。</p><h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><p>可以使用clone实现对自身状态的管理。<br>可以使用反射实现类下所有属性的状态管理。<br>使用列表管理备忘录，可实现多备份。</p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><hr><h4 id="定义-17"><a href="#定义-17" class="headerlink" title="定义"></a>定义</h4><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。<br>组成角色：<br>Visitor抽象访问者，抽象类或接口，声明访问者可以访问哪些元素，就是方法接收的参数。<br>ConcreteVisitor具体访问者，实现访问者访问到一个类后干什么。<br>Element抽象元素，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。<br>ObectStruture结构对象，元素产生者，一般容纳在多个不同类、不同接口，如List、Set、Map，项目中一般很少抽象出这个角色。</p><h4 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h4><p>符合单一职责原则<br>优秀扩展性<br>灵活性高，比如针对不同对象，不同处理，可以不适用if</p><h4 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h4><p>具体元素对访问者公布细节<br>具体元素变更比较困难<br>违背了依赖倒置原则，访问者依赖的是具体元素，而不是抽象元素。</p><h4 id="应用场景-11"><a href="#应用场景-11" class="headerlink" title="应用场景"></a>应用场景</h4><p>需要对一个对象结构中的对象进行很多不同并且不相关的操作。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><hr><h4 id="定义-18"><a href="#定义-18" class="headerlink" title="定义"></a>定义</h4><p>当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了它的类。<br>组成角色：<br>State抽象状态角色：负责对状态定义，并且封装环境角色以实现状态切换。<br>ConcreteState具体状态角色：必须有2个职责，本状态下要做的事，和本状态如何过渡到其他状态。<br>Context环境角色：定义客户端需要的接口，并且负责具体状态的切换。</p><h4 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h4><p>结构清晰、遵循设计原则、封装性好</p><h4 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h4><p>子类会很多。</p><h4 id="应用场景-12"><a href="#应用场景-12" class="headerlink" title="应用场景"></a>应用场景</h4><p>行为随状态改变而改变的场景，如权限设计，不同人，不同结果。<br>条件、分支判断语句的替代者。</p><h3 id="解析器模式"><a href="#解析器模式" class="headerlink" title="解析器模式"></a>解析器模式</h3><hr><h4 id="定义-19"><a href="#定义-19" class="headerlink" title="定义"></a>定义</h4><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>重复发生的问题可以使用解释器模式，如收集不同格式日志。</p><h3 id="亨元模式"><a href="#亨元模式" class="headerlink" title="亨元模式"></a>亨元模式</h3><hr><h4 id="定义-20"><a href="#定义-20" class="headerlink" title="定义"></a>定义</h4><p>使用共享对象可有效地支持大量的细粒度的对象。建立对象池。<br>组成角色：</p><p>Flyweight抽象亨元角色，一个产品的抽象类，定义出对象的外部状态和内部状态的接口或实现。<br>ConcreteFlyweight具体亨元角色，产品类，不能同时修改内部状态，外部状态。<br>unsharedConcreteFlyweight不可共享的亨元角色，一般不会出现在亨元工厂中。<br>FlyweightFactory亨元工厂，构造一个池容器，同时提供从池中获得对象的方法。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>大大减少应用程序创建的对象，降低内存占用，增强性能，同时提高了系统复杂性，需要分离外部内部状态，且外部状态固化。</p><h4 id="应用场景-13"><a href="#应用场景-13" class="headerlink" title="应用场景"></a>应用场景</h4><p>系统中存在大量相似对象<br>需要缓冲池的场景</p><h3 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h3><hr><h4 id="定义-21"><a href="#定义-21" class="headerlink" title="定义"></a>定义</h4><p>也叫桥接模式，将抽象和实现解耦，使得两者可以独立地变化。<br>组成角色：<br>Abstraction抽象化角色，定义出该角色的行为，同时保存一个实现化角色的引用，一般是抽象类。<br>Implementor实现化角色，它是接口或者抽象类，定义角色必须的行为和属性。<br>RefinedAbstraction修正抽象化角色，引用实现化角色对抽象化角色进行修正。<br>ConcreteImplementor具体实现化角色，它实现接口或抽象类定义的方法和属性。<br>抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的<br>尽量把最可能的变化封装到最小的逻辑单元，如果有多层继承，则考虑桥梁模式。<br>就像遥控器不包含开机、换台功能，只包含对电视机功能描述的接口引用，实现是有电视机完成。</p><h4 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h4><p>抽象实现分离，为了解决继承的缺点而提出的设计模式，该模式下实现可以不受抽象的约束。<br>优秀的扩充能力。<br>实现细节对客户透明，客户不用关心实现细节。</p><h4 id="应用场景-14"><a href="#应用场景-14" class="headerlink" title="应用场景"></a>应用场景</h4><p>不希望或不适用使用继承的场景<br>接口或抽象类不稳定的场景<br>重用性要求较高的场景</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis知识点整理</title>
      <link href="2020/11/24/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>2020/11/24/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>Redis 持久化机制</li><li>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</li><li>热点数据和冷数据是什么</li><li>Memcache与Redis的区别都有哪些？</li><li>单线程的redis为什么这么快</li><li>redis的数据类型，以及每种数据类型的使用场景，Redis 内部结构</li><li>redis的过期策略以及内存淘汰机制</li><li>Redis 为什么是单线程的，优点</li><li>如何解决redis的并发竞争key问题</li><li>Redis 集群方案应该怎么做？都有哪些方案？</li><li>有没有尝试进行多机redis 的部署？如何保证数据一致的？</li><li>对于大量的请求怎么样处理</li><li>Redis 常见性能问题和解决方案？</li><li>讲解下Redis线程模型</li><li>为什么Redis的操作是原子性的，怎么保证原子性的？</li><li>Redis事务</li><li>Redis实现分布式锁</li></ul><h3 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h3><p>Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。<br>    实现：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。<br>    RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）<br>    AOF：Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。<br>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p><h3 id="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题"><a href="#缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题" class="headerlink" title="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题"></a>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间<br>(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。<br>解决办法：<br>大多数系统设计者考虑用加锁（最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。<br>解决办法：<br>最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<br>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。<br>5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？<br>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。<br>Bitmap： 典型的就是哈希表<br>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。<br>布隆过滤器（推荐）<br>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。<br>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。<br>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。<br>受提醒补充：缓存穿透与缓存击穿的区别<br>缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据。<br>解决方案;在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。<br>增：给一个我公司处理的案例：背景双机拿token，token在存一份到redis，保证系统在token过期时都只有一个线程去获取token;线上环境有两台机器，故使用分布式锁实现。</p><h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！<br>解决思路：</p><ol><li>直接写个缓存刷新页面，上线时手工操作下；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存；</li></ol><h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><ol><li>定时去清理过期的缓存；</li><li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</li></ol><h4 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h4><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<br>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。<br>以参考日志级别设置预案：</p><ol><li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li><li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。<br>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</li></ol><h3 id="热点数据和冷数据是什么"><a href="#热点数据和冷数据是什么" class="headerlink" title="热点数据和冷数据是什么"></a>热点数据和冷数据是什么</h3><p>热点数据，缓存才有价值<br>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存<br>对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。<br>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。<br>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。<br>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p><h3 id="Memcache与Redis的区别都有哪些"><a href="#Memcache与Redis的区别都有哪些" class="headerlink" title="Memcache与Redis的区别都有哪些"></a>Memcache与Redis的区别都有哪些</h3><ol><li>存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据</li><li>数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储</li><li>使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。</li><li>redis的速度比memcached快很多</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ol><h3 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" class="headerlink" title="单线程的redis为什么这么快"></a>单线程的redis为什么这么快</h3><ol><li>纯内存操作</li><li>单线程操作，避免了频繁的上下文切换</li><li>采用了非阻塞I/O多路复用机制</li></ol><h3 id="redis的数据类型，以及每种数据类型的使用场景"><a href="#redis的数据类型，以及每种数据类型的使用场景" class="headerlink" title="redis的数据类型，以及每种数据类型的使用场景"></a>redis的数据类型，以及每种数据类型的使用场景</h3><ol><li>String<br>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。</li><li>hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</li><li>list<br>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。</li><li>set<br>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</li><li>sorted set<br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。</li></ol><h3 id="Redis-内部结构"><a href="#Redis-内部结构" class="headerlink" title="Redis 内部结构"></a>Redis 内部结构</h3><ul><li>dict 本质上是为了解决算法中的查找问题（Searching）是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。 本质上是为了解决算法中的查找问题（Searching）</li><li>sds sds就等同于char * 它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结 束，因此它必然有个长度字段。</li><li>skiplist （跳跃表） 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现</li><li>quicklist</li><li>ziplist 压缩表 ziplist是一个编码后的列表，是由一系列特殊编码的连续内存块组成的顺序型数据结构</li></ul><h3 id="Redis的过期策略以及内存淘汰机制"><a href="#Redis的过期策略以及内存淘汰机制" class="headerlink" title="Redis的过期策略以及内存淘汰机制"></a>Redis的过期策略以及内存淘汰机制</h3><h4 id="redis采用的是定期删除-惰性删除策略。"><a href="#redis采用的是定期删除-惰性删除策略。" class="headerlink" title="redis采用的是定期删除+惰性删除策略。"></a>redis采用的是定期删除+惰性删除策略。</h4><p>为什么不用定时删除策略?<br>定时删除,用一个定时器来负责监视key，过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key，因此没有采用这一策略。</p><h4 id="定期删除-惰性删除是如何工作的"><a href="#定期删除-惰性删除是如何工作的" class="headerlink" title="定期删除+惰性删除是如何工作的"></a>定期删除+惰性删除是如何工作的</h4><p>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p><h4 id="采用定期删除-惰性删除就没其他问题了么"><a href="#采用定期删除-惰性删除就没其他问题了么" class="headerlink" title="采用定期删除+惰性删除就没其他问题了么?"></a>采用定期删除+惰性删除就没其他问题了么?</h4><p>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。<br>在<code>redis.conf</code>中有一行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure><p>该配置就是配内存淘汰策略的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">volatile-lru #从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</span><br><span class="line">volatile-ttl #从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</span><br><span class="line">volatile-random #从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</span><br><span class="line">allkeys-lru #从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</span><br><span class="line">allkeys-random #从数据集（server.db[i].dict）中任意选择数据淘汰</span><br><span class="line">no-enviction（驱逐）#禁止驱逐数据，新写入操作会报错</span><br></pre></td></tr></table></figure><p>ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p><h3 id="Redis-为什么是单线程的"><a href="#Redis-为什么是单线程的" class="headerlink" title="Redis 为什么是单线程的"></a>Redis 为什么是单线程的</h3><p>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问。</p><ol><li>绝大部分请求是纯粹的内存操作（非常快速）</li><li>采用单线程,避免了不必要的上下文切换和竞争条件</li><li>非阻塞IO优点：<ol><li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li><li>支持丰富数据类型，支持string，list，set，sorted set，hash</li><li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题</li></ol></li></ol><h3 id="同时有多个子系统去set一个key。这个时候要注意什么"><a href="#同时有多个子系统去set一个key。这个时候要注意什么" class="headerlink" title="同时有多个子系统去set一个key。这个时候要注意什么"></a>同时有多个子系统去set一个key。这个时候要注意什么</h3><p>不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。</p><ol><li>如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可</li><li>如果对这个key操作，要求顺序：分布式锁+时间戳。假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</li><li>利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证读写key的一致性，对redis的操作都是具有原子性的，是线程安全的操作，你不用考虑并发问题，redis内部已经帮你处理好并发的问题了</li></ol><h3 id="Redis-集群方案应该怎么做？都有哪些方案"><a href="#Redis-集群方案应该怎么做？都有哪些方案" class="headerlink" title="Redis 集群方案应该怎么做？都有哪些方案"></a>Redis 集群方案应该怎么做？都有哪些方案</h3><ol><li><code>twemproxy</code>，大概概念是，它类似于一个代理方式，使用时在本需要连接 <code>redis</code> 的地方改为连接 <code>twemproxy</code>， 它会以一个代理的身份接收请求并使用一致性 <code>hash</code> 算法，将请求转接到具体 <code>redis</code>，将结果再返回 <code>twemproxy</code>。<br>缺点： twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</li><li><code>codis</code>，目前用的最多的集群方案，基本和 <code>twemproxy</code> 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 <code>hash</code> 节点</li><li><code>redis cluster3.0</code> 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 <code>hash 槽</code>的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</li></ol><h3 id="有没有尝试进行多机redis-的部署？如何保证数据一致的"><a href="#有没有尝试进行多机redis-的部署？如何保证数据一致的" class="headerlink" title="有没有尝试进行多机redis 的部署？如何保证数据一致的"></a>有没有尝试进行多机redis 的部署？如何保证数据一致的</h3><p>主从复制，读写分离<br>一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库</p><h3 id="对于大量的请求怎么样处理"><a href="#对于大量的请求怎么样处理" class="headerlink" title="对于大量的请求怎么样处理"></a>对于大量的请求怎么样处理</h3><p>redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求；<br>redis是通过IO多路复用（select，epoll, kqueue，依据不同的平台，采取不同的实现）来处理多个客户端请求的</p><h3 id="Redis-常见性能问题和解决方案"><a href="#Redis-常见性能问题和解决方案" class="headerlink" title="Redis 常见性能问题和解决方案"></a>Redis 常见性能问题和解决方案</h3><ol><li>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件</li><li>如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次</li><li>为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内</li><li>尽量避免在压力很大的主库上增加从库</li><li>主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…</code></li></ol><h3 id="讲解下Redis线程模型"><a href="#讲解下Redis线程模型" class="headerlink" title="讲解下Redis线程模型"></a>讲解下Redis线程模型</h3><p>文件事件处理器包括分别是套接字、 <code>I/O</code> 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。使用 <code>I/O</code> 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br>工作原理：<br>尽管多个文件事件可能会并发地出现， 但 <code>I/O</code> 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字。<br><img src="icofeh.png" alt="文件时间处理器"></p><h3 id="为什么Redis的操作是原子性的，怎么保证原子性的"><a href="#为什么Redis的操作是原子性的，怎么保证原子性的" class="headerlink" title="为什么Redis的操作是原子性的，怎么保证原子性的"></a>为什么Redis的操作是原子性的，怎么保证原子性的</h3><p>对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。<br>Redis的操作之所以是原子性的，是因为Redis是单线程的。<br>Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。<br>多个命令在并发中也是原子性的吗？<br>不一定，将get和set改成单命令操作，incr。使用Redis的事务，或者使用Redis+Lua==的方式实现</p><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的<br>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p><ol><li>redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</li><li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</li><li>如果在一个事务中出现运行错误，那么正确的命令会被执行。</li></ol><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><blockquote><p>注：redis的discard只是结束本次事务,正确命令造成的影响仍然存在.</p></blockquote><ol><li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li><li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。</li><li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。</li><li>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li></ol><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。<br>将 key 的值设为 value ，当且仅当 key 不存在。 若给定的 key 已经存在，则 SETNX 不做任何动作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx lockKey value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx lockKey value2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get lockKey</span><br><span class="line">&quot;value1&quot;</span><br></pre></td></tr></table></figure><p>解锁：使用 del key 命令就能释放锁<br>解决死锁：<br>1）通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。<br>2） 使用 setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务</title>
      <link href="2020/11/22/MySQL%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/11/22/MySQL%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 <code>MySQL</code> 中，事务支持是在引擎层实现的。你现在知道，<code>MySQL</code> 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 <code>MySQL</code> 原生的 <code>MyISAM</code>引擎就不支持事务，这也是 <code>MyISAM</code> 被 <code>InnoDB</code> 取代的重要原因之一。</p><h2 id="四大特性（ACID）"><a href="#四大特性（ACID）" class="headerlink" title="四大特性（ACID）"></a>四大特性（ACID）</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><hr><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br>简单说就是：一个事务要么完成要么失败</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>InnoDB存储引擎提供了undo log(回滚日志)，在undo log中保存了和执行操作相反的记录，如果事务执行失败则会执行rollback，这时就需要使用到undo log中的日志记录。例：写入2个insert，那就会记录下对应的2个delete<br>什么时候删除回滚日志？在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。就是当系统里没有比这个回滚日志更早的 <code>read-view</code>的时候。</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><hr><p>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><hr><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>数据存放在磁盘，每次都需要从磁盘读取数据，效率很低，所以innoDB提供了缓存，每次写入数据都是先写入缓存中，缓存中的数据会定时刷新磁盘。<br>这样就带来了一个问题，数据写入缓存后，服务器宕机了怎么办，数据是不是就丢失了？<br>要真数据丢失了，就没人用mysql了吧，每次写入时先写入redo log再写入缓存。就算宕机了，也可以从redo log中恢复数据，再更新缓存，保证了数据的持久性。</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><hr><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read 读到其他事物未提交的数据）、不可重复读（non-repeatable read 前后读取的数据不一致）、幻读（phantom read 前后读取的数量不一致）的问题，为了解决这些问题，就有了“隔离级别”的概念。<br>隔离性追求的是并发情形下事务之间互不干扰。</p><h4 id="关于脏读、不可重复读、幻读"><a href="#关于脏读、不可重复读、幻读" class="headerlink" title="关于脏读、不可重复读、幻读"></a>关于脏读、不可重复读、幻读</h4><ol><li>脏读：当前事务(A)中可以读到其他事务(B)未提交的数据</li></ol><table><thead><tr><th align="center">时间</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center">开始</td><td align="center">开始</td></tr><tr><td align="center">T2</td><td align="center">查询张三数学分数60</td><td align="center"></td></tr><tr><td align="center">T3</td><td align="center"></td><td align="center">修改张三数学分数为65</td></tr><tr><td align="center">T4</td><td align="center">查询张三数学分数65</td><td align="center"></td></tr><tr><td align="center">T5</td><td align="center"></td><td align="center">提交事务</td></tr></tbody></table><p>我们可以清楚的看见事务B在T5时刻在提交，事务A却在T4时已经读到事务B提交的内容了</p><ol start="2"><li>不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样</li></ol><table><thead><tr><th align="center">时间</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center">开始</td><td align="center">开始</td></tr><tr><td align="center">T2</td><td align="center">查询张三数学分数60</td><td align="center"></td></tr><tr><td align="center">T3</td><td align="center"></td><td align="center">修改张三数学分数为65</td></tr><tr><td align="center">T4</td><td align="center"></td><td align="center">提交事务</td></tr><tr><td align="center">T5</td><td align="center">查询张三数学分数65</td><td align="center">-</td></tr></tbody></table><p>可以清楚看见，事务A在两次读取张三的数学分数，取得的结果是不同的。不可重复读与脏读的区别前者为提交后读取的数据不同，后者为未提交读取的数据不同。</p><ol start="3"><li>幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同</li></ol><table><thead><tr><th align="center">时间</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center">开始</td><td align="center">开始</td></tr><tr><td align="center">T2</td><td align="center">查询张三小于60的科目：数学</td><td align="center"></td></tr><tr><td align="center">T3</td><td align="center"></td><td align="center">插入张三英语成绩，59</td></tr><tr><td align="center">T4</td><td align="center"></td><td align="center">提交事务</td></tr><tr><td align="center">T5</td><td align="center">查询张三小于60的科目：数学、英语</td><td align="center">-</td></tr></tbody></table><p>在前后两次查询中，取到的数据条数是不同，幻读与不可重复读前者是查询出的记录条数不同，后者则是查询单条记录不同。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</p><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>首先明确一点，隔离级别越高，效率就会越低。</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><h4 id="各个隔离级别存在的问题"><a href="#各个隔离级别存在的问题" class="headerlink" title="各个隔离级别存在的问题"></a>各个隔离级别存在的问题</h4><table><thead><tr><th align="center">隔离级别</th><th align="center">问题</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">脏读、不可重复读和幻读</td></tr><tr><td align="center">读提交</td><td align="center">不可重复读和幻读</td></tr><tr><td align="center">可重复读</td><td align="center">幻读</td></tr><tr><td align="center">串行化</td><td align="center">没问题</td></tr></tbody></table><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p><h4 id="默认隔离级别"><a href="#默认隔离级别" class="headerlink" title="默认隔离级别"></a>默认隔离级别</h4><p>Oracle : 读提交<br>MySQL : 可重复读<br>因此对于一些从 <code>Oracle</code> 迁移到 <code>MySQL</code> 的应用，为保证数据库隔离级别的一致，要记得将 <code>MySQL</code> 的隔离级别设置为“读提交”<br>MySQL可以这样查看隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>可重复读解决脏读、不可重复读、幻读等问题，使用的是MVCC：MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。<br>MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：</p><ol><li>隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向<code>undo log</code>的指针等。</li><li>基于undo log的版本链：前面说到每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。</li><li>ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本；但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务在某一时刻给整个事务系统（<code>trx_sys</code>）打快照，之后再进行读操作时，会将读取到的数据中的事务id与<code>trx_sys</code>快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。</li></ol><p><code>trx_sys</code>中的主要内容，以及判断可见性的方法如下：</p><ol><li>low_limit_id：表示生成ReadView时系统中应该分配给下一个事务的id。如果数据的事务id大于等于<code>low_limit_id</code>，说明该事务还没执行，则对该ReadView不可见。</li><li>up_limit_id：表示生成ReadView时当前系统中活跃的读写事务中最小的事务id。如果数据的事务id小于<code>up_limit_id</code>，说明该事务已经执行完成，则对该ReadView可见。</li><li>rw_trx_ids：表示生成ReadView时当前系统中活跃的读写事务的事务id列表。如果数据的事务id在<code>low_limit_id</code>和<code>up_limit_id</code>之间，则需要判断事务id是否在<code>rw_trx_ids</code>中：如果在，说明生成ReadView时事务仍在活跃中，因此数据对ReadView不可见；如果不在，说明生成ReadView时事务已经提交了，因此数据对ReadView可见。如下<br><img src="mvcc.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引类型</title>
      <link href="2020/10/24/MySQL%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/10/24/MySQL%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>常见的索引类型 <code>哈希索引</code>、<code>平衡二叉树索引</code>、<code>B树索引</code>、<code>B+树索引</code> 以下对这几类常见索引进行分析</p></blockquote><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><hr><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><code>哈希索引</code>拥有极高的检索效率，索引的检索可以一次到位</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>不能使用范围查询<br> Hash索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询(注意&lt;&gt;和＜＝＞是不同的操作），不能使用范围查询，例如WHERE price &gt; 100。由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤</li><li>Hash索引不能利用部分索引键查询<br> 这个场景主要出现在<code>复合索引</code>，Hash索引在计算Hash值的时候，是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过复合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用</li><li>Hash索引在任何时候都不能避免表扫描<br> Hash索引是将索引键通过Hash运算之后，将 Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中。由于不同索引键存在相同Hash值（哈希碰撞），所以无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果</li></ol><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>又称 AVL树。 它除了具备二叉查找树的基本特征之外，还具有一个非常重要的特点：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值（平衡因子 ）不超过1。也就是说AVL树每个节点的平衡因子只可能是-1、0和1（左子树高度减去右子树高度）<br><img src="2.jpg"></p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>树的高度越高，查找速度越慢</li><li>支持范围查找，但是需要进行回旋查找</li></ol><h3 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h3><hr><p><img src="b.jpg"></p><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>B树和二叉树最大的区别在于：它一个节点可以存储两个值，这就意味着它的树高度，比二叉树的高度更低，它的查询速度就更快</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>在范围查找的时候，存在回旋查询的问题。同样order by排序的时候效率也很低，因为要把树上的数据手动排序一遍</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><hr><p><img src="b+.jpg"></p><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>是B树的升级版，B+树相比B树，新增叶子节点与非叶子节点关系。叶子节点中包含了key和value，key存储的是1-10这些数字，value存储的是数据存储地址，非叶子节点中只是包含了key，不包含value。所有相邻的叶子节点包含非叶子节点，使用链表进行结合，有一定顺序排序，从而范围查询效率非常高</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桶排序，计数排序，基数排序</title>
      <link href="2020/10/22/%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>2020/10/22/%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="一、线性排序算法介绍"><a href="#一、线性排序算法介绍" class="headerlink" title="一、线性排序算法介绍"></a>一、线性排序算法介绍</h3><ol><li>线性排序算法包括桶排序、计数排序、基数排序。</li><li>线性排序算法的时间复杂度为O(n)。</li><li>此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。</li><li>对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。</li></ol><h3 id="二、桶排序（Bucket-sort）"><a href="#二、桶排序（Bucket-sort）" class="headerlink" title="二、桶排序（Bucket sort）"></a>二、桶排序（Bucket sort）</h3><ol><li>算法原理：<ol><li>将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。</li><li>桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</li></ol></li><li>使用条件<ol><li>要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。</li><li>数据在各个桶之间分布是均匀的。</li></ol></li><li>适用场景<ol><li>桶排序比较适合用在外部排序中。</li><li>外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。</li></ol></li><li>应用案例<ol><li>需求描述：<br>有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序但内存有限，仅几百MB</li><li>解决思路：<ul><li>扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。</li><li>第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。</li><li>每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。</li><li>将100个小文件依次放入内存并用快排排序。</li><li>所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。</li></ul></li><li>注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。</li></ol></li></ol><h3 id="三、计数排序（Counting-sort）"><a href="#三、计数排序（Counting-sort）" class="headerlink" title="三、计数排序（Counting sort）"></a>三、计数排序（Counting sort）</h3><ol><li>算法原理<ol><li>计数其实就是桶排序的一种特殊情况。</li><li>当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶</li><li>每个桶内的数据值都是相同的，就省掉了桶内排序的时间。</li></ol></li><li>案例分析：<br>假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。<br>使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。<br>C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。<br>对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。<br>数组R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到R[8]的呢？<br>从后到前依次扫描数组A，比如扫描到3时，可以从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R的第7个元素（也就是数组R中下标为6的位置）。当3放入数组R后，小于等于3的元素就剩下6个了，相应的C[3]要减1变成6。<br>以此类推，当扫描到第二个分数为3的考生时，就会把它放入数组R中第6个元素的位置（也就是下标为5的位置）。当扫描完数组A后，数组R内的数据就是按照分数从小到大排列的了。</li><li>使用条件<ol><li>只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；</li><li>计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；</li><li>比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。</li></ol></li></ol><h3 id="四、基数排序（Radix-sort）"><a href="#四、基数排序（Radix-sort）" class="headerlink" title="四、基数排序（Radix sort）"></a>四、基数排序（Radix sort）</h3><ol><li>算法原理（以排序10万个手机号为例来说明）<ol><li>比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。</li><li>借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。</li><li>经过11次排序后，手机号码就变为有序的了。</li><li>每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。</li></ol></li><li>使用条件<ol><li>要求数据可以分割独立的“位”来比较；</li><li>位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；</li><li>每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。</li></ol></li></ol><h3 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h3><p>1.如何根据年龄给100万用户数据排序？<br>    建1到120个桶，把数据放到桶内。<br>2.对D，a，F，B，c，A，z这几个字符串进行排序，要求将其中所有小写字母都排在大写字母前面，但是小写字母内部和大写字母内部不要求有序。比如经过排序后为a，c，z，D，F，B，A，这个如何实现呢？如果字符串中处理大小写，还有数字，将数字放在最前面，又该如何解决呢？<br>    建数字-小写字母-大写字母三个桶</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https工作原理</title>
      <link href="2020/10/13/https%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>2020/10/13/https%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="https-工作原理"><a href="#https-工作原理" class="headerlink" title="https 工作原理"></a>https 工作原理</h3><p><img src="https.jpeg" alt="https交互"></p><ol><li>客户端发起 HTTPS 请求<br> 这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。</li><li>服务端的配置<br> 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。<br> 这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li><li>传送证书<br> 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</li><li>客户端解析证书<br> 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。<br> 如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li><li>传送加密信息<br> 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li><li>服务端解密信息<br> 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li><li>传输加密后的信息<br> 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</li><li>客户端解密信息<br> 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策</li></ol><h3 id="http-与-https-区别"><a href="#http-与-https-区别" class="headerlink" title="http 与 https 区别"></a>http 与 https 区别</h3><ol><li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ol>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EXPLAIN 执行计划解析</title>
      <link href="2020/09/22/EXPLAIN-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%A7%A3%E6%9E%90/"/>
      <url>2020/09/22/EXPLAIN-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><ul><li>执行计划是数据库根据sql语句和相关表的统计信息做的查询方案，由查询优化器自动产生</li><li>使用<code>explain</code>可以模拟优化器执行sql查询语句</li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id 列的编号就是 select 的序列号，也可以理解为 SQL 执行顺序的标识，有几个 select 就有几个 id</p><ul><li>id 值不同：如果是只查询，id 的序号会递增，id 值越大优先级越高，越先被执行</li><li>id 值相同：从上往下依次执行</li><li>id 列为 null：表示这是一个结果集，不需要使用它来进行查询</li></ul><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询</p><ul><li>simple 表示查询中不包括 union 操作或者子查询，位于最外层的查询的 select_type 即为 simple</li><li>primary 需要 union 操作或者含有子查询的 select，位于最外层的查询的 select_type 即为 primary</li><li>derived：from 列表中出现的子查询，也叫做衍生表；mysql 或者递归执行这些子查询，把结果放在临时表里</li><li>subquery：除了 from 子句中包含的子查询外，其他地方出现的子查询都可能是 subquery</li><li>union：若第二个 select 出现在 union 之后，则被标记为 union；若 union 包含在 from 子句的子查询中，外层 select 将被标记为 derived</li><li>union result：从 union 表获取结果的 select ，因为它不需要参与查询，所以 id 字段为 null</li><li>dependent union：与 union 一样，出现在 union 或 union all 语句中，但是这个查询要受到外部查询的影响</li><li>dependent subquery：与 dependent union 类似，子查询中的第一个 SELECT，这个 subquery 的查询要受到外部表查询的影响</li></ul><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>表示 explain 的一行正在访问哪个表</p><ul><li>如果查询使用了别名，那么这里显示的是别名</li><li>如果不涉及对数据表的操作，那么这显示为 null</li><li>如果显示为尖括号括起来的就表示这个是临时表，后边的 N 就是执行计划中的 id，表示结果来自于这个查询产生</li><li>如果是尖括号括起来的&lt;union M,N&gt;，与类似，也是一个临时表，表示这个结果来自于 union 查询的 id 为 M,N 的结果集</li></ul><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>访问类型，即 MySQL 决定如何查找表中的行<br>依次从好到差：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL，除了 all 之外，其他的 type 都可以使用到索引，除了 index_merge 之外，其他的 type 只可以用到一个索引。一般来说，得保证查询至少达到 range 级别，最好能达到 ref</p><ul><li>system 表中只有一行数据（等于系统表），这是 const 类型的特例，平时不会出现，可以忽略不计</li><li>const 使用唯一索引或者主键，表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只需匹配一行数据，所有很快。如果将主键置于 where 列表中，mysql 就能将该查询转换为一个 const</li><li>eq_ref 唯一性索引扫描，对于每个索引键，表中只有一行数据与之匹配。常见于主键或唯一索引扫描</li><li>ref 非唯一性索引扫描，返回匹配某个单独值的所有行。本质也是一种索引</li><li>fulltext 全文索引检索，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql 不管代价，优先选择使用全文索引</li><li>ref_or_null  与 ref 方法类似，只是增加了 null 值的比较</li><li>index_merge 表示查询使用了两个以上的索引，索引合并的优化方法，最后取交集或者并集，常见 and，or 的条件使用了不同的索引</li><li>unique_subquery 用于 where 中的 in 形式子查询，子查询返回不重复值唯一值</li><li>index_subquery 用于 in 形式子查询使用到了辅助索引或者 in 常数列表，子查询可能返回重复值，可以使用索引将子查询去重</li><li>range 索引范围扫描，常见于使用<code>&gt;</code>,<code>&lt;</code>,<code>between</code>,<code>in</code>,<code>like</code>等运算符的查询中</li><li>index 索引全表扫描，把索引树从头到尾扫一遍</li><li>all 遍历全表以找到匹配的行（Index 与 ALL 虽然都是读全表，但 index 是从索引中读取，而 ALL 是从硬盘读取）</li><li>NULL MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引</li></ul><h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>显示查询可能使用到的索引</p><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>显示查询实际使用哪个索引来优化对该表的访问<br>select_type 为 index_merge 时，这里可能出现两个以上的索引，其他的 select_type 这里只会出现一个</p><h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>用于处理查询的索引长度，表示索引中使用的字节数。通过这个值，可以得出一个多列索引里实际使用了哪一部分<br>注：key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的。另外，key_len 只计算 where 条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到 key_len 中</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>显示哪个字段或者常数与 key 一起被使用</p><ul><li>如果是使用的常数等值查询，这里会显示 const</li><li>如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段</li><li>如果是条件使用了表达式或者函数，或者条件列发生了内部<code>隐式转换</code>，这里可能显示为 func</li></ul><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>表示 MySQL 根据表统计信息及索引选用情况，大致估算的找到所需的目标记录所需要读取的行数，不是精确值</p><h4 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h4><p>不适合在其他列中显示但十分重要的额外信息，这个列可以显示的信息非常多，有几十种，常用的有</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Using filesort</td><td>MySQL 有两种方式可以生成有序的结果，通过排序操作或者使用索引，当 Extra 中出现了 Using filesort 说明 MySQL 使用了后者，但注意虽然叫 filesort 但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是 ordery by，group by 语句的结果，这可能是一个 CPU 密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序</td></tr><tr><td>Using temporary</td><td>用临时表保存中间结果，常用于 GROUP BY 和 ORDER BY 操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用</td></tr><tr><td>Not exists</td><td>MYSQL 优化了 LEFT JOIN，一旦它找到了匹配 LEFT JOIN 标准的行， 就不再搜索了</td></tr><tr><td>Using index</td><td>说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现 using where，表明索引被用来执行索引键值的查找，没有 using where，表明索引用来读取数据而非执行查找动作。这是 MySQL 服务层完成的，但无需再回表查询记录</td></tr><tr><td>Using index condition</td><td>这是 MySQL 5.6 出来的新特性，叫做“索引条件推送”。简单说一点就是 MySQL 原来在索引上是不能执行如 like 这样的操作的，但是现在可以了，这样减少了不必要的 IO 操作，但是只能用在二级索引上</td></tr><tr><td>Using where</td><td>使用了 WHERE 从句来限制哪些行将与下一张表匹配或者是返回给用户。注意：Extra 列出现 Using where 表示 MySQL 服务器将存储引擎返回服务层以后再应用 WHERE 条件过滤</td></tr><tr><td>Using join buffer</td><td>使用了连接缓存：Block Nested Loop，连接算法是块嵌套循环连接;Batched Key Access，连接算法是批量索引连接</td></tr><tr><td>impossible where</td><td>where 子句的值总是 false，不能用来获取任何元组</td></tr><tr><td>select tables optimized away</td><td>在没有 GROUP BY 子句的情况下，基于索引优化 MIN/MAX 操作，或者对于 MyISAM 存储引擎优化 COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</td></tr><tr><td>distinct</td><td>优化 distinct 操作，在找到第一匹配的元组后即停止找同样值的动作</td></tr></tbody></table><h4 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h4><p>这个字段表示存储引擎返回的数据在 server 层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol><li>EXPLAIN 不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>不会考虑Cache</li><li>EXPLAIN 不能显示 MySQL 在执行查询时所作的优化工作</li><li>部分统计信息是估算的，并非精确值</li><li>EXPALIN 只能解释 SELECT 操作，其他操作要重写为 SELECT 后查看</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL count</title>
      <link href="2020/09/10/MySQL-count/"/>
      <url>2020/09/10/MySQL-count/</url>
      
        <content type="html"><![CDATA[<p>数据库查询相信很多人都不陌生，所有经常有人调侃程序员就是CRUD专员，这所谓的CRUD指的就是数据库的增删改查。<br>在数据库的增删改查操作中，使用最频繁的就是查询操作。而在所有查询操作中，统计数量操作更是经常被用到。<br>关于数据库中行数统计，无论是MySQL还是Oracle，都有一个函数可以使用，那就是<code>COUNT</code>。<br>但是，就是这个常用的<code>COUNT</code>函数，却暗藏着很多玄机，尤其是在面试的时候，一不小心就会被虐。不信的话请尝试回答下以下问题：</p><blockquote><p>1、COUNT有几种用法？<br>2、COUNT(字段名)和COUNT(<em>)的查询结果有什么不同？<br>3、COUNT(1)和COUNT(</em>)之间有什么不同？<br>4、COUNT(1)和COUNT(<em>)之间的效率哪个更高？<br>5、为什么《阿里巴巴Java开发手册》建议使用COUNT(</em>)<br>6、MySQL的MyISAM引擎对COUNT(<em>)做了哪些优化？<br>7、MySQL的InnoDB引擎对COUNT(</em>)做了哪些优化？<br>8、上面提到的MySQL对COUNT(<em>)做的优化，有一个关键的前提是什么？<br>9、SELECT COUNT(</em>) 的时候，加不加where条件有差别吗？<br>10、COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？</p></blockquote><p>以上10道题，如果您可以全部准确无误的回答的话，那说明你真的很了解<code>COUNT</code>函数了，如果有哪些知识点是不了解的，那么本文正好可以帮你答疑解惑。</p><h3 id="认识COUNT"><a href="#认识COUNT" class="headerlink" title="认识COUNT"></a>认识COUNT</h3><p>1、COUNT(expr) ，返回SELECT语句检索的行中expr的值不为NULL的数量。结果是一个BIGINT值。<br>2、如果查询结果没有命中任何记录，则返回0<br>3、但是，值得注意的是，<code>COUNT(*)</code> 的统计结果中，会包含值为NULL的行数。</p><p>即以下表记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table #bla(id int,id2 int)</span><br><span class="line">insert #bla values(null,null)</span><br><span class="line">insert #bla values(1,null)</span><br><span class="line">insert #bla values(null,1)</span><br><span class="line">insert #bla values(1,null)</span><br><span class="line">insert #bla values(null,1)</span><br><span class="line">insert #bla values(1,null)</span><br><span class="line">insert #bla values(null,null)</span><br></pre></td></tr></table></figure><p>使用语句<code>count(*)</code>,<code>count(id)</code>,<code>count(id2)</code>查询结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(*),count(id),count(id2)</span><br><span class="line">from #bla</span><br><span class="line">results 7 3 2</span><br></pre></td></tr></table></figure><p>除了<code>COUNT(id)</code>和<code>COUNT(*)</code>以外，还可以使用<code>COUNT(常量)</code>（如<code>COUNT(1)</code>）来统计行数，那么这三条SQL语句有什么区别呢？到底哪种效率更高呢？为什么《阿里巴巴Java开发手册》中强制要求不让使用 <code>COUNT(列名)</code>或 <code>COUNT(常量)</code>来替代 <code>COUNT(*)</code>呢？</p><h3 id="COUNT-列名-、COUNT-常量-和COUNT-之间的区别"><a href="#COUNT-列名-、COUNT-常量-和COUNT-之间的区别" class="headerlink" title="COUNT(列名)、COUNT(常量)和COUNT(*)之间的区别"></a><code>COUNT(列名)</code>、<code>COUNT(常量)</code>和<code>COUNT(*)</code>之间的区别</h3><p>前面我们提到过<code>COUNT(expr)</code>用于做行数统计，统计的是expr不为NULL的行数，那么<code>COUNT(列名)</code>、 <code>COUNT(常量)</code> 和 <code>COUNT(*)</code>这三种语法中，expr分别是列名、 常量 和 <code>*</code>。<br>那么列名、常量和 <code>*</code>这三个条件中，常量是一个固定值，肯定不为NULL。<code>*</code>可以理解为查询整行，所以肯定也不为NULL，那么就只有列名的查询结果有可能是NULL了。<br>所以， <code>COUNT(常量)</code> 和 <code>COUNT(*)</code>表示的是直接查询符合条件的数据库表的行数。而<code>COUNT(列名)</code>表示的是查询符合条件的列的值不为NULL的行数。<br>除了查询得到结果集有区别之外，<code>COUNT(*)</code>相比<code>COUNT(常量)</code> 和 <code>COUNT(列名)</code>来讲，<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，因为他是标准语法，所以MySQL数据库对他进行过很多优化。</p><blockquote><p>SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）。</p></blockquote><h3 id="COUNT-的优化"><a href="#COUNT-的优化" class="headerlink" title="COUNT(*)的优化"></a>COUNT(*)的优化</h3><p>前面提到了<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，所以MySQL数据库对他进行过很多优化。那么，具体都做过哪些事情呢？<br>这里的介绍要区分不同的执行引擎。MySQL中比较常用的执行引擎就是InnoDB和MyISAM。<br>MyISAM和InnoDB有很多区别，其中有一个关键的区别和我们接下来要介绍的<code>COUNT(*)</code>有关，那就是MyISAM不支持事务，MyISAM中的锁是表级锁；而InnoDB支持事务，并且支持行级锁。<br>因为MyISAM的锁是表级锁，所以同一张表上面的操作需要串行进行，所以，MyISAM做了一个简单的优化，那就是它可以把表的总行数单独记录下来，如果从一张表中使用<code>COUNT(*)</code>进行查询的时候，可以直接返回这个记录下来的数值就可以了，当然，前提是不能有where条件。<br>MyISAM之所以可以把表中的总行数记录下来供<code>COUNT(*)</code>查询使用，那是因为MyISAM数据库是表级锁，不会有并发的数据库行数修改，所以查询得到的行数是准确的。<br>但是，对于InnoDB来说，就不能做这种缓存操作了，因为InnoDB支持事务，其中大部分操作都是行级锁，所以可能表的行数可能会被并发修改，那么缓存记录下来的总行数就不准确了。<br>但是，InnoDB还是针对<code>COUNT(*)</code>语句做了些优化的。<br>在InnoDB中，使用<code>COUNT(*)</code>查询行数的时候，不可避免的要进行扫表了，那么，就可以在扫表过程中下功夫来优化效率了。<br>从MySQL 8.0.13开始，针对InnoDB的<code>SELECT COUNT(*) FROM tbl_name</code>语句，确实在扫表的过程中做了一些优化。前提是查询语句中不包含WHERE或GROUP BY等条件。<br>我们知道，<code>COUNT(*)</code>的目的只是为了统计总行数，所以，他根本不关心自己查到的具体值，所以，他如果能够在扫表的过程中，选择一个成本较低的索引进行的话，那就可以大大节省时间。<br>我们知道，InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。<br>所以，相比之下，非聚簇索引要比聚簇索引小很多，所以MySQL会优先选择<code>最小的非聚簇索引</code>来扫表。所以，当我们建表的时候，除了主键索引以外，创建一个非主键索引还是有必要的。<br>至此，我们介绍完了MySQL数据库对于<code>COUNT(*)</code>的优化，这些优化的前提都是查询语句中不包含WHERE以及GROUP BY条件。</p><h3 id="COUNT-和COUNT-1"><a href="#COUNT-和COUNT-1" class="headerlink" title="COUNT(*)和COUNT(1)"></a>COUNT(*)和COUNT(1)</h3><p>介绍完了<code>COUNT(*)</code>，接下来看看<code>COUNT(1)</code>，对于，这二者到底有没有区别，网上的说法众说纷纭。<br>有的说<code>COUNT(*)</code>执行时会转换成<code>COUNT(1)</code>，所以<code>COUNT(1)</code>少了转换步骤，所以更快。<br>还有的说，因为MySQL针对<code>COUNT(*)</code>做了特殊优化，所以<code>COUNT(*)</code>更快。<br>那么，到底哪种说法是对的呢？看下MySQL官方文档是怎么说的：</p><blockquote><p>InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</p></blockquote><p>画重点：same way , no performance difference。所以，对于<code>COUNT(1)</code>和<code>COUNT(*)</code>，MySQL的优化是完全一样的，根本不存在谁比谁快！<br>那既然<code>COUNT(*)</code>和<code>COUNT(1)</code>一样，建议用哪个呢？<br>建议使用<code>COUNT(*)</code>！因为这个是SQL92定义的标准统计行数的语法，而且本文只是基于MySQL做了分析，关于Oracle中的这个问题，也是众说纷纭的呢。</p><h3 id="COUNT-字段"><a href="#COUNT-字段" class="headerlink" title="COUNT(字段)"></a>COUNT(字段)</h3><p>最后，就是我们一直还没提到的<code>COUNT(字段)</code>，他的查询就比较简单粗暴了，就是进行全表扫描，然后判断指定字段的值是不是为NULL，不为NULL则累加。<br>相比<code>COUNT(*)</code>，<code>COUNT(字段)</code>多了一个步骤就是判断所查询的字段是否为NULL，所以他的性能要比<code>COUNT(*)</code>慢。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了COUNT函数的用法，主要用于统计表行数。主要用法有<code>COUNT(*)</code>、<code>COUNT(字段)</code>和<code>COUNT(1)</code>。<br>因为<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，所以MySQL对他进行了很多优化，MyISAM中会直接把表的总行数单独记录下来供<code>COUNT(*)</code>查询，而InnoDB则会在扫表的时候选择最小的索引来降低成本。当然，这些优化的前提都是没有进行where和group的条件查询。<br>在InnoDB中<code>COUNT(*)</code>和<code>COUNT(1)</code>实现上没有区别，而且效率一样，但是COUNT(字段)需要进行字段的非NULL判断，所以效率会低一些。<br>因为<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，并且效率高，所以请直接使用<code>COUNT(*)</code>查询表的行数！</p><p>作者：HollisChuang<br>链接：<a href="https://juejin.cn/post/6844903974445776903">https://juejin.cn/post/6844903974445776903</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆应用</title>
      <link href="2020/09/07/%E5%A0%86%E5%BA%94%E7%94%A8/"/>
      <url>2020/09/07/%E5%A0%86%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="应用一：优先级队列"><a href="#应用一：优先级队列" class="headerlink" title="应用一：优先级队列"></a>应用一：优先级队列</h3><ol><li>优先级队列，数据的出队顺序不是先进先出，而是而是按照优先级来，优先级最高的，最先出队。</li><li>实现一个优先级队列方法很多，但是用堆来实现是最直接，最高效的，这是因为堆和优先级队列非常相似。一个堆可以看作一个优先级队列，很多时候，他们只是概念上的区分。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</li><li>优先级队列的应用广泛，如赫夫曼编码，图的最短路径，做小生成树的算法等等</li></ol><h4 id="优先级队列应用一：合并有序小文件"><a href="#优先级队列应用一：合并有序小文件" class="headerlink" title="优先级队列应用一：合并有序小文件"></a>优先级队列应用一：合并有序小文件</h4><p>假设：有100个小文件，每个文件大小为100MB，每个文件中储存的都是有序的字符串。现需要将这100个小文件合并成一个有序的大文件。<br>思路：</p><ol><li>整体思路有点像归并排序中的合并函数，从100个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串合并后的大文件中，并从数组中删除。</li><li>假设，最小的字符串来自于13.txt这个文件，就再次从这个文件找那个取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止。</li><li>使用数组来存储从小文件中取出来的字符串，每次从数组中取最小字符串，都需要循环遍历整个数组，效率不高。</li><li>可以用到优先级队列，也可以说是堆。将从小文件中取出的字符串放入到小顶堆中，堆顶的元素就是优先级队列队首的元素，就是最小的字符串。</li><li>依次从小文件中取出下一个字符串，放入到堆中，循环这过程。</li></ol><p>删除堆顶数据和往堆中插入数据的时间复杂度都是O(logn)，n表示堆中的数据个数，这里就是100</p><h4 id="优先队列应用二：高性能定时器"><a href="#优先队列应用二：高性能定时器" class="headerlink" title="优先队列应用二：高性能定时器"></a>优先队列应用二：高性能定时器</h4><p>假设：有一个定时器，定时器中维护了很多定时任务</p><ol><li>每过1秒就扫描一遍任务列表做法太低效。原因1：任务的约定执行时间离当前时间可能还有很久，大量的扫描徒劳无功。原因2：每次都要扫描整个任务列表，若列表较大，会比较耗时。</li><li>针对这种文件，可用优先队列来解决。按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（最小顶堆）存储的是最先执行的任务。</li><li>这样定时器就不用每隔一秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，即可得到一个时间间隔T。</li><li>当T秒时间过去后，定时器取优先级队列中队首的任务执行，然后在计算新的队首任务的执行时间点和当前时间点的差值。</li><li>这样定时器就不用间隔1秒就轮询一次，也不用遍历整个任务列表，性能就提高了。</li></ol><h3 id="应用二：利用堆求Top-K"><a href="#应用二：利用堆求Top-K" class="headerlink" title="应用二：利用堆求Top K"></a>应用二：利用堆求Top K</h3><p>求Topk的问题可抽象成两类：</p><ol><li><p>针对静态数据<br>可以维护一个大小为k的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果堆顶元素大，就将堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前k大数据了。<br>遍历数据需要O(n)的时间复杂度，一次堆化操作需要O(logk)的时间复杂度，最坏情况下，n个元素都入堆一次，时间复杂度就是O(nlogk)。</p></li><li><p>针对动态数据求得Topk就是实时Topk。<br>一个数据集合有两个操作，一个是添加数据，另一个询问当前的前k大数据。<br>可以维护一直都维护一个k大小的小顶堆，当有数据被添加到集合时，就那它与堆顶的元素对对比。如果比堆顶元素大，就把堆顶元素删除，并将这个元素插入到堆中，如果比堆顶元素小，这不处理。这样，无论任何时候需要查询当前的前k大数据，就都可以 立刻返回给他。</p></li></ol><h3 id="应用三：利用堆求中位数"><a href="#应用三：利用堆求中位数" class="headerlink" title="应用三：利用堆求中位数"></a>应用三：利用堆求中位数</h3><ol><li>对于一组静态数据，中位数是固定的，可以先排序，第n/2个数据就是中位数。</li><li>对于动态数据集合，就无法先排序了，需要借助堆这种数据结构，我们不用排序，就可以非常高效的实现求中位数操作。</li></ol><p>实现思路：</p><ol><li>需要维护两个堆，大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。</li><li>即：如果有n个数据，n是偶数，从小到大排序，那前n/2个数据存储在大顶堆中，后n/2个数据存储在小顶堆中。这样，大顶堆中堆顶元素就是要找的中位数。</li><li>如果新加入的数据小于等于大顶堆的堆顶元素，就将这个数据插入到大顶堆；否则就插入小顶堆</li><li>当两个堆中的数据量不服和中位数的约定时，就从一个堆中不停的将堆顶的元素移动到另一个堆，重新让两个堆中数据满足上面的约定。</li></ol><p>于是，可以利用两个堆实现动态数据集合中求中位数的操作，插入数据因为涉及堆化，所以时间复杂度变成了O(logn)，但求中位数只需要返回大顶堆的堆顶元素就可以了，所以时间复杂度就是O(1)。</p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>有一个访问量非常大的新闻网站，我们希望将点击量排名 Top 10 的新闻摘要，滚动显示在网站首页 banner 上，并且每隔 1 小时更新一次。如果你是负责开发这个功能的工程师，你会如何来实现呢？</p><ol><li>对每篇新闻摘要计算一个hashcode，并建立摘要与hashcode的关联关系，使用map存储，以hashCode为key，新闻摘要为值；</li><li>按每小时一个文件的方式记录下被点击的摘要的hashCode；</li><li>当一个小时结果后，上一个小时的文件被关闭，开始计算上一个小时的点击top10；</li><li>将hashcode分片到多个文件中，通过对hashCode取模运算，即可将相同的hashCode分片到相同的文件中；</li><li>针对每个文件取top10的hashCode，使用Map&lt;hashCode,int&gt;的方式，统计出所有的摘要点击次数，然后再使用小顶堆（大小为10）计算top10；</li><li>再针对所有分片计算一个总的top10,最后合并的逻辑也是使用小顶堆，计算top10；</li><li>如果仅展示前一个小时的top10,计算结束；</li><li>如果需要展示全天，需要与上一次的计算按hashCode进行合并，然后在这合并的数据中取top10；</li><li>在展示时，将计算得到的top10的hashcode，转化为新闻摘要显示即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆与堆排序</title>
      <link href="2020/09/05/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2020/09/05/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="一：如何理解“堆”"><a href="#一：如何理解“堆”" class="headerlink" title="一：如何理解“堆”"></a>一：如何理解“堆”</h3><ol><li>堆是一个完全二叉树；<br> 完全二叉树要求除了最后一层，其他层的节点都是满的，最后一层的节点都靠左排列。</li><li>堆中每个节点都必须大于等于（或小于等于）其子树中每个节点的值。<br> 堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。</li><li>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，叫“小顶堆”。</li></ol><h3 id="二：如何实现“堆”"><a href="#二：如何实现“堆”" class="headerlink" title="二：如何实现“堆”"></a>二：如何实现“堆”</h3><p>要实现一个堆，要先知道堆都支持哪些操作，已及如何存储一个堆。</p><ol><li>如何存储一个堆：<br> 完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</li><li>往堆中插入一个元素<br> 往堆中插入一个元素后，需要继续满足堆的两个特性<ol><li>如果把新插入的元素放到堆的最后，则不符合堆的特性了，于是需要进行调整，让其重新满足堆的特性，这个过程叫做 堆化（heapify）</li><li>堆化实际上有两种，从下往上和从上往下</li><li>从下往上的堆化方法：堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。</li></ol></li><li>删除堆顶元素<ol><li>从堆的定义的第二条中，任何节点的值都大于等于（或小于等于）子树节点的值，则堆顶元素存储的就是堆中数据的最大值或最小值。</li><li>假设是大顶堆，堆堆顶元素就是最大的元素，但删除堆顶元素之后，就需要把第二大元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后在迭代地删除第二大节点，以此类推，直到叶子节点被删除。但这种方式会使堆化出来的堆不满足完全二叉树的特性。</li><li>可以把最后一个节点放到堆顶，然后利用同样的父子节点对比方法，对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止，这是从上往下的堆化方法。</li></ol></li></ol><p>一个包含n个节点的完全二叉树，树的高度不会超过log2n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，即O(log n)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以往堆中插入一个元素和删除堆顶元素的时间复杂度都是O(log n)。</p><h3 id="三：如何基于堆实现排序"><a href="#三：如何基于堆实现排序" class="headerlink" title="三：如何基于堆实现排序"></a>三：如何基于堆实现排序</h3><ol><li>排序方法有时间复杂度是O(n^2)的冒泡排序，插入排序，选择排序，有时间复杂度是O（nlogn）的归并排序，快速排序，线性排序。</li><li>借助堆这种数据结构实现的排序算法就叫作堆排序，这种排序方法的时间复杂度非常稳定，是O(nlogn)，并且它还是原地排序算法。</li></ol><p>堆排序的过程大致分解为两大步骤：建堆和排序</p><ol><li>首先将数组原地建成一个堆。“原地”：是指不借助另一个数组，就在原地数组上操作。</li><li>建堆有两种思路：<ul><li>第一种：在堆中插入一个元素的思路。尽管数组中包含n个数据，但是可以假设起初堆中只包含一个数据，就是下标为1的数据。然后，调用插入方法，将将下标从2到n的数据依次插入到堆中，这样就将包含n个数据的数组，组织成了堆</li><li>第二种：是从后往前处理数组，并且每个数据都是从上往下堆化。<br>第二种和第一种思路截然相反，第一种建堆思路的处理过程是从前往后处理数据，并且每个数据插入堆中时，都是从下往上堆化。对下标从n/2开始到1的数据进行堆化，下标是n/2 + 1到n的节点，是叶子节点，不需堆化</li></ul></li><li>建堆的时间复杂度<br>每个节点堆化的时间复杂度是O(logn)，则n/2+1个节点堆化的总时间复杂度是O(n)。因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点高度k成正比。</li><li>排序：<br>建堆结束后，数组中的数据已是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。<br>将它和最后一个元素交换，最大元素就放到了下标为n的位置<br>这个过程有点类似“删除堆顶元素”的操作，当堆顶元素移除后，把下标为n的元素放到堆顶，然后在通过堆化的方法，将剩下的n-1个元素重新构建成堆。堆化完成之后，在取堆顶元素，放到下标是n-1的位置，一直重复这个过程，直到最后堆中只剩下标为1的一个元素，排序工作就完成了。</li><li>时间，空间复杂度，以及稳定性分析<br>①：整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。<br>②：堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是O(n)，排序过程的时间复杂度是O(nlogn),所以堆排序的时间复杂度是O(nlogn)<br>③：堆排序不是稳定的排序算法，可能改变值相等的数据原始相对顺序。</li></ol><h3 id="四、思考题"><a href="#四、思考题" class="headerlink" title="四、思考题"></a>四、思考题</h3><ol><li><p>在讲堆排序建堆的时候，我说到，对于完全二叉树来说，下标从 2n​+1 到 n 的都是叶子节点，这个结论是怎么推导出来的呢？<br>n就是n/2的左子节点，所以n/2，并不是叶子节点。其实很简单，n是最后一个节点，那n的父节点n/2必定就是最后一个父节点了。那么自然n/2之后的节点都为叶子节点。使用数组存储表示完全二叉树时，从数组下标为1开始存储数据，数组下标为i的节点，左子节点为2i, 右子节点为2i + 1. 这个结论很重要（可以用数学归纳法证明)，将此结论记为『原理1』，以下证明会用到这个原理。<br>为什么，对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点？ 使用反证法证明即可：<br>如果下标为n/2 + 1的节点不是叶子节点，即它存在子节点，按照『原理1』，它的左子节点为：2(n/2 + 1) = n + 2，大家明显可以看出，这个数字已经大于n + 1，超出了实现完全二叉树所用数组的大小（数组下标从1开始记录数据，对于n个节点来说，数组大小是n + 1），左子节点都已经超出了数组容量，更何况右子节点。以此类推，很容易得出：下标大于n/2 + 1的节点肯定都是也叶子节点了，故而得出结论：对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点。备注下：用数组存储表示完全二叉树时，也可以从下标为0开始，只是这样做的话，计算左子节点时，会多一次加法运算</p></li><li><p>我们今天讲了堆的一种经典应用，堆排序。关于堆，你还能想到它的其他应用吗？</p><ul><li>从大数量级数据中筛选出top n 条数据； 比如：从几十亿条订单日志中筛选出金额靠前的1000条数据</li><li>在一些场景中，会根据不同优先级来处理网络请求，此时也可以用到优先队列(用堆实现的数据结构)；比如：网络框架Volley就用了Java中PriorityBlockingQueue，当然它是线程安全的</li><li>可以用堆来实现多路归并，从而实现有序，leetcode上也有相关的一题：Merge K Sorted Lists</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据类型对应的数据结构</title>
      <link href="2020/09/05/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2020/09/05/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>Redis 中，键的数据类型是字符串，但是值的数据类型有很多，常用的数据类型是：字符串、列表、字典、集合、有序集合</p><h3 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h3><ol><li>列表这种数据类型支持存储一组数据</li><li>两种实现方法：（1）压缩列表（ziplist）（2）双向循环链表<ul><li>当列表中存储的数据量比较小时，可以采用压缩列表的方式实现。</li><li>具体需要同时满足下面两个条件：<br>（1）列表中保存的单个数据（可能是字符串类型的）小于 64 字节；<br>（2）列表中数据个数少于 512 个</li></ul></li><li>关于压缩列表<ul><li>它并不是基础数据结构，而是 Redis 自己设计的一种数据存储结构</li><li>类似数组，通过一片连续的内存空间来存储数据</li><li>跟数组不同的是它允许存储的数据大小不同</li></ul></li><li>压缩列表中的“压缩”如何理解？<ul><li>“压缩”：就是节省内存，之所以说节省内存，是相较于数组的存储思路而言的。数组要求每个元素的大小相同，如果要存储不同长度的字符串，就需要用最大长度的字符串大小作为元素的大小。但压缩数组允许不同的存储空间。</li><li>压缩列表这种存储结构，另一方面可以支持不同类型数据的存储</li><li>数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高。</li></ul></li><li>不能同时满足压缩列表的两个条件时，列表就要通过双向循环链表来实现</li></ol><h3 id="字典（hash）"><a href="#字典（hash）" class="headerlink" title="字典（hash）"></a>字典（hash）</h3><ol><li>字典类型用来存储一组数据对。</li><li>每个数据对又包含键值两部分，也有两种实现方式：（1）压缩列表（2）散列表</li><li>同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：<ul><li>字典中保存的键和值的大小都要小于 64 字节</li><li>字典中键值对的个数要小于 512 个</li></ul></li><li>当不能同时满足上面两个条件的时候，Redis 就使用散列表来实现字典类型<ul><li>Redis 使用MurmurHash2这种运行速度快、随机性好的哈希算法作为哈希函数</li><li>对于哈希冲突问题，Redis 使用链表法来解决</li><li>除此之外，Redis 还支持散列表的动态扩容、缩容。</li></ul></li><li>扩容：当数据动态增加，装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右（具体值需要计算才能得到）。</li><li>缩容：当数据动态减少之后，为了节省内存，当装载因子小于 0.1 的时候，Redis 就会触发缩容，缩小为字典中数据个数的大约 2 倍大小（这个值也是计算得到的）<br>扩容缩容要做大量的数据搬移和哈希值的重新计算，比较耗时。针对这个问题，Redis 使用渐进式扩容缩容策略：将数据的搬移分批进行，避免了大量数据一次性搬移导致的服务停顿。</li></ol><h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><ol><li>集合这种数据类型用来存储一组不重复的数据</li><li>这种数据类型也有两种实现方法：（1）有序数组（2）散列表</li><li>Redis 若采用有序数组，要同时满足下面这样两个条件：<ul><li>存储的数据都是整数；</li><li>存储的数据元素个数不超过 512 个。</li><li>当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。</li></ul></li></ol><h3 id="有序集合（sortedset）"><a href="#有序集合（sortedset）" class="headerlink" title="有序集合（sortedset）"></a>有序集合（sortedset）</h3><ol><li>它用来存储一组数据，并且每个数据会附带一个得分。通过得分的大小，将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。</li><li>当数据量比较小的时候，Redis 可用压缩列表来实现有序集合。使用的前提有两个：<ul><li>所有数据的大小都要小于 64 字节；</li><li>元素个数要小于 128 个</li></ul></li></ol><h3 id="数据结构持久化"><a href="#数据结构持久化" class="headerlink" title="数据结构持久化"></a>数据结构持久化</h3><p>尽管 Redis 经常会被用作内存数据库，但它也支持将内存中的数据存储到硬盘中。当机器断电的时，存储在 Redis 中的数据不会丢失。Redis 的数据格式由“键”和“值”两部分组成。而“值”又支持很多数据类型，像字典、集合等类型，底层用到了散列表，散列表中有指针的概念，而指针指向的是内存中的存储地址。</p><h4 id="Redis-是如何将一个跟具体内存地址有关的数据结构存储到磁盘中的？"><a href="#Redis-是如何将一个跟具体内存地址有关的数据结构存储到磁盘中的？" class="headerlink" title="Redis 是如何将一个跟具体内存地址有关的数据结构存储到磁盘中的？"></a>Redis 是如何将一个跟具体内存地址有关的数据结构存储到磁盘中的？</h4><ol><li>Redis 遇到的这个问题被称为数据结构的持久化问题，或者对象的持久化问题</li><li>将数据结构持久化到硬盘主要有两种解决思路：<ul><li>第一种是清除原有的存储结构，只将数据存储到磁盘中。<ol><li>当需要从磁盘还原数据到内存时，再重新将数据组织成原来的数据结构。Redis 采用的就是这种持久化思路。</li><li>这种方式有一定的弊端：数据从硬盘还原到内存的过程，会耗用比较多的时间</li></ol></li><li>第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现一个通用的高性能的排序函数</title>
      <link href="2020/09/01/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/"/>
      <url>2020/09/01/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一、如何选择合适的排序算法？"><a href="#一、如何选择合适的排序算法？" class="headerlink" title="一、如何选择合适的排序算法？"></a>一、如何选择合适的排序算法？</h3><p>排序算法一览表</p><table><thead><tr><th align="center">排序名称</th><th align="center">时间复杂度</th><th align="center">是稳定排序？</th><th align="center">是原地排序？</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center"><code>O(n^2)</code></td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">插入排序</td><td align="center"><code>O(n^2)</code></td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">选择排序</td><td align="center"><code>O(n^2)</code></td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">快速排序</td><td align="center"><code>O(nlogn)</code></td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">归并排序</td><td align="center"><code>O(nlogn)</code></td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">桶排序</td><td align="center"><code>O(n)</code></td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">计数排序</td><td align="center"><code>O(n+k)</code>k是数据范围</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">基数排序</td><td align="center"><code>O(dn)</code>d是纬度</td><td align="center">是</td><td align="center">否</td></tr></tbody></table><h4 id="为什选择快速排序？"><a href="#为什选择快速排序？" class="headerlink" title="为什选择快速排序？"></a>为什选择快速排序？</h4><ol><li>线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序。</li><li>为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数。</li><li>同为O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排。</li></ol><h3 id="二、如何优化快速排序？"><a href="#二、如何优化快速排序？" class="headerlink" title="二、如何优化快速排序？"></a>二、如何优化快速排序？</h3><p>导致快排时间复杂度降为O(n)的原因是分区点选择不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。如何优化分区点的选择？有2种常用方法，如下：</p><ol><li>三数取中法<ol><li>从区间的首、中、尾分别取一个数，然后比较大小，取中间值作为分区点。</li><li>如果要排序的数组比较大，那“三数取中”可能就不够用了，可能要“5数取中”或者“10数取中”。</li></ol></li><li>随机法：每次从要排序的区间中，随机选择一个元素作为分区点。</li><li>警惕快排的递归发生堆栈溢出，有2中解决方法，如下：<ol><li>限制递归深度，一旦递归超过了设置的阈值就停止递归。</li><li>在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制。</li></ol></li></ol><h3 id="三、通用排序函数实现技巧"><a href="#三、通用排序函数实现技巧" class="headerlink" title="三、通用排序函数实现技巧"></a>三、通用排序函数实现技巧</h3><ol><li>数据量不大时，可以采取用时间换空间的思路</li><li>数据量大时，优化快排分区点的选择</li><li>防止堆栈溢出，可以选择在堆上手动模拟调用栈解决</li><li>在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n^2)级别的插入排序</li><li>用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致</li></ol><h3 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h3><ol><li>php中的排序函数都是用什么排序算法实现的？有哪些技巧？<br> 当数据量较小时（小于等于16)，会使用插入排序，因为此时插入排序性能更好；否则会使用快速排序。</li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序与快速排序的PHP实现</title>
      <link href="2020/08/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84PHP%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/08/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84PHP%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一、分治思想"><a href="#一、分治思想" class="headerlink" title="一、分治思想"></a>一、分治思想</h3><ol><li>分治思想：分治，顾明思意，就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。</li><li>分治与递归的区别：分治算法一般都用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。</li></ol><h3 id="二、归并排序"><a href="#二、归并排序" class="headerlink" title="二、归并排序"></a>二、归并排序</h3><p><img src="mergeSort.jpg" alt="归并排序"></p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并到一起，这样整个数组就有序了。这就是归并排序的核心思想。如何用递归实现归并排序呢？写递归代码的技巧就是分写得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。递推公式怎么写？如下<br>递推公式：<code>merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</code><br>终止条件：<code>p &gt;= r </code>不用再继续分解</p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><ol><li><p>算法稳定性：<br>归并排序稳不稳定关键要看merge()函数，也就是两个子数组合并成一个有序数组的那部分代码。在合并的过程中，如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，那我们就可以像伪代码中那样，先把 A[p…q] 中的元素放入tmp数组，这样 就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一种稳定排序算法。</p></li><li><p>时间复杂度：分析归并排序的时间复杂度就是分析递归代码的时间复杂度<br>如何分析递归代码的时间复杂度？<br>递归的适用场景是一个问题a可以分解为多个子问题b、c，那求解问题a就可以分解为求解问题b、c。问题b、c解决之后，我们再把b、c的结果合并成a的结果。若定义求解问题a的时间是T(a)，则求解问题b、c的时间分别是T(b)和T(c)，那就可以得到这样的递推公式：T(a) = T(b) + T(c) + K，其中K等于将两个子问题b、c的结果合并成问题a的结果所消耗的时间。这里有一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。套用这个公式，那么归并排序的时间复杂度就可以表示为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">T(1) &#x3D; C； n&#x3D;1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) &#x3D; 2*T(n&#x2F;2) + n； n&gt;1，其中n就是merge()函数合并两个子数组的的时间复杂度O(n)。</span><br><span class="line">T(n) &#x3D; 2*T(n&#x2F;2) + n</span><br><span class="line">    &#x3D; 2*(2*T(n&#x2F;4) + n&#x2F;2) + n &#x3D; 4*T(n&#x2F;4) + 2*n</span><br><span class="line">    &#x3D; 4*(2*T(n&#x2F;8) + n&#x2F;4) + 2*n &#x3D; 8*T(n&#x2F;8) + 3*n</span><br><span class="line">    &#x3D; 8*(2*T(n&#x2F;16) + n&#x2F;8) + 3*n &#x3D; 16*T(n&#x2F;16) + 4*n</span><br><span class="line">    ......</span><br><span class="line">    &#x3D; 2^k * T(n&#x2F;2^k) + k * n</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>当<code>T(n/2^k)=T(1)</code> 时，也就是 <code>n/2^k=1</code>，我们得到k=log2n。将k带入上面的公式就得到<code>T(n)=Cn+nlog2n</code>。如用大O表示法，<code>T(n)</code>就等于<code>O(nlogn)</code>。所以，归并排序的是复杂度时间复杂度就是<code>O(nlogn)</code>。</p></li><li><p>空间复杂度：归并排序算法不是原地排序算法，空间复杂度是O(n)<br>为什么？因为归并排序的合并函数，在合并两个数组为一个有序数组时，需要借助额外的存储空间。为什么空间复杂度是O(n)而不是O(nlogn)呢？如果我们按照分析递归的时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是O(nlogn)，但这种分析思路是有问题的！因为，在实际上，递归代码的空间复杂度并不是像时间复杂度那样累加，而是这样的过程，即在每次合并过程中都需要申请额外的内存空间，但是合并完成后，临时开辟的内存空间就被释放掉了，在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时空间再大也不会超过n个数据的大小，所以空间复杂度是O(n)。</p></li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$array</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$low</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$n</span> = count(<span class="variable">$array</span>);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;mergeSortRecursive(<span class="variable">$array</span>, <span class="variable">$low</span>, <span class="variable">$n</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeSortRecursive</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$array</span>, <span class="variable">$low</span>, <span class="variable">$high</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$low</span> &gt;= <span class="variable">$high</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="variable">$array</span>[<span class="variable">$high</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取中间位置$mid</span></span><br><span class="line">    <span class="variable">$mid</span> = <span class="variable">$low</span> + ((<span class="variable">$high</span> - <span class="variable">$low</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 递归，合并</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;merge(<span class="keyword">$this</span>-&gt;mergeSortRecursive(<span class="variable">$array</span>, <span class="variable">$low</span>, <span class="variable">$mid</span>), <span class="keyword">$this</span>-&gt;mergeSortRecursive(<span class="variable">$array</span>, <span class="variable">$mid</span> + <span class="number">1</span>, <span class="variable">$high</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$leftArr</span>, <span class="keyword">array</span> <span class="variable">$rightArr</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 归并排序中最有意思的部分：可以延伸考多个有序数组合并问题</span></span><br><span class="line">    <span class="variable">$newArr</span> = [];</span><br><span class="line">    <span class="variable">$leftIndex</span> = <span class="variable">$rightIndex</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$leftCount</span> = count(<span class="variable">$leftArr</span>);</span><br><span class="line">    <span class="variable">$rightCount</span> = count(<span class="variable">$rightArr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$leftIndex</span> &lt; <span class="variable">$leftCount</span> &amp;&amp; <span class="variable">$rightIndex</span> &lt; <span class="variable">$rightCount</span>) &#123;</span><br><span class="line">        <span class="variable">$newArr</span>[] = <span class="variable">$leftArr</span>[<span class="variable">$leftIndex</span>] &lt;= <span class="variable">$rightArr</span>[<span class="variable">$rightIndex</span>] ? <span class="variable">$leftArr</span>[<span class="variable">$leftIndex</span>++] : <span class="variable">$rightArr</span>[<span class="variable">$rightIndex</span>++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里要考虑，如果拼接完成后，数组还有剩余的处理</span></span><br><span class="line">    <span class="variable">$start</span> = <span class="variable">$leftIndex</span>;</span><br><span class="line">    <span class="variable">$end</span> = <span class="variable">$leftCount</span>;</span><br><span class="line">    <span class="variable">$corpArr</span> = <span class="variable">$leftArr</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$rightIndex</span> &lt; <span class="variable">$rightCount</span>) &#123;</span><br><span class="line">        <span class="variable">$start</span> = <span class="variable">$rightIndex</span>;</span><br><span class="line">        <span class="variable">$end</span> = <span class="variable">$rightCount</span>;</span><br><span class="line">        <span class="variable">$corpArr</span> = <span class="variable">$rightArr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$start</span> &lt; <span class="variable">$end</span>) &#123;</span><br><span class="line">        <span class="variable">$newArr</span>[] = <span class="variable">$corpArr</span>[<span class="variable">$start</span>++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$newArr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、快速排序"><a href="#三、快速排序" class="headerlink" title="三、快速排序"></a>三、快速排序</h3><h4 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h4><p>快排的思想是这样的：如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。然后遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将povit放到中间。经过这一步之后，数组p到r之间的数据就分成了3部分，前面p到q-1之间都是小于povit的，中间是povit，后面的q+1到r之间是大于povit的。根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。<br>递推公式：<code>quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)</code><br>终止条件：p &gt;= r</p><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><ol><li>算法稳定性：<br>因为分区过程中涉及交换操作，如果数组中有两个8，其中一个是pivot，经过分区处理后，后面的8就有可能放到了另一个8的前面，先后顺序就颠倒了，所以快速排序是不稳定的排序算法。比如数组[1,2,3,9,8,11,8]，取后面的8作为pivot，那么分区后就会将后面的8与9进行交换。</li><li>时间复杂度：最好、最坏、平均情况<br>快排也是用递归实现的，所以时间复杂度也可以用递推公式表示。<br>如果每次分区操作都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并的相同。<br>T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。<br>T(n) = 2*T(n/2) + n； n&gt;1<br>所以，快排的时间复杂度也是O(nlogn)。<br>如果数组中的元素原来已经有序了，比如1，3，5，6，8，若每次选择最后一个元素作为pivot，那每次分区得到的两个区间都是不均等的，需要进行大约n次的分区，才能完成整个快排过程，而每次分区我们平均要扫描大约n/2个元素，这种情况下，快排的时间复杂度就是O(n^2)。<br>前面两种情况，一个是分区及其均衡，一个是分区极不均衡，它们分别对应了快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均时间复杂度是多少呢？T(n)大部分情况下是O(nlogn)，只有在极端情况下才是退化到O(n^2)，而且我们也有很多方法将这个概率降低。</li><li>空间复杂度：快排是一种原地排序算法，空间复杂度是O(1)</li></ol><h4 id="原地交换的实现图解"><a href="#原地交换的实现图解" class="headerlink" title="原地交换的实现图解"></a>原地交换的实现图解</h4><p><img src="fastSort.jpg"></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 快排</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> array $array</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$array</span></span>)</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="variable">$count</span> = count(<span class="variable">$array</span>);</span><br><span class="line">     <span class="keyword">$this</span>-&gt;quickSortRecursive(<span class="variable">$array</span>, <span class="number">0</span>, <span class="variable">$count</span> - <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="variable">$array</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">quickSortRecursive</span>(<span class="params"><span class="keyword">array</span> &amp;<span class="variable">$array</span>, <span class="keyword">int</span> <span class="variable">$left</span>, <span class="keyword">int</span> <span class="variable">$right</span></span>)</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="variable">$left</span> &gt;= <span class="variable">$right</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="variable">$q</span> = <span class="keyword">$this</span>-&gt;partition(<span class="variable">$array</span>, <span class="variable">$left</span>, <span class="variable">$right</span>);</span><br><span class="line">     <span class="keyword">$this</span>-&gt;quickSortRecursive(<span class="variable">$array</span>, <span class="variable">$left</span>, <span class="variable">$q</span> - <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">$this</span>-&gt;quickSortRecursive(<span class="variable">$array</span>, <span class="variable">$q</span> + <span class="number">1</span>, <span class="variable">$right</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params"><span class="keyword">array</span> &amp;<span class="variable">$array</span>, <span class="keyword">int</span> <span class="variable">$left</span>, <span class="keyword">int</span> <span class="variable">$right</span></span>)</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="variable">$pivot</span> = <span class="variable">$array</span>[<span class="variable">$right</span>];</span><br><span class="line">     <span class="variable">$index</span> = <span class="variable">$left</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="variable">$left</span>; <span class="variable">$j</span> &lt; <span class="variable">$right</span>; ++<span class="variable">$j</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="variable">$array</span>[<span class="variable">$j</span>] &lt; <span class="variable">$pivot</span>) &#123;</span><br><span class="line">             <span class="variable">$tmp</span> = <span class="variable">$array</span>[<span class="variable">$j</span>];</span><br><span class="line">             <span class="variable">$array</span>[<span class="variable">$j</span>] = <span class="variable">$array</span>[<span class="variable">$index</span>];</span><br><span class="line">             <span class="variable">$array</span>[<span class="variable">$index</span>] = <span class="variable">$tmp</span>;</span><br><span class="line">             <span class="variable">$index</span> ++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="variable">$tmp</span> = <span class="variable">$array</span>[<span class="variable">$index</span>];</span><br><span class="line">     <span class="variable">$array</span>[<span class="variable">$index</span>] = <span class="variable">$array</span>[<span class="variable">$right</span>];</span><br><span class="line">     <span class="variable">$array</span>[<span class="variable">$right</span>] = <span class="variable">$tmp</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="variable">$index</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="四、归并排序与快速排序的区别"><a href="#四、归并排序与快速排序的区别" class="headerlink" title="四、归并排序与快速排序的区别"></a>四、归并排序与快速排序的区别</h3><p>归并和快排用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？</p><ol><li>归并排序，是先递归调用，再进行合并，合并的时候进行数据的交换。所以它是自下而上的排序方式。何为自下而上？就是先解决子问题，再解决父问题。</li><li>快速排序，是先分区，在递归调用，分区的时候进行数据的交换。所以它是自上而下的排序方式。何为自上而下？就是先解决父问题，再解决子问题。</li></ol><h3 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h3><ol><li>O(n)时间复杂度内求无序数组中第K大元素，比如4，2，5，12，3这样一组数据，第3大元素是4。<br>我们选择数组区间A[0…n-1]的最后一个元素作为pivot，对数组A[0…n-1]进行原地分区，这样数组就分成了3部分，A[0…p-1]、A[p]、A[p+1…n-1]。<br>如果如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1，说明第K大元素出现在A[p+1…n-1]区间，我们按照上面的思路递归地在A[p+1…n-1]这个区间查找。同理，如果K&lt;p+1，那我们就在A[0…p-1]区间查找。<br>时间复杂度分析？<br>第一次分区查找，我们需要对大小为n的数组进行分区操作，需要遍历n个元素。第二次分区查找，我们需要对大小为n/2的数组执行分区操作，需要遍历n/2个元素。依次类推，分区遍历元素的个数分别为n、n/2、n/4、n/8、n/16……直到区间缩小为1。如果把每次分区遍历的元素个数累加起来，就是等比数列求和，结果为2n-1。所以，上述解决问题的思路为O(n)。</li><li>有10个访问日志文件，每个日志文件大小约为300MB，每个文件里的日志都是按照时间戳从小到大排序的。现在需要将这10个较小的日志文件合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述任务的机器内存只有1GB，你有什么好的解决思路能快速地将这10个日志文件合并？</li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡插入选择排序的php实现</title>
      <link href="2020/08/19/%E5%86%92%E6%B3%A1%E6%8F%92%E5%85%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84php%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/08/19/%E5%86%92%E6%B3%A1%E6%8F%92%E5%85%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84php%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一、排序方法与复杂度归类"><a href="#一、排序方法与复杂度归类" class="headerlink" title="一、排序方法与复杂度归类"></a>一、排序方法与复杂度归类</h3><ol><li>几种最经典、最常用的排序方法：冒泡排序、插入排序、选择排序、快速排序、归并排序、计数排序、基数排序、桶排序。</li><li>复杂度归类<ul><li>冒泡排序、插入排序、选择排序 O(n^2)</li><li>快速排序、归并排序 O(nlogn)</li><li>计数排序、基数排序、桶排序 O(n)</li></ul></li></ol><h3 id="二、如何分析一个“排序算法”？"><a href="#二、如何分析一个“排序算法”？" class="headerlink" title="二、如何分析一个“排序算法”？"></a>二、如何分析一个“排序算法”？</h3><h4 id="算法的执行效率"><a href="#算法的执行效率" class="headerlink" title="算法的执行效率"></a>算法的执行效率</h4><ol><li>最好、最坏、平均情况时间复杂度。</li><li>时间复杂度的系数、常数和低阶。</li><li>比较次数，交换（或移动）次数。</li></ol><h4 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h4><ol><li>稳定性概念：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</li><li>稳定性重要性：可针对对象的多种属性进行有优先级的排序。</li><li>举例：给电商交易系统中的“订单”排序，按照金额大小对订单数据排序，对于相同金额的订单以下单时间早晚排序。用稳定排序算法可简洁地解决。先按照下单时间给订单排序，排序完成后用稳定排序算法按照订单金额重新排序。</li></ol><h4 id="排序算法的内存损耗"><a href="#排序算法的内存损耗" class="headerlink" title="排序算法的内存损耗"></a>排序算法的内存损耗</h4><p>原地排序算法：特指空间复杂度是O(1)的排序算法。</p><h3 id="三、冒泡排序"><a href="#三、冒泡排序" class="headerlink" title="三、冒泡排序"></a>三、冒泡排序</h3><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。</p><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>冒泡排序是稳定的排序算法。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>冒泡排序是原地排序算法。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ol><li>最好情况（满有序度）：O(n)。</li><li>最坏情况（满逆序度）：O(n^2)。</li><li>平均情况：<ol><li>“有序度”和“逆序度”：对于一个不完全有序的数组，如4，5，6，3，2，1，有序元素对为3个（4，5），（4，6），（5，6），有序度为3，逆序度为12；对于一个完全有序的数组，如1，2，3，4，5，6，有序度就是<code>n*(n-1)/2</code>，也就是15，称作满有序度；逆序度=满有序度-有序度；冒泡排序、插入排序交换（或移动）次数=逆序度。</li><li>最好情况下初始有序度为<code>n*(n-1)/2</code>，最坏情况下初始有序度为0，则平均初始有序度为<code>n*(n-1)/4</code>，即交换次数为<code>n*(n-1)/4</code>，因交换次数&lt;比较次数&lt;最坏情况时间复杂度，所以平均时间复杂度为O(n^2)。</li></ol></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params"><span class="variable">$array</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$count</span> = count(<span class="variable">$array</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$count</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$count</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">        <span class="variable">$flag</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="variable">$count</span> - <span class="number">1</span>; <span class="variable">$j</span> &gt; <span class="variable">$i</span>; <span class="variable">$j</span>--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$array</span>[<span class="variable">$j</span>] &lt; <span class="variable">$array</span> [<span class="variable">$j</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="variable">$tmp</span> = <span class="variable">$array</span>[<span class="variable">$j</span>];</span><br><span class="line">                <span class="variable">$array</span>[<span class="variable">$j</span>] = <span class="variable">$array</span>[<span class="variable">$j</span> - <span class="number">1</span>];</span><br><span class="line">                <span class="variable">$array</span> [<span class="variable">$j</span> - <span class="number">1</span>] = <span class="variable">$tmp</span>;</span><br><span class="line">                <span class="variable">$flag</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable">$flag</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、插入排序"><a href="#四、插入排序" class="headerlink" title="四、插入排序"></a>四、插入排序</h3><p>插入排序将数组数据分成已排序区间和未排序区间。初始已排序区间只有一个元素，即数组第一个元素。在未排序区间取出一个元素插入到已排序区间的合适位置，直到未排序区间为空。</p><h4 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h4><p>插入排序是稳定的排序算法。</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>插入排序是原地排序算法。</p><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><ol><li>最好情况：O(n)。</li><li>最坏情况：O(n^2)。</li><li>平均情况：O(n^2)（往数组中插入一个数的平均时间复杂度是O(n)，一共重复n次）。</li></ol><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$a</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$n</span> = count(<span class="variable">$a</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$n</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$value</span> = <span class="variable">$a</span>[<span class="variable">$i</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="variable">$i</span> - <span class="number">1</span>; <span class="variable">$j</span> &gt;= <span class="number">0</span>; --<span class="variable">$j</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$a</span>[<span class="variable">$j</span>] &gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">                <span class="variable">$a</span>[<span class="variable">$j</span> + <span class="number">1</span>] = <span class="variable">$a</span>[<span class="variable">$j</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$a</span>[<span class="variable">$j</span> + <span class="number">1</span>] = <span class="variable">$value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、选择排序"><a href="#五、选择排序" class="headerlink" title="五、选择排序"></a>五、选择排序</h3><p>选择排序将数组分成已排序区间和未排序区间。初始已排序区间为空。每次从未排序区间中选出最小的元素插入已排序区间的末尾，直到未排序区间为空。</p><h4 id="稳定性-2"><a href="#稳定性-2" class="headerlink" title="稳定性"></a>稳定性</h4><p>选择排序不是稳定的排序算法。</p><h4 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>选择排序是原地排序算法。</p><h4 id="时间复杂度：（都是O-n-2-）"><a href="#时间复杂度：（都是O-n-2-）" class="headerlink" title="时间复杂度：（都是O(n^2)）"></a>时间复杂度：（都是O(n^2)）</h4><ol><li>最好情况：O(n^2)。</li><li>最坏情况：O(n^2)。</li><li>平均情况：O(n^2)。</li></ol><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 选择排序</span></span><br><span class="line"><span class="comment">* 时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> array $list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$list</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$n</span> = count(<span class="variable">$list</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span> - <span class="number">1</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$min</span> = <span class="variable">$i</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="variable">$i</span> + <span class="number">1</span>; <span class="variable">$j</span> &lt; <span class="variable">$n</span>; <span class="variable">$j</span>++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$list</span>[<span class="variable">$j</span>] &lt; <span class="variable">$list</span>[<span class="variable">$min</span>]) &#123;</span><br><span class="line">                <span class="variable">$min</span> = <span class="variable">$j</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$min</span> != <span class="variable">$i</span>) &#123;</span><br><span class="line">            <span class="variable">$value</span> = <span class="variable">$list</span>[<span class="variable">$min</span>];</span><br><span class="line">            <span class="variable">$list</span>[<span class="variable">$min</span>] = <span class="variable">$list</span>[<span class="variable">$i</span>];</span><br><span class="line">            <span class="variable">$list</span>[<span class="variable">$i</span>] = <span class="variable">$value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ol><li>冒泡排序和插入排序的时间复杂度相同，都是<code>O(n^2)</code>，在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序算法呢？<br>答：从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个，所以在对相同数组进行排序时，冒泡排序的运行时间理论上要长于插入排序。</li><li>这种排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？<br>答：是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化</li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP-三次握手和四次挥手简单理解</title>
      <link href="2020/08/14/TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
      <url>2020/08/14/TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="三次握手（three-way-handshaking）"><a href="#三次握手（three-way-handshaking）" class="headerlink" title="三次握手（three-way handshaking）"></a>三次握手（three-way handshaking）</h3><blockquote><p>在Google Groups的TopLanguage中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“TCP建立连接为什么是三次握手？”的问题，在众多回复中，有一条回复写道：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。这可视为对“三次握手”目的的另一种解答思路</p></blockquote><ol><li><p>背景：TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。</p></li><li><p>原理：</p><ol><li>发送端首先发送一个带有SYN（synchronize）标志地数据包给接收方。</li><li>接收方接收后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了。</li><li>最后，发送方再回传一个带有ACK标志的数据包，代表我知道了，表示’握手‘结束。</li></ol></li><li><p>通俗的说法</p><ol><li><p>Client：嘿，李四，是我，听到了吗？</p></li><li><p>Server：我听到了，你能听到我的吗?</p></li><li><p>Client：好的，我们互相都能听到对方的话，我们的通信可以开始了。</p><p> <img src="3.png" alt="三次握手">        </p></li></ol></li></ol><h3 id="四次挥手（Four-Way-Wavehand）"><a href="#四次挥手（Four-Way-Wavehand）" class="headerlink" title="四次挥手（Four-Way-Wavehand）"></a>四次挥手（Four-Way-Wavehand）</h3><ol><li><p>意义：当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</p></li><li><p>原理：</p><ol><li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li><li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</li><li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li><li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手</li></ol></li><li><p>通俗的说法</p><ol><li><p>Client：我所有东西都说完了</p></li><li><p>Server：我已经全部听到了，但是等等我，我还没说完</p></li><li><p>Server：好了，我已经说完了</p></li><li><p>Client：好的，那我们的通信结束l</p><p> <img src="4.png" alt="四次挥手">     </p></li></ol></li></ol><p>作者：心如简_cc99<br>链接：<a href="https://www.jianshu.com/p/d3725391af59">https://www.jianshu.com/p/d3725391af59</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT远程仓库</title>
      <link href="2020/07/23/GIT%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>2020/07/23/GIT%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>要参与任何一个 Git 项目的协作，必须要了解该如何管理远程仓库。远程仓库是指托管在网络上的项目仓库，可能会有好多个，其中有些你只能读，另外有些可以写。同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展。 管理远程仓库的工作，包括添加远程库，移除废弃的远程库，管理各式远程库分支，定义是否跟踪这些分支，等等</p></blockquote><h3 id="查看当前远程仓库"><a href="#查看当前远程仓库" class="headerlink" title="查看当前远程仓库"></a>查看当前远程仓库</h3><p>要查看当前配置有哪些远程仓库，可以用 <code>git remote</code> 命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 <code>origin</code> 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit.git</span><br><span class="line">Cloning into &#39;ticgit&#39;...</span><br><span class="line">remote: Reusing existing pack: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (1857&#x2F;1857), 374.35 KiB | 193.00 KiB&#x2F;s, done.</span><br><span class="line">Resolving deltas: 100% (772&#x2F;772), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">$ cd ticgit</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>也可以加上 <code>-v</code> 选项（译注：此为 <code>--verbose</code> 的简写，取首字母），显示对应的克隆地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit.git (fetch)</span><br><span class="line">origin  git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit.git (push)</span><br></pre></td></tr></table></figure><p>如果有多个远程仓库，此命令将全部列出。比如在我的 Grit 项目中，可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd grit</span><br><span class="line">$ git remote -v</span><br><span class="line">bakkdoor  git:&#x2F;&#x2F;github.com&#x2F;bakkdoor&#x2F;grit.git</span><br><span class="line">cho45     git:&#x2F;&#x2F;github.com&#x2F;cho45&#x2F;grit.git</span><br><span class="line">defunkt   git:&#x2F;&#x2F;github.com&#x2F;defunkt&#x2F;grit.git</span><br><span class="line">koke      git:&#x2F;&#x2F;github.com&#x2F;koke&#x2F;grit.git</span><br><span class="line">origin    git@github.com:mojombo&#x2F;grit.git</span><br></pre></td></tr></table></figure><p>这样一来，我就可以非常轻松地从这些用户的仓库中，拉取他们的提交到本地。请注意，上面列出的地址只有 <code>origin</code> 用的是 <code>SSH URL</code> 链接，所以也只有这个仓库我能推送数据上去</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 <code>git remote add [shortname] [url]</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb git:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit.git</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit.git</span><br><span class="line">pb  git:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit.git</span><br></pre></td></tr></table></figure><p>现在可以用字符串 <code>pb</code> 指代对应的仓库地址了。比如说，要抓取所有 <code>Paul</code> 有的，但本地仓库没有的信息，可以运行 <code>git fetch pb</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch pb</span><br><span class="line">remote: Counting objects: 58, done.</span><br><span class="line">remote: Compressing objects: 100% (41&#x2F;41), done.</span><br><span class="line">remote: Total 44 (delta 24), reused 1 (delta 0)</span><br><span class="line">Unpacking objects: 100% (44&#x2F;44), done.</span><br><span class="line">From git:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb&#x2F;master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb&#x2F;ticgit</span><br></pre></td></tr></table></figure><p>现在，<code>Paul</code> 的主干分支<code>master</code>已经完全可以在本地访问了，对应的名字是 pb/master，你可以将它合并到自己的某个分支，或者切换到这个分支，看看有些什么有趣的更新。</p><h3 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h3><p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。</p><p>如果是克隆了一个仓库，此命令会自动将远程仓库归于 <code>origin</code> 名下。所以，<code>git fetch origin</code> 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。</p><p>如果设置了某个分支用于跟踪某个远端仓库的分支（参见下节及第三章的内容），可以使用 <code>git pull</code> 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 <code>git clone</code> 命令本质上就是自动创建了本地的 <code>master</code> 分支用于跟踪远程仓库中的 <code>master</code> 分支（假设远程仓库确实有 <code>master</code> 分支）。所以一般我们运行<code>git pull</code>，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p><h3 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h3><p>项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单： <code>git push [remote-name] [branch-name]</code>。如果要把本地的 <code>master</code> 分支推送到 <code>origin</code> 服务器上（再次说明下，克隆操作会自动使用默认的 <code>master</code> 和 <code>origin</code> 名字），可以运行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送</p><h3 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h3><p>我们可以通过命令 <code>git remote show [remote-name]</code> 查看某个远程仓库的详细信息，比如要看所克隆的 origin 仓库，可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  URL: git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit.git</span><br><span class="line">  Remote branch merged with &#39;git pull&#39; while on branch master</span><br><span class="line">    master</span><br><span class="line">  Tracked remote branches</span><br><span class="line">    master</span><br><span class="line">    ticgit</span><br></pre></td></tr></table></figure><p>除了对应的克隆地址外，它还给出了许多额外的信息。它友善地告诉你如果是在 <code>master</code> 分支，就可以用 <code>git pull</code> 命令抓取数据合并到本地。另外还列出了所有处于跟踪状态中的远端分支。</p><p>上面的例子非常简单，而随着使用 <code>Git</code> 的深入，<code>git remote show</code> 给出的信息可能会像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  URL: git@github.com:defunkt&#x2F;github.git</span><br><span class="line">  Remote branch merged with &#39;git pull&#39; while on branch issues</span><br><span class="line">    issues</span><br><span class="line">  Remote branch merged with &#39;git pull&#39; while on branch master</span><br><span class="line">    master</span><br><span class="line">  New remote branches (next fetch will store in remotes&#x2F;origin)</span><br><span class="line">    caching</span><br><span class="line">  Stale tracking branches (use &#39;git remote prune&#39;)</span><br><span class="line">    libwalker</span><br><span class="line">    walker2</span><br><span class="line">  Tracked remote branches</span><br><span class="line">    acl</span><br><span class="line">    apiv2</span><br><span class="line">    dashboard2</span><br><span class="line">    issues</span><br><span class="line">    master</span><br><span class="line">    postgres</span><br><span class="line">  Local branch pushed with &#39;git push&#39;</span><br><span class="line">    master:master</span><br></pre></td></tr></table></figure><p>它告诉我们，运行 <code>git push</code> 时缺省推送的分支是什么（译注：最后两行）。它还显示了有哪些远端分支还没有同步到本地（译注：第六行的 <code>caching</code> 分支），哪些已同步到本地的远端分支在远端服务器上已被删除（译注：<code>Stale tracking branches</code> 下面的两个分支），以及运行 <code>git pull</code> 时将自动合并哪些分支（译注：前四行中列出的 <code>issues</code> 和 <code>master</code> 分支）。</p><h3 id="远程仓库的删除与重命名"><a href="#远程仓库的删除与重命名" class="headerlink" title="远程仓库的删除与重命名"></a>远程仓库的删除与重命名</h3><p>在新版 <code>Git</code> 中可以用 <code>git remote rename</code> 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 <code>pb/master</code> 分支现在成了 <code>paul/master</code>。</p><p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 <code>git remote rm</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h3 id="拉取远程分支并创建本地分支"><a href="#拉取远程分支并创建本地分支" class="headerlink" title="拉取远程分支并创建本地分支"></a>拉取远程分支并创建本地分支</h3><p><code>git checkout -b 本地分支名x origin/远程分支名x</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hhhh master</span><br></pre></td></tr></table></figure><p>以<code>master</code>为模板，创建<code>hhhh</code>分支，并且切换到<code>hhhh</code>分支。使用该方式会在本地新建分支x，并自动切换到该本地分支x。</p>]]></content>
      
      
      <categories>
          
          <category> MAC使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希算法</title>
      <link href="2020/07/14/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>2020/07/14/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="带着问题来学习："><a href="#带着问题来学习：" class="headerlink" title="带着问题来学习："></a>带着问题来学习：</h3><ol><li>如何防止数据库中的用户信息被脱库？</li><li>你会如何存储用户密码这么重要的数据吗？仅仅 MD5 加密一下存储就够了吗？</li><li>在实际开发中，我们应该如何用哈希算法解决问题？</li></ol><p>###一、什么是哈希算法？</p><ol><li>定义<br>将任意长度的二进制值串映射成固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。</li><li>如何设计一个优秀的哈希算法？<ol><li>单向哈希：<br>从哈希值不能反向推导出哈希值（所以哈希算法也叫单向哈希算法）。</li><li>篡改无效：<br>对输入敏感，哪怕原始数据只修改一个Bit，最后得到的哈希值也大不相同。</li><li>散列冲突：<br>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小。</li><li>执行效率：<br>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速计算哈希值。</li></ol></li></ol><h3 id="二、哈希算法的常见应用有哪些？"><a href="#二、哈希算法的常见应用有哪些？" class="headerlink" title="二、哈希算法的常见应用有哪些？"></a>二、哈希算法的常见应用有哪些？</h3><p>7个常见应用：安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。</p><ol><li>安全加密<ol><li>常用于加密的哈希算法：<ul><li>MD5：MD5 Message-Digest Algorithm，MD5消息摘要算法</li><li>SHA：Secure Hash Algorithm，安全散列算法</li><li>DES：Data Encryption Standard，数据加密标准</li><li>AES：Advanced Encryption Standard，高级加密标准</li></ul></li><li>对用于加密的哈希算法，有两点格外重要，第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要小。</li><li>在实际开发中要权衡破解难度和计算时间来决定究竟使用哪种加密算法。</li></ol></li><li>唯一标识<br>通过哈希算法计算出数据的唯一标识，从而用于高效检索数据。</li><li>数据校验<br>利用哈希算法对输入数据敏感的特点，可以对数据取哈希值，从而高效校验数据是否被篡改过。</li><li>散列函数<br>散列函数中用到的哈希算法更加关注散列后的值能不能平均分布，以及散列函数的执行快慢。</li><li>负载均衡<br>我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：<ul><li>如果客户端很多，映射表可能会很大，比较浪费内存空间</li><li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大<br>通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</li></ul></li><li>数据分片<ol><li>如何统计“搜索关键词”出现的次数<ol><li>有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数</li><li>我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果</li><li>这里的处理过程也是 MapReduce 的基本设计思想。</li></ol></li><li>如何快速判断图片是否在图库中<ol><li>图库中有 1 亿张图片</li><li>我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</li><li>针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制</li></ol></li></ol></li><li>分布式存储<ol><li>为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是，我们就需要将数据分布在多台机器上。通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。</li><li>问题：如果原来的 10 个机器已经无法承受了，我们就需要扩容了，比如扩到 11 个机器，这时候麻烦就来了。因为，这里并不是简单地加个机器就可以了</li><li>解决方案-一致性哈希算法<br> 假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</li></ol></li></ol><h3 id="三、思考"><a href="#三、思考" class="headerlink" title="三、思考"></a>三、思考</h3><ol><li>如何防止数据库中的用户信息被脱库？你会如何存储用户密码这么重要的数据吗？<ol><li>使用MD5进行加密</li><li>字典攻击：如果用户信息被“脱库”，黑客虽然拿到的是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。</li><li>针对字典攻击，我们可以引入一个盐（salt），跟用户密码组合在一起，增加密码的复杂度。</li></ol></li><li>现在，区块链是一个很火的领域，它被很多人神秘化，不过其底层的实现原理并不复杂。其中，哈希算法就是它的一个非常重要的理论基础。你能讲一讲区块链使用的是哪种哈希算法吗？是为了解决什么问题而使用的呢？<br> 区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体。区块头保存着 自己区块体 和 上一个区块头 的哈希值。因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。</li><li>有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢<br> 我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP数组排序</title>
      <link href="2020/07/08/PHP%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"/>
      <url>2020/07/08/PHP%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="一维数组排序"><a href="#一维数组排序" class="headerlink" title="一维数组排序"></a>一维数组排序</h3><p>sort() -以升序对数组进行排序<br>rsort() -以降序对数组排序<br>asort() -根据值，以升序对关联数组进行排序<br>ksort() -根据键，以升序对关联数组进行排序<br>arsort() -根据值，以降序对关联数组进行排序<br>krsort() -根据键，以降序对关联数组进行排序</p><h3 id="二维数组排序"><a href="#二维数组排序" class="headerlink" title="二维数组排序"></a>二维数组排序</h3><h4 id="array-multisort"><a href="#array-multisort" class="headerlink" title="array_multisort()"></a><code>array_multisort()</code></h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$idArr</span> = [];</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$v</span>) &#123;</span><br><span class="line">    <span class="variable">$idArr</span>[] = <span class="variable">$v</span>[<span class="string">&#x27;like&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">array_multisort(<span class="variable">$idArr</span>, SORT_DESC, <span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$arr</span>;</span><br></pre></td></tr></table></figure><h4 id="usort"><a href="#usort" class="headerlink" title="usort()"></a><code>usort()</code></h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">usort(<span class="variable">$arr</span>, <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$al</span> = <span class="variable">$a</span>[<span class="string">&#x27;like&#x27;</span>];</span><br><span class="line">    <span class="variable">$bl</span> = <span class="variable">$b</span>[<span class="string">&#x27;like&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$al</span> == <span class="variable">$bl</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable">$al</span> &gt; <span class="variable">$bl</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$arr</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>处理composer.lock文件合并冲突</title>
      <link href="2020/07/01/%E5%A4%84%E7%90%86composer-lock%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81/"/>
      <url>2020/07/01/%E5%A4%84%E7%90%86composer-lock%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<p>多人协同开发过程中，如果同时新增或升级了依赖经常会遇到人工处理 composer.lock/json 文件冲突的情况，下面介绍个简单粗暴的处理方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按需回滚冲突文件到对方的版本</span></span><br><span class="line">git checkout --theirs -- composer.lock composer.json </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新添加自己的依赖或升级</span></span><br><span class="line">composer require &#x27;...&#x27;</span><br></pre></td></tr></table></figure><p>这样可以避免人工解冲突，可以无脑执行，并且不会造成无关包的升级。</p>]]></content>
      
      
      <categories>
          
          <category> MAC使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-trait</title>
      <link href="2020/06/24/PHP-trait/"/>
      <url>2020/06/24/PHP-trait/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。</p></blockquote><blockquote><p>Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。Trait 和 Class 组合的语义定义了一种减少复杂性的方式，避免传统多继承和 Mixin 类相关典型问题。</p></blockquote><blockquote><p>Trait 和 Class 相似，但仅仅旨在用细粒度和一致的方式来组合功能。 无法通过 trait 自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用的几个 Class 之间不需要继承。</p></blockquote><p>Example #1 Trait 示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">trait ezcReflectionReturnInfo &#123;</span><br><span class="line">    function getReturnType() &#123; &#x2F;*1*&#x2F; &#125;</span><br><span class="line">    function getReturnDescription() &#123; &#x2F;*2*&#x2F; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ezcReflectionMethod extends ReflectionMethod &#123;</span><br><span class="line">    use ezcReflectionReturnInfo;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ezcReflectionFunction extends ReflectionFunction &#123;</span><br><span class="line">    use ezcReflectionReturnInfo;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。</p><p>Example #2 优先顺序示例</p><p>从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Base &#123;</span><br><span class="line">    public function sayHello() &#123;</span><br><span class="line">        echo &#39;Hello &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait SayWorld &#123;</span><br><span class="line">    public function sayHello() &#123;</span><br><span class="line">        parent::sayHello();</span><br><span class="line">        echo &#39;World!&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyHelloWorld extends Base &#123;</span><br><span class="line">    use SayWorld;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$o &#x3D; new MyHelloWorld();</span><br><span class="line">$o-&gt;sayHello();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>以上例程会输出：</p><p>Hello World!</p><p>Example #3 另一个优先级顺序的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">trait HelloWorld &#123;</span><br><span class="line">    public function sayHello() &#123;</span><br><span class="line">        echo &#39;Hello World!&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TheWorldIsNotEnough &#123;</span><br><span class="line">    use HelloWorld;</span><br><span class="line">    public function sayHello() &#123;</span><br><span class="line">        echo &#39;Hello Universe!&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$o &#x3D; new TheWorldIsNotEnough();</span><br><span class="line">$o-&gt;sayHello();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>以上例程会输出：</p><p>Hello Universe!</p><h3 id="多个-trait"><a href="#多个-trait" class="headerlink" title="多个 trait"></a>多个 trait</h3><p>通过逗号分隔，在 use 声明列出多个 trait，可以都插入到一个类中。</p><p>Example #4<br>多个 trait 的用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">trait Hello &#123;</span><br><span class="line">    public function sayHello() &#123;</span><br><span class="line">        echo &#39;Hello &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait World &#123;</span><br><span class="line">    public function sayWorld() &#123;</span><br><span class="line">        echo &#39;World&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyHelloWorld &#123;</span><br><span class="line">    use Hello, World;</span><br><span class="line">    public function sayExclamationMark() &#123;</span><br><span class="line">        echo &#39;!&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$o &#x3D; new MyHelloWorld();</span><br><span class="line">$o-&gt;sayHello();</span><br><span class="line">$o-&gt;sayWorld();</span><br><span class="line">$o-&gt;sayExclamationMark();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>以上例程会输出：</p><p>Hello World!</p><h3 id="冲突的解决"><a href="#冲突的解决" class="headerlink" title="冲突的解决"></a>冲突的解决</h3><p>如果两个 trait 都插入了一个同名的方法，如果没有明确解决冲突将会产生一个致命错误。</p><p>为了解决多个 trait 在同一个类中的命名冲突，需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个。</p><p>以上方式仅允许排除掉其它方法，as 操作符可以 为某个方法引入别名。 注意，as 操作符不会对方法进行重命名，也不会影响其方法。</p><p>Example #5 冲突的解决</p><p>在本例中 Talker 使用了 trait A 和 B。由于 A 和 B 有冲突的方法，其定义了使用 trait B 中的 smallTalk 以及 trait A 中的 bigTalk。</p><p>Aliased_Talker 使用了 as 操作符来定义了 talk 来作为 B 的 bigTalk 的别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">trait A &#123;</span><br><span class="line">    public function smallTalk() &#123;</span><br><span class="line">        echo &#39;a&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function bigTalk() &#123;</span><br><span class="line">        echo &#39;A&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait B &#123;</span><br><span class="line">    public function smallTalk() &#123;</span><br><span class="line">        echo &#39;b&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function bigTalk() &#123;</span><br><span class="line">        echo &#39;B&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Talker &#123;</span><br><span class="line">    use A, B &#123;</span><br><span class="line">        B::smallTalk insteadof A;</span><br><span class="line">        A::bigTalk insteadof B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Aliased_Talker &#123;</span><br><span class="line">    use A, B &#123;</span><br><span class="line">        B::smallTalk insteadof A;</span><br><span class="line">        A::bigTalk insteadof B;</span><br><span class="line">        B::bigTalk as talk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>Note:<br>在 PHP 7.0 之前，在类里定义和 trait 同名的属性，哪怕是完全兼容的也会抛出 E_STRICT（完全兼容的意思：具有相同的访问可见性、初始默认值）。<br>修改方法的访问控制</p><p>使用 as 语法还可以用来调整方法的访问控制。</p><p>Example #6 修改方法的访问控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">trait HelloWorld &#123;</span><br><span class="line">    public function sayHello() &#123;</span><br><span class="line">        echo &#39;Hello World!&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改 sayHello 的访问控制</span><br><span class="line">class MyClass1 &#123;</span><br><span class="line">    use HelloWorld &#123; sayHello as protected; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给方法一个改变了访问控制的别名</span><br><span class="line">&#x2F;&#x2F; 原版 sayHello 的访问控制则没有发生变化</span><br><span class="line">class MyClass2 &#123;</span><br><span class="line">    use HelloWorld &#123; sayHello as private myPrivateHello; &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">从 trait 来组成 trait</span><br><span class="line"></span><br><span class="line">正如 class 能够使用 trait 一样，其它 trait 也能够使用 trait。在 trait 定义时通过使用一个或多个 trait，能够组合其它 trait 中的部分或全部成员。</span><br><span class="line"></span><br><span class="line">Example #7 从 trait 来组成 trait</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">trait Hello &#123;</span><br><span class="line">    public function sayHello() &#123;</span><br><span class="line">        echo &#39;Hello &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait World &#123;</span><br><span class="line">    public function sayWorld() &#123;</span><br><span class="line">        echo &#39;World!&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait HelloWorld &#123;</span><br><span class="line">    use Hello, World;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyHelloWorld &#123;</span><br><span class="line">    use HelloWorld;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$o &#x3D; new MyHelloWorld();</span><br><span class="line">$o-&gt;sayHello();</span><br><span class="line">$o-&gt;sayWorld();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>以上例程会输出：</p><p>Hello World!</p><h3 id="Trait-的抽象成员"><a href="#Trait-的抽象成员" class="headerlink" title="Trait 的抽象成员"></a>Trait 的抽象成员</h3><p>为了对使用的类施加强制要求，trait 支持抽象方法的使用。</p><p>Example #8 表示通过抽象方法来进行强制要求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">trait Hello &#123;</span><br><span class="line">    public function sayHelloWorld() &#123;</span><br><span class="line">        echo &#39;Hello&#39;.$this-&gt;getWorld();</span><br><span class="line">    &#125;</span><br><span class="line">    abstract public function getWorld();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyHelloWorld &#123;</span><br><span class="line">    private $world;</span><br><span class="line">    use Hello;</span><br><span class="line">    public function getWorld() &#123;</span><br><span class="line">        return $this-&gt;world;</span><br><span class="line">    &#125;</span><br><span class="line">    public function setWorld($val) &#123;</span><br><span class="line">        $this-&gt;world &#x3D; $val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="Trait-的静态成员"><a href="#Trait-的静态成员" class="headerlink" title="Trait 的静态成员"></a>Trait 的静态成员</h3><p>Traits 可以被静态成员静态方法定义。</p><p>Example #9 静态变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">trait Counter &#123;</span><br><span class="line">    public function inc() &#123;</span><br><span class="line">        static $c &#x3D; 0;</span><br><span class="line">        $c &#x3D; $c + 1;</span><br><span class="line">        echo &quot;$c\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C1 &#123;</span><br><span class="line">    use Counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C2 &#123;</span><br><span class="line">    use Counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$o &#x3D; new C1(); $o-&gt;inc(); &#x2F;&#x2F; echo 1</span><br><span class="line">$p &#x3D; new C2(); $p-&gt;inc(); &#x2F;&#x2F; echo 1</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>Example #10 静态方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">trait StaticExample &#123;</span><br><span class="line">    public static function doSomething() &#123;</span><br><span class="line">        return &#39;Doing something&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Example &#123;</span><br><span class="line">    use StaticExample;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example::doSomething();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP精度问题</title>
      <link href="2020/06/20/PHP%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
      <url>2020/06/20/PHP%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><code>intval(0.58 * 100)</code>输出结果为57</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>要搞明白这个原因, 首先我们要知道浮点数的表示(IEEE 754):</p><ul><li>浮点数, 以64位的长度(双精度)为例， 会采用1位符号位(E)， 11指数位(Q)，52位尾数(M)表示(一共64位)。</li><li>符号位：最高位表示数据的正负，0表示正数，1表示负数。</li><li>指数位：表示数据以2为底的幂，指数采用偏移码表示。</li><li>尾数：表示数据小数点后的有效数字。</li></ul><p>这里的关键点就在于，小数在二进制的表示，关于小数如何用二进制表示，大家可以百度一下,，我这里就不再赘述, 我们关键的要了解，0.58 对于二进制表示来说，是无限长的值(下面的数字省掉了隐含的1)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.58的二进制表示基本上(52位)是: 0010100011110101110000101000111101011100001010001111</span><br><span class="line">0.57的二进制表示基本上(52位)是: 0010001111010111000010100011110101110000101000111101</span><br></pre></td></tr></table></figure><p>而两者的二进制，如果只是通过这52位计算的话，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.58 -&gt; 0.57999999999999996</span><br><span class="line">0.57 -&gt; 0.56999999999999995</span><br></pre></td></tr></table></figure><p>模糊的来看：0.58 * 100 = 57.999999999。<br>经过<code>intval</code>，自然就是57了。<br>可见, 这个问题的关键点就是: “看似有穷的小数, 在计算机的二进制表示里却是无穷的”。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="number">0.1</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">0.7</span>;</span><br><span class="line">var_dump((<span class="variable">$a</span> + <span class="variable">$b</span>) == <span class="number">0.8</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>*<em>PHP浮点型在进行+-</em>%/存在不准确的问题**</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用高精度的数学函数<br>例如使用 <code>bcmul(0.58,100)</code>输出结果为58。</p><p>常用的高精度函数如下</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>bcadd</td><td>将两个高精度的数字相加</td></tr><tr><td>bccomp</td><td>比较两个高精度数字，返回-1, 0, 1</td></tr><tr><td>bcdiv</td><td>将两个高精度数字相除</td></tr><tr><td>bcmod</td><td>求高精度数字余数</td></tr><tr><td>bcmul</td><td>将两个高精度数字相乘</td></tr><tr><td>bcpow</td><td>求高精度数字乘方</td></tr><tr><td>bcpowmod</td><td>求高精度数字乘方求模，数论里非常常用</td></tr><tr><td>bcscale</td><td>配置默认小数点位数，相当于就是Linux bc中的”scale=”</td></tr><tr><td>bcsqrt</td><td>求高精度数字平方根</td></tr><tr><td>bcsub</td><td>将两个高精度数字相减</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP的运行模式</title>
      <link href="2020/06/13/PHP%E7%9A%84%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/06/13/PHP%E7%9A%84%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="如何获取当前运行模式"><a href="#如何获取当前运行模式" class="headerlink" title="如何获取当前运行模式"></a>如何获取当前运行模式</h3><hr><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php_sapi_name()</span><br></pre></td></tr></table></figure><h3 id="CLI-（command-line-interface）命令行接口"><a href="#CLI-（command-line-interface）命令行接口" class="headerlink" title="CLI:（command-line interface）命令行接口"></a>CLI:（command-line interface）命令行接口</h3><hr><p>可以在控制台或者是shell中键入命令。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php index.php</span><br></pre></td></tr></table></figure><h3 id="CGI-：-Common-Gateway-Interface-公共网关接口"><a href="#CGI-：-Common-Gateway-Interface-公共网关接口" class="headerlink" title="CGI ：(Common Gateway Interface)公共网关接口"></a>CGI ：(Common Gateway Interface)公共网关接口</h3><hr><p><code>CGI</code>实际上是一种程序之间的交互协议，通常作为<code>HTTP Server</code>和“程序”进行“交谈”的一种工具。这里的“程序”即实现了<code>CGI</code>协议的程序，我们可以称之为<code>CGI程序</code>，<code>CGI程序</code>的实现语言并没有要求。例如<code>PHP-CGI</code>就是实现了CGI协议的<code>CGI</code>程序，而<code>HTTP Server</code>本身也要实现<code>CGI协议</code>才能和<code>PHP-CGI</code>交互。</p><p>通过<code>CGI</code>协议，保证了<code>HTTP Server</code>传递过来的数据是标准格式的，以方便<code>CGI</code>程序的编写者。服务器要支持<code>CGI</code>就要提供<code>CGI</code>中要求的环境变量。该协议要求<code>HTTP Server</code>把<code>HTTP Request</code>的Header设置成<code>CGI</code>程序的环境变量，<code>HTTP Request</code>的正文设置成<code>CGI</code>程序的标准输入，而<code>CGI</code>程序的标准输出就是<code>HTTP Response</code>，包括Header和正文。</p><p>再进一步具体举例来讲的话，php以CGI方式运行时，web server（比如说nginx）根据配置文件知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP-CGI。Nginx会传哪些数据给PHP-CGI呢？url要有吧，查询字符串也得有吧，POST数据也要有，HTTP header不能少吧，好的，CGI协议就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。将用户请求以消息的方式转交给PHP-CGI独立进程。<br>实际上上面这个流程也说明了一个问题就是PHP与web服务之间并不是从属关系。</p><p>那么，<code>CLI</code>和<code>CGI</code>有哪些显著区别呢？</p><ol><li><code>CLI</code>与<code>CGI SAPI</code>不同，CLI其输出没有任何头信息。<br> 尽管<code>CGI SAPI</code> 提供了取消 HTTP 头信息的方法，但在 <code>CLI SAPI</code> 中并不存在类似的方法以开启 HTTP 头信息的输出。</li><li><code>CLI</code> 默认以安静模式开始，但为了保证兼容性，<code>-q</code> 和 <code>--no-header</code> 参数为了向后兼容仍然保留，使得可以使用旧的<code>CGI</code>脚本。</li><li><code>CLI</code>在运行时，不会把工作目录改为脚本的当前目录（可以使用<code>-C</code>和<code>--no-chdir</code> 参数来兼容CGI模式）。</li><li><code>CLI</code>出错时输出纯文本的错误信息（非 HTML 格式）。</li></ol><h3 id="FastCGI：-Fast-Common-Gateway-Interface-快速公共网关接口"><a href="#FastCGI：-Fast-Common-Gateway-Interface-快速公共网关接口" class="headerlink" title="FastCGI：(Fast Common Gateway Interface)快速公共网关接口"></a>FastCGI：(Fast Common Gateway Interface)快速公共网关接口</h3><hr><p>顾名思义，<code>FastCGI</code>是<code>CGI</code>的升级版本，运行速度更快。传统的CGI程序有很多缺点，比如每接收一个请求就要<code>fork</code>一个新的进程去处理，每次只能接收一个请求作出一个响应，请求结束后该进程就会结束。而<code>FastCGI</code>程序会事先启动起来，作为一个cgi程序的管理服务器存在，预先启动一系列的子进程来等待处理，然后等待web服务器发过来的请求，一旦接受到请求就交由子进程处理，这样由于不需要在接受到请求后启动cgi程序，所以会快很多。</p><p><code>FastCGI</code>使用进程/线程池来处理一连串的请求。这些进程/线程由<code>FastCGI</code>服务器管理，而不是Web服务器。当进来一个请求时，Web服务器把环境变量和这个页面请求通过一个<code>Socket</code>长连接传递给<code>FastCGI</code>进程。<code>FastCGI</code>进程像是一个常驻型的CGI进程，它可以一直执行，在请求到达时不会花费时间去fork一个进程来处理(这是CGI最为人诟病的fork-and-execute模式)。正是因为它只是一个通信协议，它还支持分布式的运算，即FastCGI程序可以在网站服务器以外的主机上执行并且接受来自其他网站服务器的请求。</p><h4 id="FastCGI整个流程"><a href="#FastCGI整个流程" class="headerlink" title="FastCGI整个流程"></a>FastCGI整个流程</h4><ol><li>Web server启动时载入FastCGI进程管理器</li><li>FastCGI自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web server的请求</li><li>当请求Web server时，Web server通过socket请求FastCGI进程管理器，FastCGI进程管理器选择并连接到一个PHP-CGI，Web server将CGI环境变量和标准输入发送到FastCGI子进程PHP-CGI</li><li>FastCGI子进程处理请求完成后将标准输出和错误从同一连接返回给Web server，当FastCGI子进程结束后请求便结束。FastCGI子进程接着等待处理来自FastCGI进程管理器的下一个连接。（在CGI模式中，php-cgi在此便退出了）。</li></ol><h4 id="PHP-FPM：-PHP-Fast-CGI-Process-Manager-PHP-FastCGI进程管理器"><a href="#PHP-FPM：-PHP-Fast-CGI-Process-Manager-PHP-FastCGI进程管理器" class="headerlink" title="PHP-FPM：(PHP Fast CGI Process Manager)PHP-FastCGI进程管理器"></a>PHP-FPM：(PHP Fast CGI Process Manager)PHP-FastCGI进程管理器</h4><p><code>PHP-FPM</code>是一个实现了<code>FastCGI</code>协议的程序，被PHP官方收了。也可以说<code>php-fpm</code>是实现了<code>FastCGI</code>协议的<code>php-cgi</code>进程的管理器，用来管理<code>FastCGI</code>进程的。</p><p>通过上面我们知道，<code>php-cgi</code>只是一个<code>CGI</code>程序，本身只能解析请求，返回结果，不会进程管理。所以就出现了一些能够调度<code>php-cgi</code>进程的程序，比如说由<code>lighthttpd</code>分离出来的<code>spawn-fcgi</code>。所以<code>PHP-FPM</code>也是这么个东东，在长时间的发展后，逐渐得到了大家的认可（要知道，前几年大家可是抱怨PHP-FPM稳定性太差的），也越来越流行。 </p><h3 id="mod-php：即apache的php模块"><a href="#mod-php：即apache的php模块" class="headerlink" title="mod_php：即apache的php模块"></a>mod_php：即apache的php模块</h3><hr><p><code>Mod_php</code>模式将PHP做为web-server的子进程控制,两者之间有从属关系.最明显的例子就是在CGI模式下,如果修改了PHP.INI的配置文件,不用重启web服务便可生效,而模块模式下则需要重启web服务。以mod_php模式运行PHP，意味着php是作为apache的一个模块来启动的，因此只有在apache启动的时候会读取php.ini配置文件并加载扩展模块，在apache运行期间是不会再去读取和加载扩展模块的</p><h4 id="Apache的工作模式prefork的工作原理"><a href="#Apache的工作模式prefork的工作原理" class="headerlink" title="Apache的工作模式prefork的工作原理"></a>Apache的工作模式prefork的工作原理</h4><p>一个单独的控制进程(父进程)负责产生子进程，这些子进程用于监听请求并作出应答。Apache总是试图保持一些备用的 (spare)或是空闲的子进程用于迎接即将到来的请求。这样客户端就无需在得到服务前等候子进程的产生。在Unix系统中，父进程通常以root身份运行以便邦定80端口，而 Apache产生的子进程通常以一个低特权的用户运行。User和Group指令用于配置子进程的低特权用户。运行子进程的用户必须要对他所服务的内容有读取的权限，但是对服务内容之外的其他资源必须拥有尽可能少的权限。</p><h4 id="worker的工作原理"><a href="#worker的工作原理" class="headerlink" title="worker的工作原理"></a>worker的工作原理</h4><p>每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。Apache总是试图维持一个备用(spare)或是空闲的服务线程池。这样，客户端无须等待新线程或新进程的建立即可得到处理。在Unix中，为了能够绑定80端口，父进程一般都是以root身份启动，随后，Apache以较低权限的用户建立子进程和线程。User和Group指令用于配置Apache子进程的权限。虽然子进程必须对其提供的内容拥有读权限，但应该尽可能给予他较少的特权。另外，除非使用了suexec ，否则，这些指令配置的权限将被CGI脚本所继承</p><p>个人理解:这种模式把php嵌入到apache中，相当于给apache加入了解析php文件的功能。</p><h3 id="基于fast-cgi协议模式的nginx和php-fpm交互细节"><a href="#基于fast-cgi协议模式的nginx和php-fpm交互细节" class="headerlink" title="基于fast-cgi协议模式的nginx和php-fpm交互细节"></a>基于fast-cgi协议模式的nginx和php-fpm交互细节</h3><hr><p>Nginx与PHP-fpm之间通过socket进行通讯，主要有两种通信方式<code>unix socket</code>和<code>tcp socket</code></p><ol><li><p>nginx配置比较</p><ul><li><p><code>unix socket</code>需要在<code>nginx</code>配置文件中填写<code>php-fpm</code>运行的pid文件（即sock文件）地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">include fastcgi_params;</span><br><span class="line">       fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;;</span><br><span class="line">       fastcgi_pass unix:&#x2F;var&#x2F;run&#x2F;php5-fpm.sock;</span><br><span class="line">       fastcgi_index index.php;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>tcp socket</code>需要在<code>nginx</code>配置文件中填写php-fpm运行的ip地址和端口号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;;</span><br><span class="line">    fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    fastcgi_index index.php;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特点比较</p><p> <code>unix socket</code>减少了不必要的tcp开销，而tcp需要经过loopback，还要申请临时端口和tcp相关资源。但是，<code>unix socket</code>高并发时候不稳定，连接数爆发时，会产生大量的长时缓存，在没有面向连接协议的支撑下，大数据包可能会直接出错不返回异常。tcp这样的面向连接的协议，多少可以保证通信的正确性和完整性。</p></li></ol><p>选择建议：如果是在同一台服务器上运行的nginx和php-fpm，并发量不超过1000，选择<code>unix socket</code>，因为是本地，可以避免一些检查操作(路由等)，因此更快，更轻。 如果面临高并发业务，我会选择使用更可靠的<code>tcp socket</code>，以负载均衡、内核优化等运维手段维持效率。</p><h3 id="nginx和php配合处理请求的通用流程："><a href="#nginx和php配合处理请求的通用流程：" class="headerlink" title="nginx和php配合处理请求的通用流程："></a>nginx和php配合处理请求的通用流程：</h3><hr><ol><li><code>nginx.conf</code>配置<code>webserver</code>参数, 请求PHP类应用可配置<code>fastcgi_pass</code>，指明监听端口或socket地址</li><li><code>php-fpm.conf</code>中listen地址与<code>nginx.conf fastcgi_pass</code>字段配置一致（sock文件或是端口），表明<code>php-fpm worker</code>进程监听目标</li><li>启动后，请求先到达<code>nginx server</code>端口，分发到对应位置，若配置了<code>fastcgi-pass</code>，则被转到对应端口或<code>socket</code>，<code>php-fpm master</code>进程监听到，再创建<code>fork worker</code>进程实际运行，运行结束返回给nginx。即如下所示：<pre><code> www.example.com =》 Nginx =》 路由到www.example.com/index.php =》 加载nginx的fast-cgi模块 =》 fast-cgi监听127.0.0.1:9000地址=》 www.example.com/index.php请求到达127.0.0.1:9000 =》 php-fpm 监听127.0.0.1:9000 =》 php-fpm 接收到请求，启用worker进程处理请求 =》 php-fpm 处理完请求，返回给nginx =》 nginx将结果通过http返回给浏览器</code></pre></li></ol><p>所以综上所述，Nginx和phpcgi都是实现了cgi协议的cgi程序，cgi协议规定了交互（输入和输出）的数据格式和方式，这个方式就是socket</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列表（下）</title>
      <link href="2020/06/02/%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>2020/06/02/%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="带着问题学习"><a href="#带着问题学习" class="headerlink" title="带着问题学习"></a>带着问题学习</h3><ol><li>为什么散列表和链表经常放在一起使用？</li><li>散列表和链表如何组合起来使用？</li></ol><h3 id="一、为什么散列表和链表经常放在一起使用？"><a href="#一、为什么散列表和链表经常放在一起使用？" class="headerlink" title="一、为什么散列表和链表经常放在一起使用？"></a>一、为什么散列表和链表经常放在一起使用？</h3><ol><li>散列表的优点：支持高效的数据插入、删除和查找操作</li><li>散列表的缺点：不支持快速顺序遍历散列表中的数据</li><li>如何按照顺序快速遍历散列表的数据？只能将数据转移到数组，然后排序，最后再遍历数据。</li><li>我们知道散列表是动态的数据结构，需要频繁的插入和删除数据，那么每次顺序遍历之前都需要先排序，这势必会造成效率非常低下。</li><li>如何解决上面的问题呢？就是将散列表和链表（或跳表）结合起来使用。</li></ol><h3 id="二、散列表和链表如何组合起来使用？"><a href="#二、散列表和链表如何组合起来使用？" class="headerlink" title="二、散列表和链表如何组合起来使用？"></a>二、散列表和链表如何组合起来使用？</h3><ol><li>LRU（Least Recently Used）缓存淘汰算法<ol><li>LRU缓存淘汰算法主要操作有哪些？主要包含3个操作：<ol><li>往缓存中添加一个数据；</li><li>从缓存中删除一个数据；</li><li>在缓存中查找一个数据；</li><li>总结：上面3个都涉及到查找。</li></ol></li><li>如何用链表实现LRU缓存淘汰算法？<ol><li>需要维护一个按照访问时间从大到小的有序排列的链表结构。</li><li>缓冲空间有限，当空间不足需要淘汰一个数据时直接删除链表头部的节点。</li><li>当要缓存某个数据时，先在链表中查找这个数据。若未找到，则直接将数据放到链表的尾部。若找到，就把它移动到链表尾部。</li><li>前面说了，LRU缓存的3个主要操作都涉及到查找，若单纯由链表实现，查找的时间复杂度很高为O(n)。若将链表和散列表结合使用，查找的时间复杂度会降低到O(1)。</li></ol></li><li>如何使用散列表和链表实现LRU缓存淘汰算法？<ol><li>使用双向链表存储数据，链表中每个节点存储数据（data）、前驱指针（prev）、后继指针（next）和hnext指针（解决散列冲突的链表指针）。</li><li>散列表通过链表法解决散列冲突，所以每个节点都会在两条链中。一条链是双向链表，另一条链是散列表中的拉链。前驱和后继指针是为了将节点串在双向链表中，hnext指针是为了将节点串在散列表的拉链中。</li><li>LRU缓存淘汰算法的3个主要操作如何做到时间复杂度为O(1)呢？<br>首先，我们明确一点就是链表本身插入和删除一个节点的时间复杂度为O(1)，因为只需更改几个指针指向即可。<br>接着，来分析查找操作的时间复杂度。当要查找一个数据时，通过散列表可实现在O(1)时间复杂度找到该数据，再加上前面说的插入或删除的时间复杂度是O(1)，所以我们总操作的时间复杂度就是O(1)。</li></ol></li></ol></li><li>Redis有序集合<ol><li>什么是有序集合？<ol><li>在有序集合中，每个成员对象有2个重要的属性，即key（键值）和score（分值）。</li><li>不仅会通过score来查找数据，还会通过key来查找数据。</li></ol></li><li>有序集合的操作有哪些？<br> 举个例子，比如用户积分排行榜有这样一个功能：可以通过用户ID来查找积分信息，也可以通过积分区间来查找用户ID。这里用户ID就是key，积分就是score。所以，有序集合的操作如下：<ol><li>添加一个对象；</li><li>根据键值删除一个对象；</li><li>根据键值查找一个成员对象；</li><li>根据分值区间查找数据，比如查找积分在[100.356]之间的成员对象；</li><li>按照分值从小到大排序成员变量。<br>这时可以按照分值将成员对象组织成跳表结构，按照键值构建一个散列表。那么上面的所有操作都非常高效。</li></ol></li></ol></li><li>Java LinkedHashMap<br>和LRU缓存淘汰策略实现一模一样。支持按照插入顺序遍历数据，也支持按照访问顺序遍历数据。</li></ol><h3 id="三、课后思考"><a href="#三、课后思考" class="headerlink" title="三、课后思考"></a>三、课后思考</h3><ol><li><p>上面所讲的几个散列表和链表组合的例子里，我们都是使用双向链表。如果把双向链表改成单链表，还能否正常工作？为什么呢？<br>在删除一个元素时，虽然能 O(1) 的找到目标结点，但是要删除该结点需要拿到前一个结点的指针，遍历到前一个结点复杂度会变为 O(N），所以用双链表实现比较合适。</p></li><li><p>假设猎聘网有10万名猎头，每个猎头可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这10万个猎头的ID和积分信息，让它能够支持这样几个操作：</p><ol><li><p>根据猎头ID查收查找、删除、更新这个猎头的积分信息；</p></li><li><p>查找积分在某个区间的猎头ID列表；</p></li><li><p>查找按照积分从小到大排名在第x位到第y位之间的猎头ID列表。</p><p>答：</p></li></ol><ul><li>ID 在散列表中所以可以 O(1) 查找到这个猎头；</li><li>积分以跳表存储，跳表支持区间查询；</li><li>积分数量用链表进行存储，达到区间查找逻辑</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列表（中）</title>
      <link href="2020/05/30/%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>2020/05/30/%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题目：如何设计一个工业级的散列函数？"><a href="#面试题目：如何设计一个工业级的散列函数？" class="headerlink" title="面试题目：如何设计一个工业级的散列函数？"></a>面试题目：如何设计一个工业级的散列函数？</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？结合学过的知识，我觉的应该有这样的要求：</p><ol><li>支持快速的查询、插入、删除操作；</li><li>内存占用合理，不能浪费过多空间；</li><li>性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况。</li></ol><h3 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h3><p>如何设计这样一个散列表呢？根据前面讲到的知识，从3个方面来考虑设计思路：</p><ol><li>设计一个合适的散列函数；</li><li>定义装载因子阈值，并且设计动态扩容策略；</li><li>选择合适的散列冲突解决方法。</li></ol><h2 id="知识总结："><a href="#知识总结：" class="headerlink" title="知识总结："></a>知识总结：</h2><h3 id="一、如何设计散列函数？"><a href="#一、如何设计散列函数？" class="headerlink" title="一、如何设计散列函数？"></a>一、如何设计散列函数？</h3><ol><li>要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。</li><li>除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。</li><li>常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。</li></ol><h3 id="二、如何根据装载因子动态扩容？"><a href="#二、如何根据装载因子动态扩容？" class="headerlink" title="二、如何根据装载因子动态扩容？"></a>二、如何根据装载因子动态扩容？</h3><ol><li>如何设置装载因子阈值？<ol><li>可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，插入数据的时间复杂度使用摊还分析法。</li><li>装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如何权衡？如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。</li></ol></li><li>如何避免低效扩容？分批扩容<ol><li>分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。</li><li>分批扩容的查询操作：先查新散列表，再查老散列表。</li><li>通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。</li></ol></li></ol><h3 id="三、如何选择散列冲突解决方法？"><a href="#三、如何选择散列冲突解决方法？" class="headerlink" title="三、如何选择散列冲突解决方法？"></a>三、如何选择散列冲突解决方法？</h3><ol><li>常见的2中方法：开放寻址法和链表法。</li><li>大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击。</li><li>但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列表（上）</title>
      <link href="2020/05/29/%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>2020/05/29/%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、散列表的由来？"><a href="#一、散列表的由来？" class="headerlink" title="一、散列表的由来？"></a>一、散列表的由来？</h3><p>1.散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。<br>2.需要存储在散列表中的数据我们称为键，将键转化为数组下标的方法称为散列函数，散列函数的计算结果称为散列值。<br>3.将数据存储在散列值对应的数组下标位置。</p><h3 id="二、如何设计散列函数？"><a href="#二、如何设计散列函数？" class="headerlink" title="二、如何设计散列函数？"></a>二、如何设计散列函数？</h3><p>总结3点设计散列函数的基本要求<br>1.散列函数计算得到的散列值是一个非负整数。<br>2.若key1=key2，则hash(key1)=hash(key2)<br>3.若key≠key2，则hash(key1)≠hash(key2)<br>正是由于第3点要求，所以产生了几乎无法避免的散列冲突问题。</p><h3 id="三、散列冲突的解放方法？"><a href="#三、散列冲突的解放方法？" class="headerlink" title="三、散列冲突的解放方法？"></a>三、散列冲突的解放方法？</h3><ol><li>常用的散列冲突解决方法有2类：开放寻址法（open addressing）和链表法（chaining）</li><li>开放寻址法<ol><li>核心思想：如果出现散列冲突，就重新探测一个空闲位置，将其插入。</li><li>线性探测法（Linear Probing）：<ul><li>插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</li><li>查找数据：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。</li><li>删除数据：为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。</li><li>结论：最坏时间复杂度为O(n)</li></ul></li><li>二次探测（Quadratic probing）：线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。</li><li>双重散列（Double hashing）：使用一组散列函数，直到找到空闲位置为止。</li><li>线性探测法的性能描述：<ul><li>用“装载因子”来表示空位多少，公式：散列表装载因子=填入表中的个数/散列表的长度。</li><li>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</li></ul></li></ol></li><li>链表法（更常用）<br>插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。<br>查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。</li></ol><h3 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h3><ol><li>Word文档中单词拼写检查功能是如何实现的？<br>字符串占用内存大小为8字节，20万单词占用内存大小不超过20MB，所以用散列表存储20万英文词典单词，然后对每个编辑进文档的单词进行查找，若未找到，则提示拼写错误。</li><li>假设我们有10万条URL访问日志，如何按照访问次数给URL排序？<br>字符串占用内存大小为8字节，10万条URL访问日志占用内存不超过10MB，通过散列表统计url访问次数，然后用TreeMap存储散列表的元素值（作为key）和数组下标值（作为value）</li><li>有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？<br>分别将2个数组的字符串通过散列函数映射到散列表，散列表中的元素值为次数。注意，先存储的数组中的相同元素值不进行次数累加。最后，统计散列表中元素值大于等于2的散列值对应的字符串就是两个数组中相同的字符串。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库与缓存双写一致性方案解析</title>
      <link href="2020/05/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90/"/>
      <url>2020/05/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h3><p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。</p><h4 id="原因一（线程安全角度）"><a href="#原因一（线程安全角度）" class="headerlink" title="原因一（线程安全角度）"></a>原因一（线程安全角度）</h4><p>同时有请求A和请求B进行更新操作，那么会出现</p><ol><li>线程A更新了数据库；</li><li>线程B更新了数据库；</li><li>线程B更新了缓存；</li><li>线程A更新了缓存；</li></ol><p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p><h4 id="原因二（业务场景角度）"><a href="#原因二（业务场景角度）" class="headerlink" title="原因二（业务场景角度）"></a>原因二（业务场景角度）</h4><p>有如下两点：</p><ol><li>如果是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读，缓存就被频繁的更新，浪费性能。</li><li>如果写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</li></ol><h3 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h3><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p><ol><li>请求A进行写操作，删除缓存；</li><li>请求B查询发现缓存不存在；</li><li>请求B去数据库查询得到旧值；</li><li>请求B将旧值写入缓存；</li><li>请求A将新值写入数据库。</li></ol><p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p><p>那么，如何解决呢？采用延时双删策略。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为中文描述就是：</p><ol><li>先淘汰缓存；</li><li>再写数据库（这两步和原来一样）；</li><li>休眠1秒，再次淘汰缓存。</li></ol><p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。</p><p>那么，这个1秒怎么确定的，具体该休眠多久呢？</p><p>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p><p>如果用了mysql的读写分离架构怎么办？</p><p>在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p><ol><li>请求A进行写操作，删除缓存；</li><li>请求A将数据写入数据库了；</li><li>请求B查询缓存发现，缓存没有值；</li><li>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值；</li><li>请求B将旧值写入缓存</li><li>数据库完成主从同步，从库变为新值</li></ol><p>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</p><p>采用这种同步淘汰策略，吞吐量降低怎么办？</p><p>那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p><p>第二次删除,如果删除失败怎么办？</p><p>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：</p><ol><li>请求A进行写操作，删除缓存</li><li>请求B查询发现缓存不存在</li><li>请求B去数据库查询得到旧值</li><li>请求B将旧值写入缓存</li><li>请求A将新值写入数据库</li><li>请求A试图去删除请求B写入对缓存值，结果失败了。</li></ol><p>这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。</p><h3 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">《Cache-Aside pattern》</a>。其中就指出</p><ul><li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li>命中：应用程序从cache中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><p>另外，知名社交网站facebook也在论文<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">《Scaling Memcache at Facebook》</a>中提出，他们用的也是先更新数据库，再删缓存的策略。</p><p>这种情况不存在并发问题么？<br>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p><ol><li>缓存刚好失效</li><li>请求A查询数据库，得一个旧值</li><li>请求B将新值写入数据库</li><li>请求B删除缓存</li><li>请求A将查到的旧值写入缓存</li></ol><p>ok，如果发生上述情况，确实是会发生脏数据。然而，发生这种情况的概率又有多少呢？</p><p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。假设，有人非要抬杠，有强迫症，一定要解决怎么办？如何解决上述并发问题？首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。</p><h3 id="删缓存失败了怎么办"><a href="#删缓存失败了怎么办" class="headerlink" title="删缓存失败了怎么办"></a>删缓存失败了怎么办</h3><p>提供一个保障的重试机制，这里给出两套方案</p><h4 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h4><p><img src="1.png" alt="方案1"></p><p>流程如下所示</p><ol><li>更新数据库数据；</li><li>缓存因为种种问题删除失败；</li><li>将需要删除的key发送至消息队列；</li><li>自己消费消息，获得需要删除的key；</li><li>继续重试删除操作，直到成功。</li></ol><p>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p><h4 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h4><p><img src="2.png" alt="方案2"></p><p>流程如下图所示：</p><ol><li>更新数据库数据；</li><li>数据库会将操作信息写入binlog日志当中；</li><li>订阅程序提取出所需要的数据以及key；</li><li>另起一段非业务代码，获得该信息；</li><li>尝试删除缓存操作，发现删除失败；</li><li>将这些信息发送至消息队列；</li><li>重新从消息队列中获得该数据，重试操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="2020/05/02/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>2020/05/02/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是二分查找？"><a href="#一、什么是二分查找？" class="headerlink" title="一、什么是二分查找？"></a>一、什么是二分查找？</h3><p>二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0。</p><h3 id="二、时间复杂度分析？"><a href="#二、时间复杂度分析？" class="headerlink" title="二、时间复杂度分析？"></a>二、时间复杂度分析？</h3><ol><li>时间复杂度<br>假设数据大小是n，每次查找后数据都会缩小为原来的一半，最坏的情况下，直到查找区间被缩小为空，才停止。所以，每次查找的数据大小是：<code>n，n/2，n/4，…，n/(2^k)，…</code>，这是一个等比数列。当<code>n/(2^k)=1</code>时，k的值就是总共缩小的次数，也是查找的总次数。而每次缩小操作只涉及两个数据的大小比较，所以，经过k次区间缩小操作，时间复杂度就是<code>O(k)</code>。通过<code>n/(2^k)=1</code>，可求得<code>k=log2n</code>，所以时间复杂度是<code>O(logn)</code>。</li><li>认识<code>O(logn)</code><ol><li>这是一种极其高效的时间复杂度，有时甚至比O(1)的算法还要高效。为什么？</li><li>因为logn是一个非常“恐怖“的数量级，即便n非常大，对应的logn也很小。比如n等于2的32次方，也就是42亿，而logn才32。</li><li>由此可见，O(logn)有时就是比O(1000)，O(10000)快很多。</li></ol></li></ol><h3 id="三、如何实现二分查找？"><a href="#三、如何实现二分查找？" class="headerlink" title="三、如何实现二分查找？"></a>三、如何实现二分查找？</h3><h4 id="循环实现"><a href="#循环实现" class="headerlink" title="循环实现"></a>循环实现</h4><p>代码实现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环实现二分查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bsearchLoop</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$array</span>, <span class="keyword">int</span> <span class="variable">$n</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$low</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$high</span> = <span class="variable">$n</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$low</span> &lt;= <span class="variable">$low</span>) &#123;</span><br><span class="line">        <span class="variable">$mid</span> = <span class="variable">$low</span> + ((<span class="variable">$high</span> - <span class="variable">$low</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$array</span>[<span class="variable">$mid</span>] &gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="variable">$high</span> = <span class="variable">$mid</span> - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$array</span>[<span class="variable">$mid</span>] &lt; <span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="variable">$low</span> = <span class="variable">$mid</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$mid</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>循环退出条件是：low&lt;=high，而不是low&lt;high。</li><li>mid的取值，使用mid=low + (high - low) / 2，而不用mid=(low + high)/2，因为如果low和high比较大的话，求和可能会发生int类型的值超出最大范围。为了把性能优化到极致，可以将除以2转换成位运算，即low + ((high - low) &gt;&gt; 1)，因为相比除法运算来说，计算机处理位运算要快得多。</li><li>low和end的更新：low = mid - 1，high = mid + 1，若直接写成low = mid，high=mid，就可能会发生死循环。</li></ol><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现二分查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bsearchRecursion</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$array</span>, <span class="keyword">int</span> <span class="variable">$n</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;bSear(<span class="variable">$array</span>, <span class="variable">$value</span>, <span class="number">0</span>, <span class="variable">$n</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">bSear</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$array</span>, <span class="variable">$value</span>, <span class="keyword">int</span> <span class="variable">$low</span>, <span class="keyword">int</span> <span class="variable">$high</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$low</span> &gt; <span class="variable">$high</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$mid</span> = <span class="variable">$low</span> + ((<span class="variable">$high</span> - <span class="variable">$low</span>) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$array</span>[<span class="variable">$mid</span>] == <span class="variable">$value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$mid</span>;</span><br><span class="line">    &#125; <span class="keyword">elseif</span> (<span class="variable">$array</span>[<span class="variable">$mid</span>] &gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">        <span class="variable">$high</span> = <span class="variable">$mid</span> - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$low</span> = <span class="variable">$mid</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;bSear(<span class="variable">$array</span>, <span class="variable">$value</span>, <span class="variable">$low</span>, <span class="variable">$high</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、使用条件（应用场景的局限性）"><a href="#四、使用条件（应用场景的局限性）" class="headerlink" title="四、使用条件（应用场景的局限性）"></a>四、使用条件（应用场景的局限性）</h3><ol><li>二分查找依赖的是顺序表结构，即数组。</li><li>二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的场景中。</li><li>数据量太小不适合二分查找，与直接遍历相比效率提升不明显。但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是长度超过300的字符串，那这是还是尽量减少比较操作使用二分查找吧。</li><li>数据量太大也不是适合用二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间。</li></ol><h3 id="五、递归变体"><a href="#五、递归变体" class="headerlink" title="五、递归变体"></a>五、递归变体</h3><h4 id="1-查找第一个值等于给定值的元素"><a href="#1-查找第一个值等于给定值的元素" class="headerlink" title="1.查找第一个值等于给定值的元素"></a>1.查找第一个值等于给定值的元素</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变体1. 查找第一个值等于给定值的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bsearch1</span>(<span class="params"><span class="variable">$array</span>, <span class="keyword">int</span> <span class="variable">$n</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$low</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$high</span> = <span class="variable">$n</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$low</span> &lt;= <span class="variable">$high</span>) &#123;</span><br><span class="line">        <span class="variable">$mid</span> = <span class="variable">$low</span> + ((<span class="variable">$high</span> - <span class="variable">$low</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$array</span>[<span class="variable">$mid</span>] &gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="variable">$high</span> = <span class="variable">$mid</span> - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$array</span>[<span class="variable">$mid</span>] &lt; <span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="variable">$low</span> = <span class="variable">$mid</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$mid</span> == <span class="number">0</span> || <span class="variable">$array</span>[<span class="variable">$mid</span> - <span class="number">1</span>] != <span class="variable">$value</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$mid</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$high</span> = <span class="variable">$mid</span> - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-查找最后一个值等于给定值的元素"><a href="#2-查找最后一个值等于给定值的元素" class="headerlink" title="2.查找最后一个值等于给定值的元素"></a>2.查找最后一个值等于给定值的元素</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变体2. 查找最后一个值等于给定值的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bsearch2</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$array</span>, <span class="keyword">int</span> <span class="variable">$n</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$low</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$high</span> = <span class="variable">$n</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$low</span> &lt;= <span class="variable">$high</span>) &#123;</span><br><span class="line">        <span class="variable">$mid</span> = <span class="variable">$low</span> + ((<span class="variable">$high</span> - <span class="variable">$low</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$array</span>[<span class="variable">$mid</span>] &gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="variable">$high</span> = <span class="variable">$mid</span> - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$array</span>[<span class="variable">$mid</span>] &lt; <span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="variable">$low</span> = <span class="variable">$mid</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$mid</span> == <span class="variable">$n</span> - <span class="number">1</span> || <span class="variable">$array</span>[<span class="variable">$mid</span> + <span class="number">1</span>] != <span class="variable">$value</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$mid</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$low</span> = <span class="variable">$mid</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-查找第一个大于等于给定值的元素"><a href="#3-查找第一个大于等于给定值的元素" class="headerlink" title="3.查找第一个大于等于给定值的元素"></a>3.查找第一个大于等于给定值的元素</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变体3. 查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bsearch3</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$array</span>, <span class="keyword">int</span> <span class="variable">$n</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$low</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$high</span> = <span class="variable">$n</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$low</span> &lt;= <span class="variable">$high</span>) &#123;</span><br><span class="line">        <span class="variable">$mid</span> = <span class="variable">$low</span> + ((<span class="variable">$high</span> - <span class="variable">$low</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$array</span>[<span class="variable">$mid</span>] &gt;= <span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$mid</span> == <span class="number">0</span> || <span class="variable">$array</span>[<span class="variable">$mid</span> - <span class="number">1</span>] &lt; <span class="variable">$value</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$mid</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$high</span> = <span class="variable">$mid</span> - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$low</span> = <span class="variable">$mid</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-查找最后一个小于等于给定值的元素"><a href="#4-查找最后一个小于等于给定值的元素" class="headerlink" title="4.查找最后一个小于等于给定值的元素"></a>4.查找最后一个小于等于给定值的元素</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变体4. 查找最后一个小于等于给定值的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bsearch4</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$array</span>, <span class="keyword">int</span> <span class="variable">$n</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$low</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$high</span> = <span class="variable">$n</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$low</span> &lt;= <span class="variable">$high</span>) &#123;</span><br><span class="line">        <span class="variable">$mid</span> = <span class="variable">$low</span> + ((<span class="variable">$high</span> - <span class="variable">$low</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$array</span>[<span class="variable">$mid</span>] &gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="variable">$high</span> = <span class="variable">$mid</span> - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$mid</span> == <span class="variable">$n</span> - <span class="number">1</span> || <span class="variable">$array</span>[<span class="variable">$mid</span> + <span class="number">1</span>] &gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$mid</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$low</span> = <span class="variable">$mid</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、思考"><a href="#六、思考" class="headerlink" title="六、思考"></a>六、思考</h3><ol><li>如何在1000万个整数中快速查找某个整数？<ol><li>1000万个整数占用存储空间为40MB，占用空间不大，所以可以全部加载到内存中进行处理；</li><li>用一个1000万个元素的数组存储，然后使用快排进行升序排序，时间复杂度为O(nlogn)</li><li>在有序数组中使用二分查找算法进行查找，时间复杂度为O(logn)</li></ol></li><li>如何编程实现“求一个数的平方根”？要求精确到小数点后6位？</li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树遍历-php实现</title>
      <link href="2020/04/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86-php%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/04/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86-php%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>经典的方法有三种，前序遍历、中序遍历和后序遍历。<br>其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。</p><ul><li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li><li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</li><li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</li></ul><p><img src="ergodic.jpg" alt="ergodic"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="定义一个树节点类"><a href="#定义一个树节点类" class="headerlink" title="定义一个树节点类"></a>定义一个树节点类</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点中的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> null </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$data</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> null </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$left</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> null </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$right</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TreeNode constructor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> null $data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$data</span> = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;data = <span class="variable">$data</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;left = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="再定义个树类"><a href="#再定义个树类" class="headerlink" title="再定义个树类"></a>再定义个树类</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> [type]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$head</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tree constructor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> null $headData</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$headData</span> = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$headData</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;head = <span class="keyword">new</span> TreeNode(<span class="variable">$headData</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$node</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;data == <span class="variable">$data</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$node</span>;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (<span class="variable">$data</span> &gt; <span class="variable">$node</span>-&gt;data) &#123;</span><br><span class="line">                <span class="variable">$node</span> = <span class="variable">$node</span>-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$node</span> = <span class="variable">$node</span>-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;head = <span class="keyword">new</span> TreeNode(<span class="variable">$data</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$node</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$data</span> &gt; <span class="variable">$node</span>-&gt;data) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="variable">$node</span>-&gt;right = <span class="keyword">new</span> TreeNode(<span class="variable">$data</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable">$node</span> = <span class="variable">$node</span>-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;left == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="variable">$node</span>-&gt;left = <span class="keyword">new</span> TreeNode(<span class="variable">$data</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable">$node</span> = <span class="variable">$node</span>-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delete</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 找到需要删除节点</span></span><br><span class="line">        <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line">        <span class="variable">$pnode</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$node</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;data == <span class="variable">$data</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (<span class="variable">$data</span> &gt; <span class="variable">$node</span>-&gt;data) &#123;</span><br><span class="line">                <span class="variable">$pnode</span> = <span class="variable">$node</span>;</span><br><span class="line">                <span class="variable">$node</span> = <span class="variable">$node</span>-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$pnode</span> = <span class="variable">$node</span>;</span><br><span class="line">                <span class="variable">$node</span> = <span class="variable">$node</span>-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$node</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">        <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;left != <span class="literal">null</span> &amp;&amp; <span class="variable">$node</span>-&gt;right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$minPP</span> = <span class="variable">$node</span>;</span><br><span class="line">            <span class="variable">$minP</span> = <span class="variable">$node</span>-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable">$minP</span>-&gt;left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="variable">$minPP</span> = <span class="variable">$minP</span>;</span><br><span class="line">                <span class="variable">$minP</span> = <span class="variable">$minP</span>-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$node</span>-&gt;data = <span class="variable">$minP</span>-&gt;data;</span><br><span class="line">            <span class="variable">$node</span> = <span class="variable">$minP</span>;</span><br><span class="line">            <span class="comment">// 删除掉右子树中的最小节点</span></span><br><span class="line">            <span class="variable">$minPP</span>-&gt;left = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$child</span> = <span class="variable">$node</span>-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$node</span>-&gt;right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$child</span> = <span class="variable">$node</span>-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$child</span> = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$pnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 删除的是根节点</span></span><br><span class="line">            <span class="variable">$node</span> = <span class="variable">$child</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$pnode</span>-&gt;left == <span class="variable">$node</span>) &#123;</span><br><span class="line">            <span class="variable">$pnode</span>-&gt;left = <span class="variable">$child</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$pnode</span>-&gt;right = <span class="variable">$child</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">preOrder</span>(<span class="params"><span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$node</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$node</span>-&gt;data . <span class="string">&#x27;-&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;preOrder(<span class="variable">$node</span>-&gt;left);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;preOrder(<span class="variable">$node</span>-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">inOrder</span>(<span class="params"><span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$node</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;inOrder(<span class="variable">$node</span>-&gt;left);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$node</span>-&gt;data . <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;inOrder(<span class="variable">$node</span>-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $node</span></span><br><span class="line"><span class="comment">     * 后续遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">postOrder</span>(<span class="params"><span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$node</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;postOrder(<span class="variable">$node</span>-&gt;left);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;postOrder(<span class="variable">$node</span>-&gt;right);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$node</span>-&gt;data . <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 层级遍历</span></span><br><span class="line"><span class="comment">     * 首先把节点放入数组，记录放入数组的根节点个数index，把节点的左右子放入数组</span></span><br><span class="line"><span class="comment">     * 开始遍历数组queue(从index开始,子节点已经入队列的节点元素不再处理)，把左右子节点放入queue,index++</span></span><br><span class="line"><span class="comment">     * 持续上述过程，当节点没有子节点时，入队列过程结束，queue里节点的顺序即为层级遍历元素节点的顺序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $index 从队列(数组)的那个位置开始处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span>(<span class="params"><span class="variable">$queue</span>, <span class="variable">$index</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="variable">$index</span>; <span class="variable">$i</span> &lt; count(<span class="variable">$queue</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$node</span> = <span class="variable">$queue</span>[<span class="variable">$i</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;left) &#123;</span><br><span class="line">                <span class="variable">$queue</span>[] = <span class="variable">$node</span>-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$queue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;right) &#123;</span><br><span class="line">                <span class="variable">$queue</span>[] = <span class="variable">$node</span>-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$queue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$index</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$queue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳表</title>
      <link href="2020/04/08/%E8%B7%B3%E8%A1%A8/"/>
      <url>2020/04/08/%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是跳表？"><a href="#一、什么是跳表？" class="headerlink" title="一、什么是跳表？"></a>一、什么是跳表？</h3><p>为一个值有序的链表建立多级索引，比如每2个节点提取一个节点到上一级，我们把抽出来的那一级叫做索引或索引层。如下图所示，其中down表示down指针，指向下一级节点。以此类推，对于节点数为n的链表，大约可以建立log2n-1级索引。像这种为链表建立多级索引的数据结构就称为跳表。</p><h3 id="二、跳表的时间复杂度？"><a href="#二、跳表的时间复杂度？" class="headerlink" title="二、跳表的时间复杂度？"></a>二、跳表的时间复杂度？</h3><ol><li>计算跳表的高度<br>如果链表有n个节点，每2个节点抽取抽出一个节点作为上一级索引的节点，那第1级索引的节点个数大约是n/2，第2级索引的节点个数大约是n/4，依次类推，第k级索引的节点个数就是n/(2^k)。假设索引有h级别，最高级的索引有2个节点，则有n/(2^h)=2，得出h=log2n-1，包含原始链表这一层，整个跳表的高度就是log2n。</li><li>计算跳表的时间复杂度<br>假设我们在跳表中查询某个数据的时候，如果每一层都遍历m个节点，那在跳表中查询一个数据的时间复杂度就是O(m*logn)。那这个m是多少呢？如下图所示，假设我们要查找的数据是x，在第k级索引中，我们遍历到y节点之后，发现x大于y，小于后面的节点z，所以我们通过y的down指针，从第k级下降到第k-1级索引。在第k-1级索引中，y和z之间只有3个节点（包含y和z），所以，我们在k-1级索引中最多只需要遍历3个节点，以此类推，每一级索引都最多只需要遍历3个节点。所以m=3。因此在跳表中查询某个数据的时间复杂度就是O(logn)。</li></ol><h3 id="三、跳表的空间复杂度及如何优化？"><a href="#三、跳表的空间复杂度及如何优化？" class="headerlink" title="三、跳表的空间复杂度及如何优化？"></a>三、跳表的空间复杂度及如何优化？</h3><ol><li>计算索引的节点总数<br>如果链表有n个节点，每2个节点抽取抽出一个节点作为上一级索引的节点，那每一级索引的节点数分别为：n/2，n/4，n/8，…，8，4，2，等比数列求和n-1，所以跳表的空间复杂度为O(n)。</li><li>如何优化时间复杂度<br>如果链表有n个节点，每3或5个节点抽取抽出一个节点作为上一级索引的节点，那每一级索引的节点数分别为（以3为例）：n/3，n/9，n/27，…，27，9，3，1，等比数列求和n/2，所以跳表的空间复杂度为O(n)，和每2个节点抽取一次相比，时间复杂度要低不少呢。</li></ol><h3 id="四、高效的动态插入和删除？"><a href="#四、高效的动态插入和删除？" class="headerlink" title="四、高效的动态插入和删除？"></a>四、高效的动态插入和删除？</h3><p>跳表本质上就是链表，所以仅插作，插入和删除操时间复杂度就为O(1)，但在实际情况中，要插入或删除某个节点，需要先查找到指定位置，而这个查找操作比较费时，但在跳表中这个查找操作的时间复杂度是O(logn)，所以，跳表的插入和删除操作的是时间复杂度也是O(logn)。</p><h3 id="五、跳表索引动态更新？"><a href="#五、跳表索引动态更新？" class="headerlink" title="五、跳表索引动态更新？"></a>五、跳表索引动态更新？</h3><p>当往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中，那么如何选择这个索引层呢？可以通过随机函数来决定将这个节点插入到哪几级索引中，比如随机函数生成了值K，那就可以把这个节点添加到第1级到第K级索引中。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之cp</title>
      <link href="2020/03/30/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bcp/"/>
      <url>2020/03/30/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bcp/</url>
      
        <content type="html"><![CDATA[<h3 id="关于-–"><a href="#关于-–" class="headerlink" title="关于 –"></a>关于 –</h3><p>今天有个同事问我，shall编程里的 <code>cp -rf --</code> 中的<code>--</code>的作用是什么，不知道啊，略尴尬，就查查学习学习</p><p><code>--</code> 主要是为了解决<code>cp</code>特殊字符文件名的情况，例如 文件名是<code>-aaa.txt</code>，进行<code>cp</code>时，<code>cp -aaa.txt</code>会报错。shell 把破折号(-)之后的内容认作参数了，而很明显没有这样的参数，所以报错 这时候使用 <code>cp -- -aaa.txt</code> 即可</p><ol><li>针对<code>-</code>开头的文件需要使用<code>--</code>来告知bash，不要将这里的<code>-</code>解释为参数</li><li>针对其它特殊字符，使用<code>&#39;</code>单引号把文件名括起来</li><li>针对文件名还包含<code>&#39;</code>或者<code>&quot;</code>的情况，就需要交替使用规则</li></ol><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [options] source dest</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [options] source... directory</span><br></pre></td></tr></table></figure><p> 选项:</p><ul><li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合</li><li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li><li>-f：覆盖已经存在的目标文件而不给出提示。</li><li>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。</li><li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li><li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li><li>-l：不复制文件，只是生成链接文件</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用指令”cp”将当前目录”test/“下的所有文件复制到新目录”newtest”下，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp –r test&#x2F; newtest</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>homebrew换源</title>
      <link href="2020/03/30/homebrew%E6%8D%A2%E6%BA%90/"/>
      <url>2020/03/30/homebrew%E6%8D%A2%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>国内使用默认brew源过慢，经常导致失败，查了一下换中科大的源，亲测很快，备份下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;brew.git</span><br><span class="line">cd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-core.git</span><br><span class="line">cd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-cask&quot;</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-cask.git</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MAC使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MAC使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel 服务容器实例教程--深入理解控制反转（IoC）和依赖注入（DI）</title>
      <link href="2020/03/27/Laravel-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%E6%95%99%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88IoC%EF%BC%89%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89/"/>
      <url>2020/03/27/Laravel-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%E6%95%99%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88IoC%EF%BC%89%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>容器，字面上理解就是装东西的东西。常见的变量、对象属性等都可以算是容器。一个容器能够装什么，全部取决于你对该容器的定义。当然，有这样一种容器，它存放的不是文本、数值，而是对象、对象的描述（类、接口）或者是提供对象的回调，通过这种容器，我们得以实现许多高级的功能，其中最常提到的，就是 “解耦” 、“依赖注入（DI）”。本文就从这里开始。</p><h3 id="IoC-容器-——-Laravel-的核心"><a href="#IoC-容器-——-Laravel-的核心" class="headerlink" title="IoC 容器 —— Laravel 的核心"></a>IoC 容器 —— Laravel 的核心</h3><p>Laravel 的核心就是一个 IoC 容器，根据文档，称其为“服务容器”，顾名思义，该容器提供了整个框架中需要的一系列服务。作为初学者，很多人会在这一个概念上犯难，因此，我打算从一些基础的内容开始讲解，通过理解面向对象开发中依赖的产生和解决方法，来逐渐揭开“依赖注入”的面纱，逐渐理解这一神奇的设计理念。</p><p>本文一大半内容都是通过举例来让读者去理解什么是 IoC（控制反转） 和 DI（依赖注入），通过理解这些概念，来更加深入。更多关于 laravel 服务容器的用法建议阅读<a href="https://xueyuanjun.com/post/93.html">文档</a>即可。</p><h3 id="IoC-容器诞生的故事"><a href="#IoC-容器诞生的故事" class="headerlink" title="IoC 容器诞生的故事"></a>IoC 容器诞生的故事</h3><p>讲解 IoC 容器有很多的文章，我之前也写过。但现在我打算利用当下的灵感重新来过，那么开始吧</p><h4 id="超人和超能力，依赖的产生"><a href="#超人和超能力，依赖的产生" class="headerlink" title="超人和超能力，依赖的产生"></a>超人和超能力，依赖的产生</h4><p>面向对象编程，有以下几样东西无时不刻的接触：接口、类还有对象。这其中，<strong>接口是类的原型，一个类必须要遵守其实现的接口；对象则是一个类实例化后的产物，我们称其为一个实例</strong>。当然这样说肯定不利于理解，我们就实际的写点中看不中用的代码辅助学习</p><blockquote><p>怪物横行的世界，总归需要点超级人物来摆平。</p></blockquote><p>我们把一个“超人”作为一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Superman &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们可以想象，一个超人诞生的时候肯定拥有至少一个超能力，这个超能力也可以抽象为一个对象，为这个对象定义一个描述他的类吧。一个超能力肯定有多种属性、（操作）方法，这个尽情的想象，但是目前我们先大致定义一个只有属性的“超能力”，至于能干啥，我们以后再丰富：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Power &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 能力值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected $ability;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 能力范围或距离</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected $range;</span><br><span class="line"></span><br><span class="line">    public function __construct($ability, $range)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;ability &#x3D; $ability;</span><br><span class="line">        $this-&gt;range &#x3D; $range;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们回过头，修改一下之前的“超人”类，让一个“超人”创建的时候被赋予一个超能力：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Superman</span><br><span class="line">&#123;</span><br><span class="line">    protected $power;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;power &#x3D; new Power(999, 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，当我们创建一个“超人”实例的时候，同时也创建了一个“超能力”的实例，但是，我们看到了一点，“超人”和“超能力”之间不可避免的产生了一个依赖。</p><p>所谓“依赖”，就是 “我若依赖你，我就不能离开你”。</p><p>在一个贯彻面向对象编程的项目中，这样的依赖随处可见。少量的依赖并不会有太过直观的影响，我们随着这个例子逐渐铺开，让大家慢慢意识到，当依赖达到一个量级时，是怎样一番噩梦般的体验。当然，我也会自然而然的讲述如何解决问题。</p><h4 id="一堆乱麻-——-可怕的依赖"><a href="#一堆乱麻-——-可怕的依赖" class="headerlink" title="一堆乱麻 —— 可怕的依赖"></a>一堆乱麻 —— 可怕的依赖</h4><p>之前的例子中，超能力类实例化后是一个具体的超能力，但是我们知道，超人的超能力是多元化的，每种超能力的方法、属性都有不小的差异，没法通过一种类描述完全。我们现在进行修改，我们假设超人可以有以下多种超能力：</p><ul><li>飞行，属性有：飞行速度、持续飞行时间</li><li>蛮力，属性有：力量值</li><li>能量弹，属性有：伤害值、射击距离、同时射击个数</li></ul><p>我们创建了如下类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Flight</span><br><span class="line">&#123;</span><br><span class="line">    protected $speed;</span><br><span class="line">    protected $holdtime;</span><br><span class="line">    public function __construct($speed, $holdtime) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Force</span><br><span class="line">&#123;</span><br><span class="line">    protected $force;</span><br><span class="line">    public function __construct($force) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shot</span><br><span class="line">&#123;</span><br><span class="line">    protected $atk;</span><br><span class="line">    protected $range;</span><br><span class="line">    protected $limit;</span><br><span class="line">    public function __construct($atk, $range, $limit) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了省事儿我没有详细写出 <code>__construct()</code> 这个构造函数的全部，只写了需要传递的参数。</p><p>好了，这下我们的超人有点“忙”了。在超人初始化的时候，我们会根据需要来实例化其拥有的超能力吗，大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Superman</span><br><span class="line">&#123;</span><br><span class="line">    protected $power;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;power &#x3D; new Fight(9, 100);</span><br><span class="line">        &#x2F;&#x2F; $this-&gt;power &#x3D; new Force(45);</span><br><span class="line">        &#x2F;&#x2F; $this-&gt;power &#x3D; new Shot(99, 50, 2);</span><br><span class="line">        &#x2F;*</span><br><span class="line">        $this-&gt;power &#x3D; array(</span><br><span class="line">            new Force(45),</span><br><span class="line">            new Shot(99, 50, 2)</span><br><span class="line">        );</span><br><span class="line">        *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要自己手动的在构造函数内（或者其他方法里）实例化一系列需要的类，这样并不好。可以想象，假如需求变更（不同的怪物横行地球），需要更多的有针对性的新的超能力，或者需要变更超能力的方法，我们必须 重新改造 超人。换句话说就是，改变超能力的同时，我还得重新制造个超人。效率太低了！新超人还没创造完成世界早已被毁灭。</p><p>这时，灵机一动的人想到：为什么不可以这样呢？超人的能力可以被随时更换，只需要添加或者更新一个芯片或者其他装置啥的（想到钢铁侠没）。这样的话就不要整个重新来过了。</p><p>对，就是这样的。</p><p>我们不应该手动在 “超人” 类中固化了他的 “超能力” 初始化的行为，而转由外部负责，由外部创造超能力模组、装置或者芯片等（我们后面统一称为 “模组”），植入超人体内的某一个接口，这个接口是一个既定的，只要这个 “模组” 满足这个接口的装置都可以被超人所利用，可以提升、增加超人的某一种能力。<strong>这种由外部负责其依赖需求的行为，我们可以称其为 “控制反转（IoC）”</strong>。</p><h4 id="工厂模式，依赖转移"><a href="#工厂模式，依赖转移" class="headerlink" title="工厂模式，依赖转移"></a>工厂模式，依赖转移</h4><p>当然，实现控制反转的方法有几种。在这之前，不如我们先了解一些好玩的东西。</p><blockquote><p>我们可以想到，组件、工具（或者超人的模组），是一种可被生产的玩意儿，生产的地方当然是 “工厂（Factory）”，于是有人就提出了这样一种模式： 工厂模式</p></blockquote><p>工厂模式，顾名思义，就是一个类所依赖的外部事物的实例，都可以被一个或多个 “工厂” 创建的这样一种开发模式，就是 “工厂模式”。</p><p>我们为了给超人制造超能力模组，我们创建了一个工厂，它可以制造各种各样的模组，且仅需要通过一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class SuperModuleFactory</span><br><span class="line">&#123;</span><br><span class="line">    public function makeModule($moduleName, $options)</span><br><span class="line">    &#123;</span><br><span class="line">        switch ($moduleName) &#123;</span><br><span class="line">            case &#39;Fight&#39;: </span><br><span class="line">                return new Fight($options[0], $options[1]);</span><br><span class="line">            case &#39;Force&#39;: </span><br><span class="line">                return new Force($options[0]);</span><br><span class="line">            case &#39;Shot&#39;: </span><br><span class="line">                return new Shot($options[0], $options[1], $options[2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，超人 创建之初就可以使用这个工厂！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Superman</span><br><span class="line">&#123;</span><br><span class="line">    protected $power;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化工厂</span><br><span class="line">        $factory &#x3D; new SuperModuleFactory;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过工厂提供的方法制造需要的模块</span><br><span class="line">        $this-&gt;power &#x3D; $factory-&gt;makeModule(&#39;Fight&#39;, [9, 100]);</span><br><span class="line">        &#x2F;&#x2F; $this-&gt;power &#x3D; $factory-&gt;makeModule(&#39;Force&#39;, [45]);</span><br><span class="line">        &#x2F;&#x2F; $this-&gt;power &#x3D; $factory-&gt;makeModule(&#39;Shot&#39;, [99, 50, 2]);</span><br><span class="line">        &#x2F;*</span><br><span class="line">        $this-&gt;power &#x3D; array(</span><br><span class="line">            $factory-&gt;makeModule(&#39;Force&#39;, [45]),</span><br><span class="line">            $factory-&gt;makeModule(&#39;Shot&#39;, [99, 50, 2])</span><br><span class="line">        );</span><br><span class="line">        *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看得出，我们不再需要在超人初始化之初，去初始化许多第三方类，只需初始化一个工厂类，即可满足需求。但这样似乎和以前区别不大，只是没有那么多 new 关键字。其实我们稍微改造一下这个类，你就明白，工厂类的真正意义和价值了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Superman</span><br><span class="line">&#123;</span><br><span class="line">    protected $power;</span><br><span class="line"></span><br><span class="line">    public function __construct(array $modules)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化工厂</span><br><span class="line">        $factory &#x3D; new SuperModuleFactory;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过工厂提供的方法制造需要的模块</span><br><span class="line">        foreach ($modules as $moduleName &#x3D;&gt; $moduleOptions) &#123;</span><br><span class="line">            $this-&gt;power[] &#x3D; $factory-&gt;makeModule($moduleName, $moduleOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建超人</span><br><span class="line">$superman &#x3D; new Superman([</span><br><span class="line">    &#39;Fight&#39; &#x3D;&gt; [9, 100],</span><br><span class="line">    &#39;Shot&#39; &#x3D;&gt; [99, 50, 2]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>现在修改的结果令人满意。现在，“超人” 的创建不再依赖任何一个 “超能力” 的类，我们如若修改了或者增加了新的超能力，只需要针对修改 SuperModuleFactory 即可。扩充超能力的同时不再需要重新编辑超人的类文件，使得我们变得很轻松。但是，这才刚刚开始。</p><h4 id="IoC-容器的重要组成-——-依赖注入"><a href="#IoC-容器的重要组成-——-依赖注入" class="headerlink" title="IoC 容器的重要组成 —— 依赖注入"></a>IoC 容器的重要组成 —— 依赖注入</h4><p>由 “超人” 对 “超能力” 的依赖变成 “超人” 对 “超能力模组工厂” 的依赖后，对付小怪兽们变得更加得心应手。但这也正如你所看到的，依赖并未解除，只是由原来对多个外部的依赖变成了对一个 “工厂” 的依赖。假如工厂出了点麻烦，问题变得就很棘手。</p><blockquote><p>其实大多数情况下，工厂模式已经足够了。工厂模式的缺点就是：接口未知（即没有一个很好的契约模型，关于这个我马上会有解释）、产生对象类型单一。总之就是，还是不够灵活。虽然如此，工厂模式依旧十分优秀，并且适用于绝大多数情况。不过我们为了讲解后面的依赖注入 ，这里就先夸大一下工厂模式的缺陷咯。</p></blockquote><p>我们知道，超人依赖的模组，我们要求有统一的接口，这样才能和超人身上的注入接口对接，最终起到提升超能力的效果。</p><p>事实上，我之前说谎了，不仅仅只有一堆小怪兽，还有更多的大怪兽。嘿嘿。额，这时候似乎工厂的生产能力显得有些不足 —— 由于工厂模式下，所有的模组都已经在工厂类中安排好了，如果有新的、高级的模组加入，我们必须修改工厂类（好比增加新的生产线）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class SuperModuleFactory</span><br><span class="line">&#123;</span><br><span class="line">    public function makeModule($moduleName, $options)</span><br><span class="line">    &#123;</span><br><span class="line">        switch ($moduleName) &#123;</span><br><span class="line">            case &#39;Fight&#39;: </span><br><span class="line">                return new Fight($options[0], $options[1]);</span><br><span class="line">            case &#39;Force&#39;: </span><br><span class="line">                return new Force($options[0]);</span><br><span class="line">            case &#39;Shot&#39;: </span><br><span class="line">                return new Shot($options[0], $options[1], $options[2]);</span><br><span class="line">            &#x2F;&#x2F; case &#39;more&#39;: .......</span><br><span class="line">            &#x2F;&#x2F; case &#39;and more&#39;: .......</span><br><span class="line">            &#x2F;&#x2F; case &#39;and more&#39;: .......</span><br><span class="line">            &#x2F;&#x2F; case &#39;oh no! its too many!&#39;: .......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没。。。噩梦般的感受！</p><blockquote><p>其实灵感就差一步！你可能会想到更为灵活的办法！对，下一步就是我们今天的主要配角 —— DI （依赖注入）</p></blockquote><p>由于对超能力模组的需求不断增大，我们需要集合整个世界的高智商人才，一起解决问题，不应该仅仅只有几个工厂垄断负责。不过高智商人才们都非常自负，认为自己的想法是对的，创造出的超能力模组没有统一的接口，自然而然无法被正常使用。这时我们需要提出一种契约，这样无论是谁创造出的模组，都符合这样的接口，自然就可被正常使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface SuperModuleInterface</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 超能力激活方法</span><br><span class="line">     *</span><br><span class="line">     * 任何一个超能力都得有该方法，并拥有一个参数</span><br><span class="line">     *@param array $target 针对目标，可以是一个或多个，自己或他人</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function activate(array $target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文中，我们定下了一个接口 （超能力模组的规范、契约），所有被创造的模组必须遵守该规范，才能被生产。</p><p>其实，这就是 php 中接口（ interface ）的用处和意义！很多人觉得，为什么 php 需要接口这种东西？难道不是 java 、 C# 之类的语言才有的吗？这么说，只要是一个正常的面向对象编程语言（虽然 php 可以面向过程），都应该具备这一特性。因为一个 对象（object） 本身是由他的模板或者原型 —— 类 （class） ，经过实例化后产生的一个具体事物，而有时候，实现统一种方法且不同功能（或特性）的时候，会存在很多的类（class），这时候就需要有一个契约，让大家编写出可以被随时替换却不会产生影响的接口。这种由编程语言本身提出的硬性规范，会增加更多优秀的特性。</p><p>虽然有些绕，但通过我们接下来的实例，大家会慢慢领会接口带来的好处。</p><p>这时候，那些提出更好的超能力模组的高智商人才，遵循这个接口，创建了下述（模组）类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * X-超能量</span><br><span class="line"> *&#x2F;</span><br><span class="line">class XPower implements SuperModuleInterface</span><br><span class="line">&#123;</span><br><span class="line">    public function activate(array $target)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 这只是个例子。。具体自行脑补</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 终极炸弹 （就这么俗）</span><br><span class="line"> *&#x2F;</span><br><span class="line">class UltraBomb implements SuperModuleInterface</span><br><span class="line">&#123;</span><br><span class="line">    public function activate(array $target)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 这只是个例子。。具体自行脑补</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，为了防止有些 “砖家” 自作聪明，或者一些叛徒恶意捣蛋，不遵守契约胡乱制造模组，影响超人，我们对超人初始化的方法进行改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Superman</span><br><span class="line">&#123;</span><br><span class="line">    protected $module;</span><br><span class="line"></span><br><span class="line">    public function __construct(SuperModuleInterface $module)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;module &#x3D; $module;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造完毕！现在，当我们初始化 “超人” 类的时候，提供的模组实例必须是一个 <code>SuperModuleInterface</code> 接口的实现。否则就会提示错误。</p><p>正是由于超人的创造变得容易，一个超人也就不需要太多的超能力，我们可以创造多个超人，并分别注入需要的超能力模组即可。这样的话，虽然一个超人只有一个超能力，但超人更容易变多，我们也不怕怪兽啦！</p><p>现在有人疑惑了，你要讲的依赖注入呢？</p><p>其实，上面讲的内容，正是依赖注入。</p><h4 id="什么叫做依赖注入？"><a href="#什么叫做依赖注入？" class="headerlink" title="什么叫做依赖注入？"></a>什么叫做依赖注入？</h4><p>本文从开头到现在提到的一系列依赖，<strong>只要不是由内部生产（比如初始化、构造函数 __construct 中通过工厂方法、自行手动 new 的），而是由外部以参数或其他形式注入的，都属于依赖注入（DI）</strong> 。是不是豁然开朗？事实上，就是这么简单。下面就是一个典型的依赖注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 超能力模组</span><br><span class="line">$superModule &#x3D; new XPower;</span><br><span class="line">&#x2F;&#x2F; 初始化一个超人，并注入一个超能力模组依赖</span><br><span class="line">$superMan &#x3D; new Superman($superModule);</span><br></pre></td></tr></table></figure><p>关于依赖注入这个本文的主要配角，也就这么多需要讲的。理解了依赖注入，我们就可以继续深入问题。慢慢走近今天的主角……</p><h4 id="更为先进的工厂-——-IoC-容器"><a href="#更为先进的工厂-——-IoC-容器" class="headerlink" title="更为先进的工厂 —— IoC 容器"></a>更为先进的工厂 —— IoC 容器</h4><p>刚刚列了一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$superModule &#x3D; new XPower;</span><br><span class="line">$superMan &#x3D; new Superman($superModule);</span><br></pre></td></tr></table></figure><p>读者应该看出来了，手动的创建了一个超能力模组、手动的创建超人并注入了刚刚创建超能力模组。呵呵，手动。</p><blockquote><p>现代社会，应该是高效率的生产，干净的车间，完美的自动化装配。</p></blockquote><p>一群怪兽来了，如此低效率产出超人是不现实，我们需要自动化 —— 最多一条指令，千军万马来相见。我们需要一种高级的生产车间，我们只需要向生产车间提交一个脚本，工厂便能够通过指令自动化生产。这种更为高级的工厂，就是工厂模式的升华 —— IoC 容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Container</span><br><span class="line">&#123;</span><br><span class="line">    protected $binds;</span><br><span class="line"></span><br><span class="line">    protected $instances;</span><br><span class="line"></span><br><span class="line">    public function bind($abstract, $concrete)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($concrete instanceof Closure) &#123;</span><br><span class="line">            $this-&gt;binds[$abstract] &#x3D; $concrete;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;instances[$abstract] &#x3D; $concrete;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function make($abstract, $parameters &#x3D; [])</span><br><span class="line">    &#123;</span><br><span class="line">        if (isset($this-&gt;instances[$abstract])) &#123;</span><br><span class="line">            return $this-&gt;instances[$abstract];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        array_unshift($parameters, $this);</span><br><span class="line"></span><br><span class="line">        return call_user_func_array($this-&gt;binds[$abstract], $parameters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，一个十分粗糙的容器就诞生了。现在的确很简陋，但不妨碍我们进一步提升他。先着眼现在，看看这个容器如何使用吧！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个容器（后面称作超级工厂）</span><br><span class="line">$container &#x3D; new Container;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向该 超级工厂添加超人的生产脚本</span><br><span class="line">$container-&gt;bind(&#39;superman&#39;, function($container, $moduleName) &#123;</span><br><span class="line">    return new Superman($container-&gt;make($moduleName));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向该 超级工厂添加超能力模组的生产脚本</span><br><span class="line">$container-&gt;bind(&#39;xpower&#39;, function($container) &#123;</span><br><span class="line">    return new XPower;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同上</span><br><span class="line">$container-&gt;bind(&#39;ultrabomb&#39;, function($container) &#123;</span><br><span class="line">    return new UltraBomb;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ****************** 华丽丽的分割线 **********************</span><br><span class="line">&#x2F;&#x2F; 开始启动生产</span><br><span class="line">$superman_1 &#x3D; $container-&gt;make(&#39;superman&#39;, &#39;xpower&#39;);</span><br><span class="line">$superman_2 &#x3D; $container-&gt;make(&#39;superman&#39;, &#39;ultrabomb&#39;);</span><br><span class="line">$superman_3 &#x3D; $container-&gt;make(&#39;superman&#39;, &#39;xpower&#39;);</span><br><span class="line">&#x2F;&#x2F; ...随意添加</span><br></pre></td></tr></table></figure><p>看到没？通过最初的 绑定（<code>bind</code>） 操作，我们向 超级工厂 注册了一些生产脚本，这些生产脚本在生产指令下达之时便会执行。发现没有？我们彻底的解除了 超人 与 超能力模组 的依赖关系，更重要的是，容器类也丝毫没有和他们产生任何依赖！我们通过注册、绑定的方式向容器中添加一段可以被执行的回调（可以是匿名函数、非匿名函数、类的方法）作为生产一个类的实例的 脚本 ，只有在真正的 生产（<code>make</code>） 操作被调用执行时，才会触发。</p><p>这样一种方式，使得我们更容易在创建一个实例的同时解决其依赖关系，并且更加灵活。当有新的需求，只需另外绑定一个“生产脚本”即可。</p><p>实际上，真正的 <code>IoC 容器</code>更为高级。我们现在的例子中，还是需要手动提供超人所需要的模组参数，但真正的 <code>IoC 容器</code>会根据类的依赖需求，自动在注册、绑定的一堆实例中搜寻符合的依赖需求，并自动注入到构造函数参数中去。Laravel 框架的服务容器正是这么做的。实现这种功能其实理论上并不麻烦，但我并不会在本文中写出，因为……我懒得写。</p><p>不过我告诉大家，这种自动搜寻依赖需求的功能，是通过反射（Reflection）实现的，恰好的，php 完美的支持反射机制！关于反射，php 官方文档有详细的资料，并且中文翻译基本覆盖，足够学习和研究：<a href="http://php.net/manual/zh/book.reflection.php">反射文档</a></p><p>现在，到目前为止，我们已经不再惧怕怪兽们了。高智商人才集思广益，井井有条，根据接口契约创造规范的超能力模组。超人开始批量产出。最终，人人都是超人，你也可以是哦！</p><h3 id="重新审视-Laravel-的核心"><a href="#重新审视-Laravel-的核心" class="headerlink" title="重新审视 Laravel 的核心"></a>重新审视 Laravel 的核心</h3><p>现在，我们开始慢慢解读 Laravel 的核心。其实，Laravel 的核心就是一个 IoC 容器，也恰好是我之前所说的高级的 IoC 容器。</p><p>可以说，Laravel 的核心本身十分轻量，并没有什么很神奇很实质性的应用功能。很多人用到的各种功能模块比如 Route（路由）、Eloquent ORM（数据库 ORM 组件）、Request（请求）以及 Response（响应）等等等等，实际上都是与核心无关的类模块提供的，这些类从注册到实例化，最终被你所使用，其实都是 Laravel 的服务容器负责的。</p><p>我们以大家最常见的 Route 类作为例子。大家可能经常见到路由定义是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&#39;&#x2F;&#39;, function() &#123;</span><br><span class="line">    &#x2F;&#x2F; bla bla bla...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实际上， Route 类被定义在这个命名空间：<code>Illuminate\Routing\Router</code>，文件 <code>vendor/laravel/framework/src/Illuminate/Routing/Router.php</code></p><p>我们通过打开发现，这个类的这一系列方法，如 <code>get</code>，<code>post</code>，<code>any</code> 等都不是静态（<code>static</code>）方法，这是怎么一回事儿？不要急，我们继续。</p><h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><p> 我们在前文介绍 <code>IoC 容器</code>的部分中，提到了，一个类需要绑定、注册至容器中，才能被“制造”。</p><p>对，一个类要被容器所能够提取，必须要先注册至这个容器。既然 Laravel 称这个容器叫做服务容器，那么我们需要某个服务，就得先注册、绑定这个服务到容器，那么提供服务并绑定服务至容器的东西，就是服务提供者（<code>Service Provider</code>）。</p><p>虽然，绑定一个类到容器不一定非要通过服务提供者。</p><p>但是，我们知道，有时候我们的类、模块会有需要其他类和组件的情况，为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况，Laravel 将注册和初始化行为进行拆分，注册的时候就只能注册，初始化的时候就是初始化。拆分后的产物就是现在的服务提供者。</p><p>服务提供者主要分为两个部分，<code>register</code>（注册） 和 <code>boot</code>（引导、初始化），具体参考文档。<code>register</code> 负责进行向容器注册“脚本”，但要注意注册部分不要有对未知事物的依赖，如果有，就要移步至 <code>boot</code> 部分。</p><h4 id="门面（Facade）"><a href="#门面（Facade）" class="headerlink" title="门面（Facade）"></a>门面（Facade）</h4><p>我们现在解答之前关于 Route 的方法为何能以静态方法访问的问题。实际上这个问题文档上有写，简单说来就是模拟一个类，提供一个静态魔术方法<code>__callStatic</code>，并将该静态方法映射到真正的方法上。</p><p>我们使用的 Route 类实际上是 <code>Illuminate\Support\Facades\Route</code> 通过 <code>class_alias()</code> 函数创造的别名而已，这个类被定义在文件 <code>vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php</code> 。</p><p>我们打开文件一看……诶？怎么只有这么简单的一段代码呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">namespace Illuminate\Support\Facades;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @see \Illuminate\Routing\Router</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Route extends Facade</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Get the registered name of the component.</span><br><span class="line">     *</span><br><span class="line">     * @return string</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected static function getFacadeAccessor()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#39;router&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实仔细看，会发现这个类继承了一个叫做 <code>Facade</code> 的类，到这里谜底差不多要解开了。</p><p>上述简单的定义中，我们看到了 <code>getFacadeAccessor</code> 方法返回了一个 <code>route</code>，这是什么意思呢？事实上，这个值被一个 <code>ServiceProvider</code> 注册过，大家应该知道注册了个什么，当然是那个真正的路由类！</p><p>有人会问，<code>Facade</code> 是怎么实现的。我并不想说得太细，一个是我懒，另一个原因就是，自己发现一些东西更容易理解，并不容易忘记。很多细节我已经说了，建议大家自行去研究。</p><h3 id="附模拟容器的代码"><a href="#附模拟容器的代码" class="headerlink" title="附模拟容器的代码"></a>附模拟容器的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">interface SuperModuleInterface</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 超能力激活方法</span><br><span class="line">     *</span><br><span class="line">     * 任何一个超能力都得有该方法，并拥有一个参数</span><br><span class="line">     * @param array $target 针对目标，可以是一个或多个，自己或他人</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function activate(array $target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * X-超能量</span><br><span class="line"> *&#x2F;</span><br><span class="line">class XPower implements SuperModuleInterface</span><br><span class="line">&#123;</span><br><span class="line">    public function activate(array $target)</span><br><span class="line">    &#123;</span><br><span class="line">        return &#39;使用X-超能量击中了&#39; . join(&#39;,&#39;, $target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 终极炸弹</span><br><span class="line"> *&#x2F;</span><br><span class="line">class UltraBomb implements SuperModuleInterface</span><br><span class="line">&#123;</span><br><span class="line">    public function activate(array $target)</span><br><span class="line">    &#123;</span><br><span class="line">        return &#39;使用终极炸弹轰炸了&#39; . join(&#39;,&#39;, $target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Superman</span><br><span class="line">&#123;</span><br><span class="line">    protected $module;</span><br><span class="line"></span><br><span class="line">    public function __construct(SuperModuleInterface $module)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;module &#x3D; $module;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function run()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;module-&gt;activate([&#39;大怪兽&#39;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Container</span><br><span class="line">&#123;</span><br><span class="line">    protected $binds;</span><br><span class="line"></span><br><span class="line">    protected $instances;</span><br><span class="line"></span><br><span class="line">    public function bind($abstract, $concrete)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($concrete instanceof Closure) &#123;</span><br><span class="line">            $this-&gt;binds[$abstract] &#x3D; $concrete;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;instances[$abstract] &#x3D; $concrete;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function make($abstract, $parameters &#x3D; [])</span><br><span class="line">    &#123;</span><br><span class="line">        if (isset($this-&gt;instances[$abstract])) &#123;</span><br><span class="line">            return $this-&gt;instances[$abstract];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        array_unshift($parameters, $this);</span><br><span class="line"></span><br><span class="line">        return call_user_func_array($this-&gt;binds[$abstract], $parameters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个容器</span><br><span class="line">$container &#x3D; new Container;</span><br><span class="line"></span><br><span class="line">$container-&gt;bind(&#39;superman&#39;, function ($container, $moduleName) &#123;</span><br><span class="line">    return new Superman($container-&gt;make($moduleName));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$container-&gt;bind(&#39;xpower&#39;, function ($container) &#123;</span><br><span class="line">    return new XPower;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$container-&gt;bind(&#39;ultrabomb&#39;, function ($container) &#123;</span><br><span class="line">    return new UltraBomb;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开始启动生产</span><br><span class="line">$superman_1 &#x3D; $container-&gt;make(&#39;superman&#39;, [&#39;xpower&#39;])-&gt;run();</span><br><span class="line">$superman_2 &#x3D; $container-&gt;make(&#39;superman&#39;, [&#39;ultrabomb&#39;])-&gt;run();</span><br><span class="line">$superman_3 &#x3D; $container-&gt;make(&#39;superman&#39;, [&#39;xpower&#39;])-&gt;run();</span><br><span class="line"></span><br><span class="line">dd($superman_1, $superman_2, $superman_3);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;使用X-超能量击中了大怪兽&quot;</span><br><span class="line">&quot;使用终极炸弹轰炸了大怪兽&quot;</span><br><span class="line">&quot;使用X-超能量击中了大怪兽&quot;</span><br></pre></td></tr></table></figure><blockquote><p>本文整理自：<a href="https://www.insp.top/article/learn-laravel-container">https://www.insp.top/article/learn-laravel-container</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpbrew 安装多版本php</title>
      <link href="2020/03/20/phpbrew-%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACphp/"/>
      <url>2020/03/20/phpbrew-%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACphp/</url>
      
        <content type="html"><![CDATA[<h3 id="phpbrew-安装"><a href="#phpbrew-安装" class="headerlink" title="phpbrew 安装"></a>phpbrew 安装</h3><p><a href="https://github.com/phpbrew/phpbrew/blob/master/README.md#requirement">English</a><br><a href="https://github.com/phpbrew/phpbrew/blob/master/README.cn.md#%E5%AE%89%E8%A3%85%E9%9C%80%E6%B1%82">中文</a></p><h3 id="使用参考"><a href="#使用参考" class="headerlink" title="使用参考"></a>使用参考</h3><h4 id="安装-7-3"><a href="#安装-7-3" class="headerlink" title="安装 7.3"></a>安装 7.3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">phpbrew install \</span><br><span class="line">    --mirror&#x3D;https:&#x2F;&#x2F;www.php.net 7.3 \</span><br><span class="line">  +default+mysql+fpm+opcache+bcmath+zlib \</span><br><span class="line">  +bz2&#x3D;&quot;$(brew --prefix bzip2)&quot; \</span><br><span class="line">  +zlib&#x3D;&quot;$(brew --prefix zlib)&quot;</span><br></pre></td></tr></table></figure><ul><li><p>参数说明 </p><p>  –mirror<br><a href="https://github.com/phpbrew/phpbrew/issues/1011">参考</a></p><p>  +bz2 +zlib<br><a href="https://github.com/phpbrew/phpbrew/issues/966">参考</a></p><p>  后者可能是因为 lookup-prefix 设置不合理，默认是在 homebrew 的安装目录查找</p></li></ul><h4 id="安装-7-0"><a href="#安装-7-0" class="headerlink" title="安装 7.0"></a>安装 7.0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">phpbrew install \</span><br><span class="line">  --mirror&#x3D;https:&#x2F;&#x2F;www.php.net 7.0 \</span><br><span class="line">  +default+mysql+opcache+session+debug+hash+zlib+gd+iconv+fpm \</span><br><span class="line">  +bz2&#x3D;&quot;$(brew --prefix bzip2)&quot; \</span><br><span class="line">  +zlib&#x3D;&quot;$(brew --prefix zlib)&quot; \</span><br><span class="line">    +iconv&#x3D;&quot;$(brew --prefix libiconv)&quot;</span><br><span class="line"></span><br><span class="line">phpbrew use 7.0.33</span><br><span class="line"></span><br><span class="line">phpbrew ext install gd -- --with-zlib-dir&#x3D;&quot;$(brew --prefix zlib)&quot;</span><br><span class="line">phpbrew ext install mongodb</span><br><span class="line">phpbrew ext install zookeeper -- --with-libzookeeper-dir&#x3D;$(brew --prefix zookeeper)</span><br></pre></td></tr></table></figure><p><code>wsl</code> 使用备忘<br>在 <code>wsl</code> 里安装时下载默认用的 php stream ，可以加参数 <code>--downloader=curl</code>  换为 <code>curl apt install libxml2-dev libbz2-dev libcurl4-gnutls-dev libpng-dev libmcrypt-dev libreadline-dev libxslt-dev autoconf</code> </p><h4 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h4><h5 id="查看已安装版本"><a href="#查看已安装版本" class="headerlink" title="查看已安装版本"></a>查看已安装版本</h5><p><code>phpbrew list</code></p><h5 id="切换到-7-3-7-版本（一次性，仅在当前-session-有效）"><a href="#切换到-7-3-7-版本（一次性，仅在当前-session-有效）" class="headerlink" title="切换到 7.3.7 版本（一次性，仅在当前 session 有效）"></a>切换到 7.3.7 版本（一次性，仅在当前 session 有效）</h5><p><code>phpbrew use 7.3.7</code></p><h5 id="切换到-7-3-7-版本（永久，调用下面-off-命令才可以换回系统版本）"><a href="#切换到-7-3-7-版本（永久，调用下面-off-命令才可以换回系统版本）" class="headerlink" title="切换到 7.3.7 版本（永久，调用下面 off 命令才可以换回系统版本）"></a>切换到 7.3.7 版本（永久，调用下面 off 命令才可以换回系统版本）</h5><p><code>phpbrew switch 7.3.7</code></p><h5 id="切换回系统版本（暂时回归系统版本）"><a href="#切换回系统版本（暂时回归系统版本）" class="headerlink" title="切换回系统版本（暂时回归系统版本）"></a>切换回系统版本（暂时回归系统版本）</h5><p><code>phpbrew off</code></p><h5 id="切换回系统版本（永久）"><a href="#切换回系统版本（永久）" class="headerlink" title="切换回系统版本（永久）"></a>切换回系统版本（永久）</h5><p><code>phpbrew switch-off</code></p><h4 id="安装扩展"><a href="#安装扩展" class="headerlink" title="安装扩展"></a>安装扩展</h4><p>首先需要切换到需要安装扩展的 PHP 版本，然后执行下面命令安装扩展</p><h5 id="安装-phpredis-扩展"><a href="#安装-phpredis-扩展" class="headerlink" title="安装 phpredis 扩展"></a>安装 phpredis 扩展</h5><p><code>phpbrew ext install redis</code></p><h5 id="指定扩展版本"><a href="#指定扩展版本" class="headerlink" title="指定扩展版本"></a>指定扩展版本</h5><p><code>phpbrew ext install redis 5.0.1</code></p><h4 id="附一些常用扩展的安装"><a href="#附一些常用扩展的安装" class="headerlink" title="附一些常用扩展的安装"></a>附一些常用扩展的安装</h4><h5 id="gd"><a href="#gd" class="headerlink" title="gd"></a>gd</h5><p><code>phpbrew ext install gd -- --with-zlib-dir=&quot;$(brew --prefix zlib)&quot;</code></p><h5 id="iconv"><a href="#iconv" class="headerlink" title="iconv"></a>iconv</h5><p><code>phpbrew ext install iconv -- --with-iconv=&quot;$(brew --prefix libiconv)&quot;</code><br>如所见，可以通过 – 后附加自定义参数给 configure 过程</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>Readme <a href="https://github.com/phpbrew/phpbrew/blob/master/README.md">https://github.com/phpbrew/phpbrew/blob/master/README.md</a><br>Cookbook <a href="https://github.com/phpbrew/phpbrew/wiki/Cookbook">https://github.com/phpbrew/phpbrew/wiki/Cookbook</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决dyld: Library not loaded icu4c</title>
      <link href="2020/03/20/%E8%A7%A3%E5%86%B3dyld-Library-not-loaded-icu4c/"/>
      <url>2020/03/20/%E8%A7%A3%E5%86%B3dyld-Library-not-loaded-icu4c/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p><code>brew</code> 安装 <code>npm</code>，安装完成后发现<code>php</code>用不了了，报错信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dyld: Library not loaded: &#x2F;usr&#x2F;local&#x2F;opt&#x2F;icu4c&#x2F;lib&#x2F;libicui18n.61_1.dylib</span><br><span class="line">Referenced from: &#x2F;usr&#x2F;local&#x2F;opt&#x2F;php7&#x2F;bin&#x2F;php</span><br><span class="line">Reason: image not found</span><br><span class="line">Trace&#x2F;BPT trap: 5</span><br></pre></td></tr></table></figure><h3 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h3><p>PHP7依赖<code>61_1</code>版本的<code>icu4c</code>，使用<code>brew info icu4c</code> 提示当前版本为63。那么解决办法就来了</p><ol><li>升级<code>php</code>到<code>7.3</code>，但是这样会导致一堆<code>php</code>版本问题；</li><li>或者将<code>icu4c</code>降级到<code>61_1</code>版本，但是这<code>node</code>就不能用了</li><li>安装两个<code>icu4c</code>，来回切换</li></ol><p>这样看来，方案3最靠谱～</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>没有找到<code>brew</code>直接安装多版本的<code>icu4c</code>的方案，所以直接编译到brew的目录，然后用brew进行管理版本，本地的环境为<code>mac ios 10.15</code></p><h4 id="找到需要的版本"><a href="#找到需要的版本" class="headerlink" title="找到需要的版本"></a>找到需要的版本</h4><p><a href="http://site.icu-project.org/">官网地址</a>，按需自取，例如我需要的是61_1，对应的地址是<a href="http://download.icu-project.org/files/icu4c/61.1/icu4c-61_1-src.tgz">http://download.icu-project.org/files/icu4c/61.1/icu4c-61_1-src.tgz</a></p><h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~&#x2F;sources</span><br><span class="line">cd ~&#x2F;sources</span><br><span class="line">wget http:&#x2F;&#x2F;download.icu-project.org&#x2F;files&#x2F;icu4c&#x2F;61.1&#x2F;icu4c-61_1-src.tgz</span><br><span class="line">tar xvzf icu4c-61_1-src.tgz</span><br><span class="line">cd icu&#x2F;source&#x2F;</span><br><span class="line"># 建个目录</span><br><span class="line">sudo mkdir &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;icu4c&#x2F;61.1</span><br><span class="line"># 设定编译至该路径</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;icu4c&#x2F;61.1</span><br><span class="line"># 编译</span><br><span class="line">make</span><br><span class="line"># 安装</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h4 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h4><p>查看本机中已安装的icu4c版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew info icu4c</span><br></pre></td></tr></table></figure><p>切换版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew switch icu4c 61.1</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>其实被方案1给坑了，刚开始没在意，发生问题就直接搜索，想要直接站在巨人的肩膀上，结果需要执行<code>brew upgrade php</code> 然后就有各种php版本的问题。。下篇说说<code>phpbrew</code>管理多版本<code>php</code></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL用正则表达式进行搜索</title>
      <link href="2020/03/12/SQL%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/"/>
      <url>2020/03/12/SQL%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>偶然发现sql可以进行正则匹配搜索内容，新大陆</p><blockquote><p>关键字 REGEXP</p></blockquote><ol><li><code>.</code>表示匹配任意一个字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from products where name regexp &#39;.000&#39;</span><br></pre></td></tr></table></figure></li><li><code>or</code>匹配<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from products where name regexp &#39;1000|2000&#39;</span><br></pre></td></tr></table></figure></li><li>匹配几个字符之一<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from products where name regexp &#39;[123]Ton&#39;</span><br></pre></td></tr></table></figure></li><li>匹配范围<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from products where name regexp &#39;[1-3]Ton&#39;</span><br></pre></td></tr></table></figure></li><li>匹配字符类</li></ol><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>任意字母和数字（同[a-zA-Z0-9]）</td></tr><tr><td>[:alpha:]</td><td>任意字符（同[a-zA-Z]）</td></tr><tr><td>[:blank:]</td><td>空格和制表（同[\t]）</td></tr><tr><td>[:cntrl:]</td><td>ASCII控制字符（ASCII 0到31和127）</td></tr><tr><td>[:digit:]</td><td>任意数字（同[0-9]）</td></tr><tr><td>[:graph:]</td><td>与[:print:]相同，但不包括空格</td></tr><tr><td>[:lower:]</td><td>任意小写字母（同[a-z]）</td></tr><tr><td>[:print:]</td><td>任意可打印字符</td></tr><tr><td>[:punct:]</td><td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td></tr><tr><td>[:space:]</td><td>包括空格在内的任意空白字符（同[\f\n\r\t\v]）</td></tr><tr><td>[:upper:]</td><td>任意大写字母（同[A-Z]）</td></tr><tr><td>[:xdigit:]</td><td>任意十六进制数字（同[a-fA-F0-9]）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myisam与innoDB的主要区别和应用场景</title>
      <link href="2020/03/10/myisam%E4%B8%8EinnoDB%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>2020/03/10/myisam%E4%B8%8EinnoDB%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="主要区别："><a href="#主要区别：" class="headerlink" title="主要区别："></a>主要区别：</h3><ol><li>MyISAM是非事务安全型的，而InnoDB是事务安全型的。</li><li>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。</li><li>MyISAM支持全文类型索引，而InnoDB不支持全文索引。</li><li>MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</li><li>MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。</li><li>InnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。</li></ol><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ol><li>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</li><li>InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL connection 的相关信息</title>
      <link href="2020/01/23/MySQL-connection-%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/"/>
      <url>2020/01/23/MySQL-connection-%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="查看mysql连接数的语句"><a href="#查看mysql连接数的语句" class="headerlink" title="查看mysql连接数的语句"></a>查看mysql连接数的语句</h3><ol><li>mysql 中有<code>Max_connection</code>，这个值是对应于一个mysql实例。<br>一个mysql 实例中 ，可以有多个database、movie_log、movie_order、movie_pay 等。</li><li><code>show variables like &#39;%max_connections%&#39;;</code>可以查看当前数据库实例设置的最大连接数。<br>实际MySQL服务器允许的最大连接数16384。</li><li><code>show variables;</code> 可以查看当前数据库实例配置的所有变量，即my.ini 文件中的配置信息。</li><li><code>show processlist;</code><br>如果是root帐号，你能看到所有用户的当前连接。如果是其它普通帐号，只能看到自己占用的连接。<br>注：<code>show processlist;</code>只列出前100条，如果想全列出请使用<code>show full processlist;</code></li><li><code>show status;</code> 查看当前数据库的状态。</li><li><code>show status like &#39;%Threads%&#39;;</code>查看当前数据库线程变量的状态。</li></ol><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Threads_cached    | 58    |</span><br><span class="line">| Threads_connected | 57    |   ###这个数值指的是打开的连接数</span><br><span class="line">| Threads_created   | 3676  |</span><br><span class="line">| Threads_running   | 4     |   ###这个数值指的是激活的连接数，这个数值一般远低于connected数值</span><br><span class="line">+-------------------+-------+</span><br></pre></td></tr></table></figure><p>Threads_connected 跟show processlist结果相同，表示当前连接数。准确的来说，Threads_running是代表当前并发数（当前连接正在使用中对数量。）<br>当前连接数（包括使用中对连接，也包括闲置的连接（sleep状态），也包括阻塞的连接（waiting for ……））<br>java 中有数据库连接池，连接池中有最小连接数，<br>因此：mysql 会有最小连接数 个连接 ，可能这些连接都是 sleep 状态的，</p><ol start="7"><li><code>show status like &#39;%connect%&#39;;</code>Connections，试图连接到（不管是否成功）MySQL服务器的连接数。其中Max_used_connections表示服务器启动后已经同时使用的连接的最大数量。Threads_connected表示当前的连接数。</li></ol><h3 id="关于sleep与lock的问题"><a href="#关于sleep与lock的问题" class="headerlink" title="关于sleep与lock的问题"></a>关于sleep与lock的问题</h3><ol><li>造成sleep的原因有三个</li></ol><ul><li><p>下面是mysql手册给出的解释:</p><ol><li>客户端程序在退出之前没有调用<code>mysql_close()</code>。</li><li>客户端sleep的时间在 wait_timeout 或 interactive_timeout 规定的秒内没有发出任何请求到服务器。</li><li>客户端程序在结束之前向服务器发送了请求还没得到返回结果就结束掉了.</li></ol></li><li><p>解决办法：<br>避免大量 sleep的连接的方法，数据库连接池设置min_idle设置小一些。</p></li></ul><ol start="2"><li><p>waiting for metadata lock 的原因 ？</p><ol><li>metadata lock 机制是为了保证数据一致性存在的。在有事务的操作时候，需要首先获得metadata lock，然后操作。如果这个时候，又来了一个事务也要ddl操作 同一个表，就会出现 metadata lock。</li><li>自动提交模式下，单语句就是一个事务，执行完了事务也就结束了。</li><li>preparestatement会获得 metalock，一旦prepare 完毕， metalock 就释放了。</li><li>online DDL应该是指在alter table进行的时候，插入/修改/删除数据的sql语句不会Waiting for table metadata lock. 一旦alter table TableA的操作停滞在Waiting for table metadata lock的状态，后续对TableA的任何操作（包括读）都无法进行，也会在Opening tables的阶段进入Waiting for table metadata lock的队列</li></ol></li><li><p><code>alter table</code>什么情况下会发生锁？(主要针对于myisam 引擎（锁表）)     </p><ol><li><p>通过show processlist看到TableA上有正在进行的操作（包括读），此时alter table语句无法获取到metadata 独占锁，会进行等待。</p></li><li><p>通过show processlist看不到TableA上有任何操作，但实际上存在有未提交的事务，可以在information_schema.innodb_trx中查看到。在事务没有完成之前，TableA上的锁不会释放，alter table同样获取不到metadata的独占锁</p></li><li><p>通过show processlist看不到TableA上有任何操作，在information_schema.innodb_trx中也没有任何进行中的事务。这很可能是因为在一个显式的事务中，对TableA进行了一个失败的操作（比如查询了一个不存在的字段），这时事务没有开始，但是失败语句获取到的锁依然有效。从performance_schema.events_statements_current表中可以查到失败的语句</p><p>也就是说除了语法错误，其他错误语句获取到的锁在这个事务提交或回滚之前，仍然不会释放掉。because the failed statement is written to the binary log and the locks protect log consistency 但是解释这一行为的原因很难理解，因为错误的语句根本不会被记录到二进制日志<br>总之，alter table的语句是很危险的，在操作之前最好确认对要操作的表没有任何进行中的操作、没有未提交事务、也没有显式事务中的报错语句。如果有alter table的维护任务，在无人监管的时候运行，最好通过lock_wait_timeout设置好超时时间，避免长时间的metedata锁等待。</p></li></ol></li></ol><h3 id="MySQL的锁机制"><a href="#MySQL的锁机制" class="headerlink" title="MySQL的锁机制"></a>MySQL的锁机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyISAM和MEMORY存储引擎采用的是表级锁（table-level-locking）</span><br><span class="line">BDB存储引擎采用的是页面锁（page-level-locking），同时也支持表级锁；</span><br><span class="line">InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下是采用行级锁。</span><br><span class="line">所有表类型都支持表级锁，但是 MyISAM 只支持表级锁</span><br></pre></td></tr></table></figure><h5 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h5><pre><code>表级：直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许行级：仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。页级：表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录</code></pre><h5 id="三种锁的特性归纳"><a href="#三种锁的特性归纳" class="headerlink" title="三种锁的特性归纳"></a>三种锁的特性归纳</h5><ol><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li><li>三种锁各有各的特点，若仅从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如WEB应用；行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</li></ol><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ol><li><p>innodb 虽然是行级别锁，但是在执行update 操作时候，如果where 查询条件 不存在索引，一样会扫描整个表，锁住整张表，解决办法就是需要添加索引。这样锁住的就是某些行了。</p></li><li><p>对于读写</p><ol><li>对WRITE，MySQL使用的表锁定方法原理如下：如果在表上没有锁，在它上面放一个写锁。否则，把锁定请求放在写锁定队列中。</li><li>对READ，MySQL使用的锁定方法原理如下：如果在表上没有写锁定，把一个读锁定放在它上面  否则，把锁请求放在读锁定队列中。</li></ol></li><li><p>InnoDB使用行锁定，BDB使用页锁定。对于这两种存储引擎，都可能存在死锁。这是因为，在SQL语句处理期间，InnoDB自动获得行锁定和BDB获得页锁定，而不是在事务启动时获得。</p></li><li><p>行锁优缺点</p><ol><li>行级锁定的优点：<ol><li>当在许多线程中访问不同的行时只存在少量锁定冲突。</li><li>回滚时只有少量的更改。</li><li>可以长时间锁定单一的行。</li></ol></li><li>行级锁定的缺点：<ol><li>比页级或表级锁定占用更多的内存。</li><li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li><li>如果你在大部分数据上经常进行<code>GROUP BY</code>操作或者必须经常扫描整个表，比其它锁定明显慢很多。用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ol></li></ol></li><li><p>在以下情况下，表锁定优先于页级或行级锁定：</p><ol><li>表的大部分语句用于读取。</li><li>对严格的关键字进行读取和更新，你可以更新或删除可以用单一的读取的关键字来提取的一行：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">UPDATE</span> tbl_name <span class="keyword">SET</span> <span class="keyword">column</span>=<span class="keyword">value</span> <span class="keyword">WHERE</span> unique_key_col=key_value;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> unique_key_col=key_value;</span><br></pre></td></tr></table></figure></li><li>SELECT 结合并行的INSERT语句，并且只有很少的UPDATE或DELETE语句。<br>·         在整个表上有许多扫描或GROUP BY操作，没有任何写操作。</li></ol></li><li><p>如果想要在一个表上做大量的 INSERT 和 SELECT操作，但是并行的插入却不可能时，可以将记录插入到临时表中，然后定期将临时表中的数据更新到实际的表里。可以用以下命令实现：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOCK TABLES real_table WRITE, insert_table WRITE;</span><br><span class="line">mysql&gt; INSERT INTO real_table SELECT * FROM insert_table;</span><br><span class="line">mysql&gt; TRUNCATE TABLE insert_table;</span><br><span class="line">mysql&gt; UNLOCK TABLES;</span><br></pre></td></tr></table></figure></li><li><p>MySQL表级锁的两种模式</p></li></ol><blockquote><p>表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。什么意思呢，就是说对MyISAM表进行读操作时，它不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写操作；而对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作。</p></blockquote><blockquote><p>MyISAM表的读和写是串行的，即在进行读操作时不能进行写操作，反之也是一样。但在一定条件下MyISAM表也支持查询和插入的操作的并发进行，其机制是通过控制一个系统变量（concurrent_insert）来进行的，当其值设置为0时，不允许并发插入；当其值设置为1时，如果MyISAM表中没有空洞（即表中没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录；当其值设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</p></blockquote><blockquote><p>MyISAM锁调度是如何实现的呢，这也是一个很关键的问题。例如，当一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，此时MySQL将会如优先处理进程呢？通过研究表明，写进程将先获得锁（即使读请求先到锁等待队列）。但这也造成一个很大的缺陷，即大量的写操作会造成查询操作很难获得读锁，从而可能造成永远阻塞。所幸我们可以通过一些设置来调节MyISAM的调度行为。我们可通过指定参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利，设置其值为1（set low_priority_updates=1),使该连接发出的更新请求优先级降低。</p></blockquote><ol start="8"><li>InnoDB有两种模式的行锁：<ol><li>共享锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。<br>( Select * from table_name where ……lock in share mode)</li><li>排他锁：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。(select * from table_name where…..for update)</li></ol></li></ol><blockquote><p>为了允许行锁和表锁共存，实现多粒度锁机制；同时还有两种内部使用的意向锁（都是表锁），分别为意向共享锁和意向排他锁。</p></blockquote><blockquote><p>InnoDB行锁是通过给索引项加锁来实现的，即只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁！</p></blockquote><ol start="9"><li>MySQL 的表级锁都是写锁优先，而且是采用排队机制，这样不会出现死锁的情况。对于 InnoDB 和 BDB 存储引擎来说，是可能产生死锁的。这是因为 InnoDB 会自动捕获行锁， BDB 会在执行 SQL 语句时捕获页锁的，而不是在事务的开始就这么做。</li></ol><h3 id="插入、更新性能优化的几个重要参数"><a href="#插入、更新性能优化的几个重要参数" class="headerlink" title="插入、更新性能优化的几个重要参数"></a>插入、更新性能优化的几个重要参数</h3><ol><li><code>bulk_insert_buffer_size</code>批量插入缓存大小</li></ol><blockquote><p>这个参数是针对MyISAM存储引擎来说的.适用于在一次性插入100-1000+条记录时, 提高效率.默认值是8M.可以针对数据量的大小,翻倍增加.</p></blockquote><ol start="2"><li><code>concurrent_insert</code>并发插入</li></ol><blockquote><p>当表没有空洞(删除过记录),在某进程获取读锁的情况下,其他进程可以在表尾部进行插入。</p></blockquote><table><thead><tr><th>值</th><th align="center">意义</th><th align="center">是否默认</th></tr></thead><tbody><tr><td>0</td><td align="center">不允许并发插</td><td align="center"></td></tr><tr><td>1</td><td align="center">当表没有空洞时, 执行并发插入</td><td align="center">默认</td></tr><tr><td>2</td><td align="center">不管是否有空洞都执行并发插入</td><td align="center"></td></tr></tbody></table><ol start="3"><li><code>delay_key_write</code>针对MyISAM的延迟更新索引</li></ol><blockquote><p>针对MyISAM存储引擎,延迟更新索引.意思是说,update记录时,先将数据up到磁盘,但不up索引,将索引存在内存里,当表关闭时,将内存索引,写到磁盘. 值为 0不开启, 1开启. 默认开启.</p></blockquote><ol start="4"><li><code>delayed_insert_limit,delayed_insert_timeout,delayed_queue_size</code><br>延迟插入 <blockquote><p>将数据先交给内存队列,然后慢慢地插入。</p></blockquote></li></ol><h5 id="锁表锁行案例"><a href="#锁表锁行案例" class="headerlink" title="锁表锁行案例"></a>锁表锁行案例</h5><blockquote><p>注1: FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。注2: 要测试锁定的状况，可以利用MySQL的Command Mode ，开二个视窗来做测试。</p></blockquote><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM products WHERE id&#x3D;&#39;3&#39; FOR UPDATE;  </span><br></pre></td></tr></table></figure><p>主键明确，锁住的是行。如果没有记录，不锁定行。</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM products WHERE name&#x3D;&#39;Mouse&#39; FOR UPDATE;</span><br></pre></td></tr></table></figure><p>主键不明确，锁住的是表。</p></li></ol><h3 id="事务来一波"><a href="#事务来一波" class="headerlink" title="事务来一波"></a>事务来一波</h3><ol><li><p>事务的使用</p><ol><li>全部的表类型都可以使用锁，但是只有 InnoDB 和 BDB 才有内置的事务功能。</li><li>使用 begin 开始事务，使用 commit 结束事务，中间可以使用 rollback 回滚事务。</li><li>在默认情况下， InnoDB 表支持一致读。</li><li>事务只用于 insert 和 update 语句来更新数据表，不能用于对表结构的更改。执行一条更改表结构或 begin 则会立即提交当前的事务。</li></ol></li><li><p>事务的四个属性</p><p> InnoDB锁与MyISAM锁的最大不同在于：一是支持事务（TRANCSACTION），二是采用了行级锁。我们知道事务是由一组SQL语句组成的逻辑处理单元，其有四个属性（简称ACID属性），分别为：</p><ol><li>原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全都不执行；</li><li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态；</li><li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行；</li><li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li><li>其他： 隔离性 (isolation)通过锁来实现，其他3个原子性(atomicity)，一致性(consistency)，持久性(durability)通过数据库的redo和undo来完成。</li></ol></li><li><p>事务隔离级别：SQL标准中定义了 4 个隔离级别： read uncommited，read commited, repeatable read, serializable 。MySQL 允许利用 <code>set transaction</code> 来设置隔离级别</p><ol><li>read uncommited 即脏读，一个事务修改了一行,ha，另一个事务也可以读到该行。如果第一个事务执行了回滚，那么第二个事务读取的就是从来没有正式出现过的值。 ?</li><li>read commited 即一致读，试图通过只读取提交的值的方式来解决脏读的问题，但是这又引起了不可重复读取的问题。一个事务执行一个查询，读取了大量的数据行。在它结束读取之前，另一个事务可能完成了对数据行的更改。当第一个事务试图再次执行同一个查询，服务器就会返回不同的结果。</li><li>repeatable read 即可重复读，在一个事务对数据行执行读取或写入操作时锁定了这些数据行。但是这种方式又引发了幻想读的问题。因为只能锁定读取或写入的行，不能阻止另一个事务插入数据，后期执行同样的查询会产生更多的结果。</li><li>serializable 模式中，事务被强制为依次执行。这是 SQL 标准建议的默认行为。</li></ol></li><li><p>如果多个事务更新了同一行，就可以通过回滚其中一个事务来解除死锁。</p></li><li><p>事务一致性</p></li></ol><blockquote><p>在事务开始和完成时，数据都必须保持一致状态。事务一致性 ，是由 原子性，隔离性，持久性，共同保持的。</p></blockquote><p>例子：事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2修改了帐号A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上，事务1最终完成后，帐号A只增加了100元，因为事务2的修改结果被事务1覆盖掉了。</p><h3 id="mysql-配置信息"><a href="#mysql-配置信息" class="headerlink" title="mysql 配置信息"></a>mysql 配置信息</h3><ol><li>错误日志</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 二进制日志</span><br><span class="line">&#96;&#96;&#96; --log-bin[&#x3D;file_name] &#96;&#96;&#96;</span><br><span class="line">mysqld将包含所有更新数据的SQL命令写入日志文件。</span><br><span class="line"></span><br><span class="line">二进制日志需要用mysqlbinlog工具来查看，语法如下：</span><br></pre></td></tr></table></figure><p>#mysqlbinlog log_file<br>–binlog-do-db=db_name #如果当前的数据库是db_name，应该更新记录到二进制日志中<br>–binlog-ignore-db=db_name #如果当前的数据库是db_name，不应该更新记录到二进制日志中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果多个数据库，可如下写法：</span><br></pre></td></tr></table></figure><p>–binlog-do-db=db1<br>–binlog-do-db=db2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单个库的主从同步：</span><br></pre></td></tr></table></figure><p>replicate_do_db=test<br>replicate_wild_do_table=test.%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">或</span><br></pre></td></tr></table></figure><p>replicate_ignore_db=mysql<br>replicate_wild_ignore_table=mysql.%<br>log-slave-updates = 1 #这个参数用来配置从服务器的更新是否写入二进制日志，这个选项默认是不打开的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3. 查询日志</span><br><span class="line">&gt;记录了客户端所有的语句，而二进制日志不包含只查询数据库的语句</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; --log[&#x3D;file_name] &#96;&#96;&#96;</span><br><span class="line">启动mysqld时，查询日志开始被记录，默认文件名是host_name.log</span><br><span class="line"></span><br><span class="line">4，慢查询日志</span><br></pre></td></tr></table></figure><p>slow_query_log = 1<br>slow_query_log_file = /opt/logs/mysql5/mysql-slow.log<br>long_query_time = 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果慢查询日志中记录内容很多，可以使用mysqldumpslow工具来对慢查询日志进行分类汇总</span><br></pre></td></tr></table></figure><p>#mysqldumpslow ****-slow.log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5，配置文件详解：</span><br></pre></td></tr></table></figure><p>wget <a href="http://cdn.mysql.com/archives/mysql-5.6/mysql-5.6.10.tar.gz">http://cdn.mysql.com/archives/mysql-5.6/mysql-5.6.10.tar.gz</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>vi /etc/my.cnf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下只列出my.cnf文件中[mysqld]段落中的内容,其他段落内容对MySQL运行性能影响甚微,因而姑且忽略。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[mysqld]<br>character-set-server = utf8<br>user    = mysql<br>port    = 3306<br>socket  = /data/mysql/3306/mysql.sock<br>basedir = /usr/local/webserver/mysql<br>datadir = /data/mysql/3306/data<br>log-error = /data/mysql/3306/mysql_error.log<br>pid-file = /data/mysql/3306/mysql.pid<br>default-storage-engine = MyISAM/InnoDB #设置默认存储引擎<br>skip-locking #避免MySQL的外部锁定,减少出错几率增强稳定性</p><p>#禁止MySQL对外部连接进行DNS解析,使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意,如果开启该选项,则所有远程主机连接授权都要使用IP地址方式,否则MySQL将无法正常处理连接请求!<br>skip-name-resolve</p><h1 id="开启该选项可以彻底关闭MySQL的TCP-IP连接方式-如果CentOS系统WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项-否则将无法正常连接"><a href="#开启该选项可以彻底关闭MySQL的TCP-IP连接方式-如果CentOS系统WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项-否则将无法正常连接" class="headerlink" title="开启该选项可以彻底关闭MySQL的TCP/IP连接方式,如果CentOS系统WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项!否则将无法正常连接!"></a>开启该选项可以彻底关闭MySQL的TCP/IP连接方式,如果CentOS系统WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项!否则将无法正常连接!</h1><p>skip-networking</p><h1 id="启动mysql-不启动复制"><a href="#启动mysql-不启动复制" class="headerlink" title="启动mysql,不启动复制"></a>启动mysql,不启动复制</h1><p>skip-slave-start </p><h1 id="指定MySQL可能的连接数量。当MySQL主线程在很短的时间内接收到非常多的连接请求-该参数生效-主线程花费很短的时间检查连接并且启动一个新线程。back-log参数的值指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。默认值为50。对于Linux系统推荐设置为小于512的整数"><a href="#指定MySQL可能的连接数量。当MySQL主线程在很短的时间内接收到非常多的连接请求-该参数生效-主线程花费很短的时间检查连接并且启动一个新线程。back-log参数的值指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。默认值为50。对于Linux系统推荐设置为小于512的整数" class="headerlink" title="指定MySQL可能的连接数量。当MySQL主线程在很短的时间内接收到非常多的连接请求,该参数生效,主线程花费很短的时间检查连接并且启动一个新线程。back_log参数的值指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。默认值为50。对于Linux系统推荐设置为小于512的整数"></a>指定MySQL可能的连接数量。当MySQL主线程在很短的时间内接收到非常多的连接请求,该参数生效,主线程花费很短的时间检查连接并且启动一个新线程。back_log参数的值指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。默认值为50。对于Linux系统推荐设置为小于512的整数</h1><p>back_log = 384</p><h1 id="设置最大包-限制server接受的数据包大小，避免超长SQL的执行有问题，默认值为16M，当MySQL客户端或mysqld服务器收到大于max-allowed-packet字节的信息包时，将发出“信息包过大”错误，并关闭连接。对于某些客户端，如果通信信息包过大，在执行查询期间，可能会遇到“丢失与MySQL服务器的连接”错误"><a href="#设置最大包-限制server接受的数据包大小，避免超长SQL的执行有问题，默认值为16M，当MySQL客户端或mysqld服务器收到大于max-allowed-packet字节的信息包时，将发出“信息包过大”错误，并关闭连接。对于某些客户端，如果通信信息包过大，在执行查询期间，可能会遇到“丢失与MySQL服务器的连接”错误" class="headerlink" title="设置最大包,限制server接受的数据包大小，避免超长SQL的执行有问题，默认值为16M，当MySQL客户端或mysqld服务器收到大于max_allowed_packet字节的信息包时，将发出“信息包过大”错误，并关闭连接。对于某些客户端，如果通信信息包过大，在执行查询期间，可能会遇到“丢失与MySQL服务器的连接”错误"></a>设置最大包,限制server接受的数据包大小，避免超长SQL的执行有问题，默认值为16M，当MySQL客户端或mysqld服务器收到大于max_allowed_packet字节的信息包时，将发出“信息包过大”错误，并关闭连接。对于某些客户端，如果通信信息包过大，在执行查询期间，可能会遇到“丢失与MySQL服务器的连接”错误</h1><p>max_allowed_packet = 16M</p><h1 id="指定用于索引的缓冲区大小-增加它可得到更好的索引处理性能。对于内存在4GB左右的服务器该参数可设置为256M或384M。注意-该参数值设置的过大反而会是服务器整体效率降低"><a href="#指定用于索引的缓冲区大小-增加它可得到更好的索引处理性能。对于内存在4GB左右的服务器该参数可设置为256M或384M。注意-该参数值设置的过大反而会是服务器整体效率降低" class="headerlink" title="指定用于索引的缓冲区大小,增加它可得到更好的索引处理性能。对于内存在4GB左右的服务器该参数可设置为256M或384M。注意:该参数值设置的过大反而会是服务器整体效率降低!"></a>指定用于索引的缓冲区大小,增加它可得到更好的索引处理性能。对于内存在4GB左右的服务器该参数可设置为256M或384M。注意:该参数值设置的过大反而会是服务器整体效率降低!</h1><p>key_buffer_size = 256M</p><h1 id="查询排序时所能使用的缓冲区大小。注意-该参数对应的分配内存是每连接独占-如果有100个连接-那么实际分配的总共排序缓冲区大小为100×6-600MB。所以-对于内存在4GB左右的服务器推荐设置为6-8M。"><a href="#查询排序时所能使用的缓冲区大小。注意-该参数对应的分配内存是每连接独占-如果有100个连接-那么实际分配的总共排序缓冲区大小为100×6-600MB。所以-对于内存在4GB左右的服务器推荐设置为6-8M。" class="headerlink" title="查询排序时所能使用的缓冲区大小。注意:该参数对应的分配内存是每连接独占!如果有100个连接,那么实际分配的总共排序缓冲区大小为100×6=600MB。所以,对于内存在4GB左右的服务器推荐设置为6-8M。"></a>查询排序时所能使用的缓冲区大小。注意:该参数对应的分配内存是每连接独占!如果有100个连接,那么实际分配的总共排序缓冲区大小为100×6=600MB。所以,对于内存在4GB左右的服务器推荐设置为6-8M。</h1><p>sort_buffer_size = 6M</p><h1 id="读查询操作所能使用的缓冲区大小。和sort-buffer-size一样-该参数对应的分配内存也是每连接独享"><a href="#读查询操作所能使用的缓冲区大小。和sort-buffer-size一样-该参数对应的分配内存也是每连接独享" class="headerlink" title="读查询操作所能使用的缓冲区大小。和sort_buffer_size一样,该参数对应的分配内存也是每连接独享!"></a>读查询操作所能使用的缓冲区大小。和sort_buffer_size一样,该参数对应的分配内存也是每连接独享!</h1><p>read_buffer_size = 4M</p><h1 id="这是一个重要变量。可以把这个值设为内存的70-80-。和key-buffer相同，如果数据量比较小也不怎么增加，那么不要把这个值设太高也可以提高内存的使用率"><a href="#这是一个重要变量。可以把这个值设为内存的70-80-。和key-buffer相同，如果数据量比较小也不怎么增加，那么不要把这个值设太高也可以提高内存的使用率" class="headerlink" title="这是一个重要变量。可以把这个值设为内存的70%-80%。和key_buffer相同，如果数据量比较小也不怎么增加，那么不要把这个值设太高也可以提高内存的使用率"></a>这是一个重要变量。可以把这个值设为内存的70%-80%。和key_buffer相同，如果数据量比较小也不怎么增加，那么不要把这个值设太高也可以提高内存的使用率</h1><p>innodb_buffer_pool_size = 4G</p><h1 id="这个的效果不是很明显，至少是当操作系统能合理分配内存时。但你可能仍需要设成20M或更多一点以看Innodb会分配多少内存做其他用途"><a href="#这个的效果不是很明显，至少是当操作系统能合理分配内存时。但你可能仍需要设成20M或更多一点以看Innodb会分配多少内存做其他用途" class="headerlink" title="这个的效果不是很明显，至少是当操作系统能合理分配内存时。但你可能仍需要设成20M或更多一点以看Innodb会分配多少内存做其他用途"></a>这个的效果不是很明显，至少是当操作系统能合理分配内存时。但你可能仍需要设成20M或更多一点以看Innodb会分配多少内存做其他用途</h1><p>innodb_additional_mem_pool_size = 512M</p><h1 id="对于写很多尤其是大数据量时非常重要。要注意，大的文件提供更高的性能，但数据库恢复时会用更多的时间。我一般用64M-512M，具体取决于服务器的空间。"><a href="#对于写很多尤其是大数据量时非常重要。要注意，大的文件提供更高的性能，但数据库恢复时会用更多的时间。我一般用64M-512M，具体取决于服务器的空间。" class="headerlink" title="对于写很多尤其是大数据量时非常重要。要注意，大的文件提供更高的性能，但数据库恢复时会用更多的时间。我一般用64M-512M，具体取决于服务器的空间。"></a>对于写很多尤其是大数据量时非常重要。要注意，大的文件提供更高的性能，但数据库恢复时会用更多的时间。我一般用64M-512M，具体取决于服务器的空间。</h1><p>innodb_log_file_size = 1G</p><h1 id="这是InnoDB存储引擎的事务日志所使用的缓冲区。类似于BinlogBuffer，在写事务日志的时候，为了提高性能，也是先将信息写入Buffer中，当满足相应条件才会写入。"><a href="#这是InnoDB存储引擎的事务日志所使用的缓冲区。类似于BinlogBuffer，在写事务日志的时候，为了提高性能，也是先将信息写入Buffer中，当满足相应条件才会写入。" class="headerlink" title="这是InnoDB存储引擎的事务日志所使用的缓冲区。类似于BinlogBuffer，在写事务日志的时候，为了提高性能，也是先将信息写入Buffer中，当满足相应条件才会写入。"></a>这是InnoDB存储引擎的事务日志所使用的缓冲区。类似于BinlogBuffer，在写事务日志的时候，为了提高性能，也是先将信息写入Buffer中，当满足相应条件才会写入。</h1><p>innodb_log_buffer_size = 256M</p><h1 id="参数设置表高速缓存的数目。每个连接进来，都会至少打开一个表缓存。因此，-table-cache-的大小应与-max-connections-的设置有关"><a href="#参数设置表高速缓存的数目。每个连接进来，都会至少打开一个表缓存。因此，-table-cache-的大小应与-max-connections-的设置有关" class="headerlink" title="参数设置表高速缓存的数目。每个连接进来，都会至少打开一个表缓存。因此， table_cache 的大小应与 max_connections 的设置有关"></a>参数设置表高速缓存的数目。每个连接进来，都会至少打开一个表缓存。因此， table_cache 的大小应与 max_connections 的设置有关</h1><p>table_cache = 512</p><h1 id="默认大小是-32M。如果一张临时表超出该大小，MySQL产生一个-The-table-tbl-name-is-full-形式的错误，如果你做很多高级-GROUP-BY查询，增加tmp-table-size-值"><a href="#默认大小是-32M。如果一张临时表超出该大小，MySQL产生一个-The-table-tbl-name-is-full-形式的错误，如果你做很多高级-GROUP-BY查询，增加tmp-table-size-值" class="headerlink" title="默认大小是 32M。如果一张临时表超出该大小，MySQL产生一个 The table tbl_name is full 形式的错误，如果你做很多高级 GROUP BY查询，增加tmp_table_size 值"></a>默认大小是 32M。如果一张临时表超出该大小，MySQL产生一个 The table tbl_name is full 形式的错误，如果你做很多高级 GROUP BY查询，增加tmp_table_size 值</h1><p>tmp_table_size = 256M</p><h1 id="指定MySQL允许的最大连接进程数。如果在访问论坛时经常出现Too-Many-Connections的错误提示-则需要增大该参数值"><a href="#指定MySQL允许的最大连接进程数。如果在访问论坛时经常出现Too-Many-Connections的错误提示-则需要增大该参数值" class="headerlink" title="指定MySQL允许的最大连接进程数。如果在访问论坛时经常出现Too Many Connections的错误提示,则需要增大该参数值"></a>指定MySQL允许的最大连接进程数。如果在访问论坛时经常出现Too Many Connections的错误提示,则需要增大该参数值</h1><p>max_connections = 768</p><h1 id="如果某个用户发起的连接error超过该数值，则该用户的下次连接将被阻塞，直到管理员执行flush-hosts-命令；防止黑客"><a href="#如果某个用户发起的连接error超过该数值，则该用户的下次连接将被阻塞，直到管理员执行flush-hosts-命令；防止黑客" class="headerlink" title="如果某个用户发起的连接error超过该数值，则该用户的下次连接将被阻塞，直到管理员执行flush hosts ; 命令；防止黑客"></a>如果某个用户发起的连接error超过该数值，则该用户的下次连接将被阻塞，直到管理员执行flush hosts ; 命令；防止黑客</h1><p>max_connect_errors = 10000</p><h1 id="指定一个请求的最大连接时间-对于4GB左右内存的服务器可以设置为5-10。"><a href="#指定一个请求的最大连接时间-对于4GB左右内存的服务器可以设置为5-10。" class="headerlink" title="指定一个请求的最大连接时间,对于4GB左右内存的服务器可以设置为5-10。"></a>指定一个请求的最大连接时间,对于4GB左右内存的服务器可以设置为5-10。</h1><p>wait_timeout = 10</p><h1 id="开启了Innodb的innodb-file-per-table这个参数之后-innodb-file-per-table-1-，也就是启用InnoDB的独立表空间模式，便于管理"><a href="#开启了Innodb的innodb-file-per-table这个参数之后-innodb-file-per-table-1-，也就是启用InnoDB的独立表空间模式，便于管理" class="headerlink" title="开启了Innodb的innodb_file_per_table这个参数之后[innodb_file_per_table = 1]，也就是启用InnoDB的独立表空间模式，便于管理"></a>开启了Innodb的innodb_file_per_table这个参数之后[innodb_file_per_table = 1]，也就是启用InnoDB的独立表空间模式，便于管理</h1><p>innodb_file_per_table</p><h1 id="首先需要大致了解一下mysql日志操作步骤："><a href="#首先需要大致了解一下mysql日志操作步骤：" class="headerlink" title="首先需要大致了解一下mysql日志操作步骤："></a>首先需要大致了解一下mysql日志操作步骤：</h1><h1 id="log-buff-–mysql写-write-–-gt-log-file-–OS刷新-flush-gt-disk"><a href="#log-buff-–mysql写-write-–-gt-log-file-–OS刷新-flush-gt-disk" class="headerlink" title="log_buff –mysql写 (write) –&gt; log_file –OS刷新 (flush)-&gt; disk"></a>log_buff –mysql写 (write) –&gt; log_file –OS刷新 (flush)-&gt; disk</h1><h1 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h1><h1 id="0（延迟写）：-log-buff-–每隔1秒–-gt-log-file-–实时-gt-disk"><a href="#0（延迟写）：-log-buff-–每隔1秒–-gt-log-file-–实时-gt-disk" class="headerlink" title="0（延迟写）： log_buff –每隔1秒–&gt; log_file –实时-&gt; disk"></a>0（延迟写）： log_buff –每隔1秒–&gt; log_file –实时-&gt; disk</h1><h1 id="1（实时写，实时刷）：-log-buff-–实时—-gt-log-file-–实时—-gt-disk"><a href="#1（实时写，实时刷）：-log-buff-–实时—-gt-log-file-–实时—-gt-disk" class="headerlink" title="1（实时写，实时刷）： log_buff –实时—&gt; log_file –实时—&gt; disk"></a>1（实时写，实时刷）： log_buff –实时—&gt; log_file –实时—&gt; disk</h1><h1 id="2（实时写，延迟刷）：-log-buff-–实时—-gt-log-file-–每隔1秒-gt-disk"><a href="#2（实时写，延迟刷）：-log-buff-–实时—-gt-log-file-–每隔1秒-gt-disk" class="headerlink" title="2（实时写，延迟刷）： log_buff –实时—&gt; log_file –每隔1秒-&gt; disk"></a>2（实时写，延迟刷）： log_buff –实时—&gt; log_file –每隔1秒-&gt; disk</h1><p>innodb_flush_log_at_trx_commit = 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">### 主从同步配置以及延迟备份</span><br><span class="line">1. 数据库的主主同步时需要设置自增长的两个相关配置：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;auto_increment_offset&#96;&#96;&#96;</span><br><span class="line">表示自增长字段从那个数开始，其默认值是1，取值范围是1..65535</span><br><span class="line">&#96;&#96;&#96;auto_increment_increment&#96;&#96;&#96;</span><br><span class="line">表示自增长字段每次递增的量，其默认值是1，取值范围是1..65535</span><br><span class="line"></span><br><span class="line">&gt;在主主同步配置时，需要将两台服务器的auto_increment_increment&#x3D;2，而要把auto_increment_offset分别配置为1和2，这样才可以避免两台服务器同时做更新时自增长字段的值之间发生冲突。</span><br><span class="line"></span><br><span class="line">2. 延迟备份</span><br><span class="line"></span><br><span class="line">Mysql （需5.6以上版本）延迟复制配置，通过设置Slave上的MASTER TO MASTER_DELAY参数实现：</span><br></pre></td></tr></table></figure><p>CHANGE MASTER TO MASTER_DELAY = N；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N为多少秒，该语句设置从数据库延时N秒后，再与主数据库进行数据同步复制</span><br><span class="line"></span><br><span class="line">具体操作：</span><br><span class="line"></span><br><span class="line">登陆到Slave数据库服务器</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mysql&gt;stop slave;<br>mysql&gt;CHANGE MASTER TO MASTER_DELAY = 600；<br>mysql&gt;start slave;<br>mysql&gt;show slave status \G;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查看SQL_Delay的值为600，表示设置成功。</span><br><span class="line"></span><br><span class="line">注释：</span><br><span class="line"></span><br><span class="line">SQL_Delay：一个非负整数，表示秒数，Slave滞后多少秒于master。</span><br><span class="line"></span><br><span class="line">SQL_Remaining_Delay：当Slave_SQL_Running_State等待，直到MASTER_DELAY秒后，Master执行的事件，此字段包含一个整数，表示有多少秒左右的延迟。在其他时候，这个字段是NULL。</span><br><span class="line"></span><br><span class="line">同步到指定位置：</span><br></pre></td></tr></table></figure><p>mysql&gt;STOP SLAVE;<br>mysql&gt;CHANGE MASTER TO MASTER_DELAY = 0, RELAY_LOG_FILE = ‘xxxxx-relay-bin.######’, RELAY_LOG_POS = ######;<br>mysql&gt;START SLAVE;</p><p>```</p><ol start="3"><li>数据库状态类型<ul><li>Aborted_clients 由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。 </li><li>Aborted_connects 尝试已经失败的MySQL服务器的连接的次数。 </li><li>Connections 试图连接MySQL服务器的次数。 </li><li>Created_tmp_tables 当执行语句时，已经被创造了的隐含临时表的数量。 </li><li>Delayed_insert_threads 正在使用的延迟插入处理器线程的数量。 </li><li>Delayed_writes 用INSERT DELAYED写入的行数。 </li><li>Delayed_errors 用INSERT DELAYED写入的发生某些错误(可能重复键值)的行数。 </li><li>Flush_commands 执行FLUSH命令的次数。 </li><li>Handler_delete 请求从一张表中删除行的次数。 </li><li>Handler_read_first 请求读入表中第一行的次数。 </li><li>Handler_read_key 请求数字基于键读行。 </li><li>Handler_read_next 请求读入基于一个键的一行的次数。 </li><li>Handler_read_rnd 请求读入基于一个固定位置的一行的次数。 </li><li>Handler_update 请求更新表中一行的次数。 </li><li>Handler_write 请求向表中插入一行的次数。 </li><li>Key_blocks_used 用于关键字缓存的块的数量。 </li><li>Key_read_requests 请求从缓存读入一个键值的次数。 </li><li>Key_reads 从磁盘物理读入一个键值的次数。 </li><li>Key_write_requests 请求将一个关键字块写入缓存次数。 </li><li>Key_writes 将一个键值块物理写入磁盘的次数。 </li><li>Max_used_connections 同时使用的连接的最大数目。 </li><li>Not_flushed_key_blocks 在键缓存中已经改变但是还没被清空到磁盘上的键块。 </li><li>Not_flushed_delayed_rows 在INSERT DELAY队列中等待写入的行的数量。 </li><li>Open_tables 打开表的数量。 </li><li>Open_files 打开文件的数量。 </li><li>Open_streams 打开流的数量(主要用于日志记载） </li><li>Opened_tables 已经打开的表的数量。 </li><li>Questions 发往服务器的查询的数量。 </li><li>Slow_queries 要花超过long_query_time时间的查询数量。 </li><li>Threads_connected 当前打开的连接的数量。 </li><li>Threads_running 不在睡眠的线程数量。 </li><li>Uptime 服务器工作了多少秒。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper知识点整理</title>
      <link href="2019/12/13/Zookeeper%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>2019/12/13/Zookeeper%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ZooKeeper 是一个开源的分布式协调服务，可以基于 ZooKeeper 实现诸如：数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、配置维护，名字服务、分布式同步、分布式锁和分布式队列等功能。</p></blockquote><h3 id="Zookeeper-的认识"><a href="#Zookeeper-的认识" class="headerlink" title="Zookeeper 的认识"></a>Zookeeper 的认识</h3><p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。<br>ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><h3 id="Zookeeper-都有哪些功能"><a href="#Zookeeper-都有哪些功能" class="headerlink" title="Zookeeper 都有哪些功能"></a>Zookeeper 都有哪些功能</h3><ol><li>集群管理：监控节点存活状态、运行请求等；</li><li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 Zookeeper 可以协助完成这个过程；</li><li>分布式锁：Zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。Zookeeper 可以对分布式锁进行控制。</li><li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li></ol><h3 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h3><p>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。<br>当整个 Zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。<br>当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。<br>Zookeeper 怎么保证主从节点的状态同步？<br>Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p><ol><li>恢复模式<br>当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</li><li>广播模式<br>一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。<br>这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。<br>ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。</li></ol><h3 id="Zookeeper-的部署模式"><a href="#Zookeeper-的部署模式" class="headerlink" title="Zookeeper 的部署模式"></a>Zookeeper 的部署模式</h3><p>Zookeeper 有三种部署模式：</p><ol><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群运行；</li><li>伪集群部署：一台集群启动多个 Zookeeper 实例运行。</li></ol><h3 id="Zookeeper-的通知机制"><a href="#Zookeeper-的通知机制" class="headerlink" title="Zookeeper 的通知机制"></a>Zookeeper 的通知机制</h3><p>client 端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 znode 变化来做出业务上的改变等。</p><h3 id="集群中为什么要有主节点"><a href="#集群中为什么要有主节点" class="headerlink" title="集群中为什么要有主节点"></a>集群中为什么要有主节点</h3><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 leader 选举。</p><h3 id="集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？"><a href="#集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？" class="headerlink" title="集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？"></a>集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？</h3><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。<br>集群规则为 2N+1 台，N &gt;0，即最少需要 3 台。</p><h3 id="两阶段提交和三阶段提交的过程分别有什么问题"><a href="#两阶段提交和三阶段提交的过程分别有什么问题" class="headerlink" title="两阶段提交和三阶段提交的过程分别有什么问题"></a>两阶段提交和三阶段提交的过程分别有什么问题</h3><h4 id="两阶段提交协议-2PC"><a href="#两阶段提交协议-2PC" class="headerlink" title="两阶段提交协议 2PC"></a>两阶段提交协议 2PC</h4><ol><li>第一阶段（投票阶段）：<br>（1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应；<br>（2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。<br>（3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li><li>第二阶段（提交执行阶段）：<br>当协调者节点从所有参与者节点获得的相应消息都为”同意”时：<br>（1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求；<br>（2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源；<br>（3）参与者节点向协调者节点发送”完成”消息；<br>（4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</li></ol><p>两阶段提交存在的问题：</p><ol><li>执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态；</li><li>参与者发生故障：协调者需要给每个参与者额外指定超时机制，超时后整个事务失败；</li><li>协调者发生故障：参与者会一直阻塞下去。需要额外的备机进行容错；</li><li>二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li></ol><h4 id="三阶段提交协议-3PC"><a href="#三阶段提交协议-3PC" class="headerlink" title="三阶段提交协议 3PC"></a>三阶段提交协议 3PC</h4><p>与两阶段提交不同的是，三阶段提交有两个改动点：</p><ol><li>引入超时机制。同时在协调者和参与者中都引入超时机制；</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ol><p>也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。</p><ol><li>CanCommit 阶段<br>3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。<br>（1）事务询问：协调者向参与者发送 CanCommit 请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。<br>（2）响应反馈：参与者接到 CanCommit 请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态。否则反馈 No。</li><li>PreCommit 阶段<br>协调者根据参与者的反应情况来决定是否可以继续事务的 PreCommit 操作。根据响应情况，有以下两种可能：<br>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。<br>（1）发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段。<br>（2）事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中。<br>（3）响应反馈：如果参与者成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。<br>假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。<br>（1）发送中断请求：协调者向所有参与者发送 abort 请求。<br>（2）中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li><li>doCommit 阶段<br>该阶段进行真正的事务提交，也可以分为以下两种情况。</li><li>1 执行提交<br>（1）发送提交请求：协调接收到参与者发送的 ACK 响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。<br>（2）事务提交：参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。<br>（3）响应反馈：事务提交完之后，向协调者发送 ACK 响应。<br>（4）完成事务：协调者接收到所有参与者的 ACK 响应之后，完成事务。</li><li>2 中断事务<br>协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。<br>（1）发送中断请求：协调者向所有参与者发送 abort 请求。<br>（2）事务回滚：参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。<br>（3）反馈结果：参与者完成事务回滚之后，向协调者发送 ACK 消息。<br>（4）中断事务：协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。<br>三阶段提交的问题：<br>网络分区可能会带来问题。需要四阶段解决：四阶段直接调用远程服务的数据状态，确定当前数据一致性的情况。</li></ol><h3 id="Zookeeper-宕机如何处理"><a href="#Zookeeper-宕机如何处理" class="headerlink" title="Zookeeper 宕机如何处理"></a>Zookeeper 宕机如何处理</h3><p>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。<br>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。<br>Zookeeper 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 Zookeeper 节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以：<br>3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票 &gt; 1.5)<br>2 个节点的 cluster 就不能挂掉任何1个节点了(leader 可以得到 1 票 &lt;= 1)</p><h3 id="说下四种类型的数据节点-Znode"><a href="#说下四种类型的数据节点-Znode" class="headerlink" title="说下四种类型的数据节点 Znode"></a>说下四种类型的数据节点 Znode</h3><ol><li>PERSISTENT：持久节点，除非手动删除，否则节点一直存在于 Zookeeper 上。</li><li>EPHEMERAL：临时节点，临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与 Zookeeper连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</li><li>PERSISTENT_SEQUENTIAL：持久顺序节点，基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li><li>EPHEMERAL_SEQUENTIAL：临时顺序节点，基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li></ol><h3 id="Zookeeper-和-Dubbo-的关系"><a href="#Zookeeper-和-Dubbo-的关系" class="headerlink" title="Zookeeper 和 Dubbo 的关系"></a>Zookeeper 和 Dubbo 的关系</h3><p>Dubbo 的将注册中心进行抽象，是得它可以外接不同的存储媒介给注册中心提供服务，有 ZooKeeper，Memcached，Redis 等。<br>引入了 ZooKeeper 作为存储媒介，也就把 ZooKeeper 的特性引进来。首先是负载均衡，单注册中心的承载能力是有限的，在流量达到一定程度的时 候就需要分流，负载均衡就是为了分流而存在的，一个 ZooKeeper 群配合相应的 Web 应用就可以很容易达到负载均衡；<br>资源同步，单单有负载均衡还不够，节点之间的数据和资源需要同步，ZooKeeper 集群就天然具备有这样的功能；<br>命名服务，将树状结构用于维护全局的服务地址列表，服务提供者在启动的时候，向 ZooKeeper 上的指定节点 <code>/dubbo/$&#123;serviceName&#125;/providers</code> 目录下写入自己的 URL 地址，这个操作就完成了服务的发布。 其他特性还有 Mast 选举，分布式锁等。</p>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之df</title>
      <link href="2019/10/24/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bdf/"/>
      <url>2019/10/24/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bdf/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。</p></blockquote><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">df [选项]... [FILE]...</span><br><span class="line">文件-a, --all 包含所有的具有 0 Blocks 的文件系统</span><br><span class="line">文件--block-size&#x3D;&#123;SIZE&#125; 使用 &#123;SIZE&#125; 大小的 Blocks</span><br><span class="line">文件-h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...)</span><br><span class="line">文件-H, --si 很像 -h, 但是用 1000 为单位而不是用 1024</span><br><span class="line">文件-i, --inodes 列出 inode 资讯，不列出已使用 block</span><br><span class="line">文件-k, --kilobytes 就像是 --block-size&#x3D;1024</span><br><span class="line">文件-l, --local 限制列出的文件结构</span><br><span class="line">文件-m, --megabytes 就像 --block-size&#x3D;1048576</span><br><span class="line">文件--no-sync 取得资讯前不 sync (预设值)</span><br><span class="line">文件-P, --portability 使用 POSIX 输出格式</span><br><span class="line">文件--sync 在取得资讯前 sync</span><br><span class="line">文件-t, --type&#x3D;TYPE 限制列出文件系统的 TYPE</span><br><span class="line">文件-T, --print-type 显示文件系统的形式</span><br><span class="line">文件-x, --exclude-type&#x3D;TYPE 限制列出文件系统不要显示 TYPE</span><br><span class="line">文件-v (忽略)</span><br><span class="line">文件--help 显示这个帮手并且离开</span><br><span class="line">文件--version 输出版本资讯并且离开</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li>显示文件系统的磁盘使用情况统计：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># df </span><br><span class="line">Filesystem     1K-blocks    Used     Available Use% Mounted on </span><br><span class="line">&#x2F;dev&#x2F;sda6       29640780 4320704     23814388  16%     &#x2F; </span><br><span class="line">udev             1536756       4     1536752    1%     &#x2F;dev </span><br><span class="line">tmpfs             617620     888     616732     1%     &#x2F;run </span><br><span class="line">none                5120       0     5120       0%     &#x2F;run&#x2F;lock </span><br><span class="line">none             1544044     156     1543888    1%     &#x2F;run&#x2F;shm </span><br></pre></td></tr></table></figure><p>第一列指定文件系统的名称，第二列指定一个特定的文件系统1K-块1K是1024字节为单位的总内存。用和可用列正在使用中，分别指定的内存量。</p><p>使用列指定使用的内存的百分比，而最后一栏”安装在”指定的文件系统的挂载点。</p><ul><li><code>df</code>可以显示磁盘使用的文件系统信息：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># df test </span><br><span class="line">Filesystem     1K-blocks    Used      Available Use% Mounted on </span><br><span class="line">&#x2F;dev&#x2F;sda6       29640780    4320600   23814492  16%       &#x2F; </span><br></pre></td></tr></table></figure><ul><li>用一个<code>-i</code>选项的<code>df</code>命令的输出显示inode信息而非块使用量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df -i </span><br><span class="line">Filesystem      Inodes    IUsed    IFree     IUse% Mounted on </span><br><span class="line">&#x2F;dev&#x2F;sda6      1884160    261964   1622196   14%        &#x2F; </span><br><span class="line">udev           212748     560      212188    1%         &#x2F;dev </span><br><span class="line">tmpfs          216392     477      215915    1%         &#x2F;run </span><br><span class="line">none           216392     3        216389    1%         &#x2F;run&#x2F;lock </span><br><span class="line">none           216392     8        216384    1%         &#x2F;run&#x2F;shm </span><br></pre></td></tr></table></figure><ul><li>显示所有的信息:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># df --total </span><br><span class="line">Filesystem     1K-blocks    Used    Available Use% Mounted on </span><br><span class="line">&#x2F;dev&#x2F;sda6       29640780 4320720    23814372  16%     &#x2F; </span><br><span class="line">udev             1536756       4    1536752   1%      &#x2F;dev </span><br><span class="line">tmpfs             617620     892    616728    1%      &#x2F;run </span><br><span class="line">none                5120       0    5120      0%      &#x2F;run&#x2F;lock </span><br><span class="line">none             1544044     156    1543888   1%      &#x2F;run&#x2F;shm </span><br><span class="line">total           33344320 4321772    27516860  14% </span><br></pre></td></tr></table></figure><p>我们看到输出的末尾，包含一个额外的行，显示总的每一列。</p><ul><li><code>-h</code>选项，通过它可以产生可读的格式<code>df</code>命令的输出：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># df -h </span><br><span class="line">Filesystem      Size  Used   Avail Use% Mounted on </span><br><span class="line">&#x2F;dev&#x2F;sda6       29G   4.2G   23G   16%     &#x2F; </span><br><span class="line">udev            1.5G  4.0K   1.5G   1%     &#x2F;dev </span><br><span class="line">tmpfs           604M  892K   603M   1%     &#x2F;run </span><br><span class="line">none            5.0M     0   5.0M   0%     &#x2F;run&#x2F;lock </span><br><span class="line">none            1.5G  156K   1.5G   1%     &#x2F;run&#x2F;shm </span><br></pre></td></tr></table></figure><p>可以看到输出显示的数字形式的’G’（千兆字节），”M”（兆字节）和”K”（千字节）。</p><p>这使输出容易阅读和理解，从而使显示可读的。请注意，第二列的名称也发生了变化，为了使显示可读的”大小”。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Error:SHA256 mismatch</title>
      <link href="2019/10/14/Error-SHA256-mismatch/"/>
      <url>2019/10/14/Error-SHA256-mismatch/</url>
      
        <content type="html"><![CDATA[<p>用<code>brewhome</code>安装<code>websocketd</code> 报错(<code>brew install websocketd</code>)<br>错误内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;commit&#x2F;1a92cdbfc10e0c66f2e015264a39159c055a5c15.patch?full_index&#x3D;1</span><br><span class="line">Error: SHA256 mismatch</span><br><span class="line">Expected: 9b879e3e759d56093ca7660305c3e4f8aee8acdd87126dc10985360395704139</span><br><span class="line">Actual: 78548296476b0281fe1cea95a85f8055aa0ecae138b8a1fb3b466eed02c10cb8</span><br><span class="line">Archive: &#x2F;Users&#x2F;xx&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;go--patch-9b879e3e759d56093ca7660305c3e4f8aee8acdd87126dc10985360395704139.patch</span><br><span class="line">To retry an incomplete download, remove the file above.</span><br></pre></td></tr></table></figure><p>可以看到是在安装go补丁时候报的<code>SHA256</code>错误，这个错误可以理解成拉取时候验签错误，错误信息中给出了预期值（Expected）与实际值（Actual）并给出了解决办法</p><p>燃鹅这个retry并不好用，在网上搜了下<a href="https://github.com/caskformula/homebrew-caskformula/issues/57">类似错误</a>，给出的处理办法是用实际值替换预期值即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 搜索出来的解决办法</span><br><span class="line">使用brew edit caskformula&#x2F;caskformula&#x2F;inkscape</span><br><span class="line"></span><br><span class="line">替换1f037cc29cee8e0c60ab4753d4151741c8170e4849129bac68fdc60925eb971d 为 7ce4f70f1cb03cd0bab7dc94821a89bf71600bd59c763ae0d78c48f33db3d9ac</span><br></pre></td></tr></table></figure><p>解决方法</p><ol><li><code>brew edit go</code></li><li>替换<code>9b879e3e759d56093ca7660305c3e4f8aee8acdd87126dc10985360395704139</code>为<code>9b879e3e759d56093ca7660305c3e4f8aee8acdd87126dc10985360395704139</code></li><li>重新<code>brew install websocketd</code></li></ol><p>搞定～</p>]]></content>
      
      
      <categories>
          
          <category> brewhome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> brewhome install 错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之chmod</title>
      <link href="2019/09/24/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bchmod/"/>
      <url>2019/09/24/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bchmod/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以控制文件如何被他人所调用。</p></blockquote><h4 id="使用权限-所有使用者"><a href="#使用权限-所有使用者" class="headerlink" title="使用权限 : 所有使用者"></a>使用权限 : 所有使用者</h4><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-cfvR] [--help] [--version] mode file...</span><br></pre></td></tr></table></figure><ul><li>参数说明<br>mode : 权限设定字串，格式如下 :</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ugoa...][[+-&#x3D;][rwxX]...][,...]</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># ugoa</span><br><span class="line">u 表示该文件的拥有者</span><br><span class="line">g 表示与该文件的拥有者属于同一个群体(group)者</span><br><span class="line">o 表示其他以外的人</span><br><span class="line">a 表示这三者皆是</span><br><span class="line"># +-&#x3D;</span><br><span class="line">+ 表示增加权限</span><br><span class="line">- 表示取消权限</span><br><span class="line">&#x3D; 表示唯一设定权限</span><br><span class="line"># rwxX</span><br><span class="line">r 表示可读取</span><br><span class="line">w 表示可写入</span><br><span class="line">x 表示可执行</span><br><span class="line">X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行</span><br></pre></td></tr></table></figure><ul><li>其他参数说明：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c : 若该文件权限确实已经更改，才显示其更改动作</span><br><span class="line">-f : 若该文件权限无法被更改也不要显示错误讯息</span><br><span class="line">-v : 显示权限变更的详细资料</span><br><span class="line">-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</span><br><span class="line">--help : 显示辅助说明</span><br><span class="line">--version : 显示版本</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li>将文件 <code>file.txt</code> 设为所有人皆可读取 :</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r file.txt</span><br></pre></td></tr></table></figure><ul><li>将文件 <code>file1.txt</code> 设为所有人皆可读取 :</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r file1.txt</span><br></pre></td></tr></table></figure><ul><li>将文件 <code>file1.txt</code> 与 <code>file2.txt</code> 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure><ul><li>将 <code>ex1.py</code> 设定为只有该文件拥有者可以执行 :</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x ex1.py</span><br></pre></td></tr></table></figure><ul><li>将目前目录下的所有文件与子目录皆设为任何人可读取 :</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+r *</span><br></pre></td></tr></table></figure><h4 id="chmod也可以用数字来表示权限如"><a href="#chmod也可以用数字来表示权限如" class="headerlink" title="chmod也可以用数字来表示权限如 :"></a><code>chmod</code>也可以用数字来表示权限如 :</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chmod a&#x3D;rwx file 与以下渔具效果相同</span><br><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure><p>语法为：<code>chmod abc file</code>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r&#x3D;4，w&#x3D;2，x&#x3D;1</span><br><span class="line">若要rwx属性则4+2+1&#x3D;7；</span><br><span class="line">若要rw-属性则4+2&#x3D;6；</span><br><span class="line">若要r-x属性则4+1&#x3D;5。</span><br></pre></td></tr></table></figure><p><code>chmod ug=rwx,o=x file</code>和<code>chmod 771 file</code>效果相同</p><p>若用<code>chmod 4755 filename</code>可使此程序具有root的权限</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http状态码</title>
      <link href="2019/09/02/http%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>2019/09/02/http%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td></tr><tr><td>101</td><td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td></tr><tr><td>102</td><td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td></tr><tr><td>200</td><td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td></tr><tr><td>201</td><td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td></tr><tr><td>202</td><td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td></tr><tr><td>203</td><td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td></tr><tr><td>204</td><td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td></tr><tr><td>205</td><td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td></tr><tr><td>206</td><td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td></tr><tr><td>207</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td>300</td><td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td>301</td><td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td></tr><tr><td>302</td><td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td></tr><tr><td>303</td><td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td></tr><tr><td>304</td><td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td></tr><tr><td>305</td><td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td></tr><tr><td>306</td><td>在最新版的规范中，306状态码已经不再被使用。</td></tr><tr><td>307</td><td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td>400</td><td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。</td></tr><tr><td>401</td><td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td></tr><tr><td>402</td><td>该状态码是为了将来可能的需求而预留的。</td></tr><tr><td>403</td><td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td>404</td><td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td>405</td><td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td>406</td><td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td>407</td><td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td></tr><tr><td>408</td><td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td>409</td><td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td></tr><tr><td>410</td><td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td></tr><tr><td>411</td><td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td></tr><tr><td>412</td><td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td>413</td><td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td>414</td><td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td></tr><tr><td>415</td><td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td></tr><tr><td>416</td><td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td></tr><tr><td>417</td><td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td></tr><tr><td>421</td><td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td>422</td><td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td>422</td><td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）</td></tr><tr><td>424</td><td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td></tr><tr><td>425</td><td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td></tr><tr><td>426</td><td>客户端应当切换到TLS/1.0。（RFC 2817）</td></tr><tr><td>449</td><td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td></tr><tr><td>500</td><td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td></tr><tr><td>501</td><td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td></tr><tr><td>502</td><td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td>503</td><td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td></tr><tr><td>504</td><td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td></tr><tr><td>505</td><td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td>506</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td>507</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td>509</td><td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td>510</td><td>获取资源所需要的策略并没有没满足。（RFC 2774）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composer 版本号前置~与^符号的区别</title>
      <link href="2019/08/16/composer-%E7%89%88%E6%9C%AC%E5%8F%B7%E5%89%8D%E7%BD%AE-%E4%B8%8E-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2019/08/16/composer-%E7%89%88%E6%9C%AC%E5%8F%B7%E5%89%8D%E7%BD%AE-%E4%B8%8E-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><code>~</code>和<code>^</code>的意思很接近，在<code>x.y</code>的情况下是一样的都是代表<code>x.y &lt;= 版本号 &lt; (x+1).0</code>，但是在版本号是x.y.z的情况下有区别，举个例子：</p><ul><li><code>~1.2.3</code> 代表 <code>1.2.3 &lt;= 版本号 &lt; 1.3.0</code></li><li><code>^1.2.3</code> 代表 <code>1.2.3 &lt;= 版本号 &lt; 2.0.0</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> MAC使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHPExcel_Shared_Font不存在问题</title>
      <link href="2019/08/07/PHPExcel-Shared-Font%E4%B8%8D%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/"/>
      <url>2019/08/07/PHPExcel-Shared-Font%E4%B8%8D%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>由于昨天手残操作了下<code>git clean -xdf</code>导致本地配置文件都被干掉了，程序跑不起来，今天下午抽了点儿时间调了调。环境配置为<code>php 7.0 laravel 5.4</code>，composer.json 中 excel配置为<code>&quot;maatwebsite/excel&quot;: &quot;~2.1.0&quot;,</code></p><p>问题：<code>composer update</code> 时报<code>Class &#39;PHPExcel_Shared_Font&#39; not found</code></p><ol><li><p>搜索引擎查错误</p><p>查stackoverflow 得到结果如下 <a href="https://stackoverflow.com/questions/31760829/composer-update-error-with-laravel-5-phpexcel-shared-font-not-found">点击跳转</a></p><p>需要 删除 <code>config/excel.php</code> 然后重新发布<code>php artisan vendor:publish --provider=Maatwebsite\Excel\ExcelServiceProvider</code>  试了下，删除 <code>config/excel.php</code>后，重新发布，依然会报错</p></li><li><p>第二步在github查了下<code>maatwebsite/excel</code> 发现 <a href="https://github.com/eveseat/seat/issues/1654">issues</a>，分析得，<code>maatwebsite/excel</code>从2.1往上升级时候会造成这个问题，原因是2.1里用了PHPExcel，而包<code>phpoffice/phpexcel</code>被放弃，应该使用<code>phpoffice/phpspreadsheet</code>代替。这种情况可以用第一步中的方法解决。既然这样，咱们就看下<code>phpoffice/phpexcel</code>里的东西</p></li><li><p>在github上找到<code>phpoffice/phpexcel</code>，然后搜了下<code>PHPExcel_Shared_Font</code> <a href="https://github.com/PHPOffice/PHPExcel/search?q=PHPExcel_Shared_Font&unscoped_q=PHPExcel_Shared_Font">点击跳转</a>，发现这个类文件在 <code>vendor/phpoffice/phpexcel/Classes/PHPExcel/Shared/Font.php</code> 本地找了找，没有。那就好办了，没啥就下载啥就行了。在自己的项目里新建了Font.php, <a href="https://github.com/PHPOffice/PHPExcel/blob/c269793ee715fb5a15f0b2ad25c064d9ee6e8e53/Classes/PHPExcel/Shared/Font.php">文件内容</a> 。然后再运行<code>composer update -vvv</code>，搞定</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu14.04设置网络代理</title>
      <link href="2019/07/30/Ubuntu14-04%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"/>
      <url>2019/07/30/Ubuntu14-04%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ubuntu下apt-get的网络代理设置（终端命令行的网络代理设置）</p></blockquote><p>新立得软件管理器这种图形化的代理设置很明了，这里介绍下终端命令行的网络代理设置，这样大家就可以通过代理进行apt-get了。</p><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>　　如果只是想临时使用http代理，可以在使用apt-get之前于终端下输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy&#x3D;&quot;http:&#x2F;&#x2F;用户名:密码@代理IP:代理端口&quot;</span><br></pre></td></tr></table></figure><h4 id="方法二：（方法一的持久化）"><a href="#方法二：（方法一的持久化）" class="headerlink" title="方法二：（方法一的持久化）"></a>方法二：（方法一的持久化）</h4><p>　　如果希望apt-get与其它应用程序都可以一直使用http代理，可以这样： </p><p>　　在终端下编辑~/.bashrc文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bashrc</span><br><span class="line">&#x2F;&#x2F;在文件末尾添加如下两句：</span><br><span class="line">http_proxy&#x3D;&quot;http:&#x2F;&#x2F;用户名:密码@代理地址:代理端口&quot;</span><br><span class="line">export http_proxy</span><br></pre></td></tr></table></figure><h4 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h4><p>　　如果只是希望apt-get使用代理，可以这样：</p><p>　　在终端下编辑<code>/etc/apt/apt.conf</code>加入下面这行，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Acquire::http::Proxy &quot;http:&#x2F;&#x2F;yourproxyaddress:proxyport&quot;;</span><br></pre></td></tr></table></figure><p>　　保存退出apt.conf。</p><h4 id="四：如果是Redhat-Linux，则在profile文件中设置相关环境变量"><a href="#四：如果是Redhat-Linux，则在profile文件中设置相关环境变量" class="headerlink" title="四：如果是Redhat Linux，则在profile文件中设置相关环境变量"></a>四：如果是Redhat Linux，则在profile文件中设置相关环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line">http_proxy&#x3D;http:&#x2F;&#x2F;用户名:密码@代理服务器地址:端口</span><br></pre></td></tr></table></figure><p>　　这样在终端下便可以通过代理上网了</p>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP命令行脚本接收参数的方法</title>
      <link href="2019/05/18/PHP%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>2019/05/18/PHP%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近看python脚本，传参很方便。就查了查PHP脚本如何接受参数，发现有三种方式，记录一下</p></blockquote><h4 id="使用-argv-or-argc对参数进行接收"><a href="#使用-argv-or-argc对参数进行接收" class="headerlink" title="使用$argv or $argc对参数进行接收"></a>使用<code>$argv</code> or <code>$argc</code>对参数进行接收</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>$argv — 传递给脚本的参数数组，$argc - 参数数量 注意会包含脚本文件名</p><blockquote><p>第一个参数总是当前脚本的文件名，因此 $argv[0] 就是脚本文件名<br>这个变量仅在 register_argc_argv 打开时可用。可以使用 <code>php -i|grep register_argc_argv</code>查看是否为on</p></blockquote><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><ol><li>脚本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">var_dump($argv);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>命令行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php script.php arg1 arg2 arg3</span><br></pre></td></tr></table></figure><ol start="3"><li>结果输出</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array(4) &#123;</span><br><span class="line">  [0]&#x3D;&gt;</span><br><span class="line">  string(10) &quot;script.php&quot;</span><br><span class="line">  [1]&#x3D;&gt;</span><br><span class="line">  string(4) &quot;arg1&quot;</span><br><span class="line">  [2]&#x3D;&gt;</span><br><span class="line">  string(4) &quot;arg2&quot;</span><br><span class="line">  [3]&#x3D;&gt;</span><br><span class="line">  string(4) &quot;arg3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用getopt函数"><a href="#使用getopt函数" class="headerlink" title="使用getopt函数"></a>使用<code>getopt</code>函数</h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>getopt — 从命令行参数列表中获取选项<br>通用命令格式 <code>getopt ( string $options [, array $longopts [, int &amp;$optind ]] ) : array</code></p><ul><li>options 该字符串中的每个字符会被当做选项字符，匹配传入脚本的选项以单个连字符(-)开头。 比如，一个选项字符串 “x” 识别了一个选项 -x。 只允许 a-z、A-Z 和 0-9</li><li>longopts 选项数组。此数组中的每个元素会被作为选项字符串，匹配了以两个连字符(–)传入到脚本的选项。 例如，长选项元素 “opt” 识别了一个选项 –opt</li><li>optind 如果optind参数存在，则停止参数解析的索引将被写入该变量</li></ul><p>options 可能包含了以下元素</p><ul><li>单独的字符（不接受值）</li><li>后面跟随冒号的字符（此选项需要值）</li><li>后面跟随两个冒号的字符（此选项的值可选）</li><li>选项的值不接受空格作为分隔符</li></ul><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><ol><li>脚本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; Script example.php</span><br><span class="line">$options &#x3D; getopt(&quot;f:hp:&quot;);</span><br><span class="line">var_dump($options);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>命令行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php example.php -fvalue -h</span><br></pre></td></tr></table></figure><ol start="3"><li>输出</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array(2) &#123;</span><br><span class="line">  [&quot;f&quot;]&#x3D;&gt;</span><br><span class="line">  string(5) &quot;value&quot;</span><br><span class="line">  [&quot;h&quot;]&#x3D;&gt;</span><br><span class="line">  bool(false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用STDOUT与STDIN提示用户输入"><a href="#使用STDOUT与STDIN提示用户输入" class="headerlink" title="使用STDOUT与STDIN提示用户输入"></a>使用<code>STDOUT</code>与<code>STDIN</code>提示用户输入</h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>stdin    标准的输入设备<br>stdout    标准的输出设备<br>stderr    标准的错误设备</p><blockquote><p>fwrite()函数首先会向标准的输出设备写一条消息，询问用户输入。然后它会把从标准输入设备获得的用户输入信息读取到一个php变量里，并它把合并成为一个字符串。然后就用fwrite()把这个字符串打印输出到标准的输出设备上</p></blockquote><h5 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h5><ol><li>脚本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">fwrite(STDOUT, &#39;请输入开始时间：&#39;);</span><br><span class="line">$start &#x3D; fgets(STDIN);</span><br><span class="line">echo &quot;开始时间为：&#123;$start&#125;\n&quot;;</span><br><span class="line">fwrite(STDOUT, &#39;请输入结束时间：&#39;);</span><br><span class="line">$end &#x3D; fgets(STDIN);</span><br><span class="line">echo &quot;结束时间为：&#123;$end&#125;\n&quot;;</span><br><span class="line">var_dump([$start, $end]);</span><br></pre></td></tr></table></figure><ol start="2"><li>命令行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php script.php</span><br></pre></td></tr></table></figure><ol start="3"><li>结果输出</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">请输入开始时间：11111</span><br><span class="line">开始时间为：11111</span><br><span class="line"></span><br><span class="line">请输入结束时间：22222</span><br><span class="line">结束时间为：22222</span><br><span class="line"></span><br><span class="line">&quot;11111\n&quot;</span><br><span class="line">&quot;22222\n&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之rmdir</title>
      <link href="2019/04/30/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Brmdir/"/>
      <url>2019/04/30/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Brmdir/</url>
      
        <content type="html"><![CDATA[<blockquote><p>rmdir从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限</p></blockquote><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [选项] 目录</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- p #递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 </span><br><span class="line">-v, --verbose #显示指令执行过程 </span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li>rmdir不能删除非空目录</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir doc #rmdir 目录名 命令不能直接删除非空目录</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost scf]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">|-- bin</span><br><span class="line">|-- doc</span><br><span class="line">|   |-- info</span><br><span class="line">|   `-- product</span><br><span class="line">|-- lib</span><br><span class="line">|-- logs</span><br><span class="line">|   |-- info</span><br><span class="line">|   `-- product</span><br><span class="line">`-- service</span><br><span class="line">    `-- deploy</span><br><span class="line">        |-- info</span><br><span class="line">        `-- product</span><br><span class="line"> </span><br><span class="line">        12 directories, 0 files</span><br><span class="line">[root@localhost scf]<span class="comment"># rmdir doc</span></span><br><span class="line">rmdir: doc: 目录非空</span><br><span class="line">[root@localhost scf]<span class="comment"># rmdir doc/info</span></span><br><span class="line">[root@localhost scf]<span class="comment"># rmdir doc/product</span></span><br><span class="line">[root@localhost scf]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">|-- bin</span><br><span class="line">|-- doc</span><br><span class="line">|-- lib</span><br><span class="line">|-- logs</span><br><span class="line">|   |-- info</span><br><span class="line">|   `-- product</span><br><span class="line">`-- service</span><br><span class="line">    `-- deploy</span><br><span class="line">        |-- info</span><br><span class="line">        `-- product</span><br><span class="line"> </span><br><span class="line">        10 directories, 0 files</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>rmdir -p 当子目录被删除后使它也成为空目录的话，则顺便一并删除</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir -p logs</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost scf]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">|-- bin</span><br><span class="line">|-- doc</span><br><span class="line">|-- lib</span><br><span class="line">|-- logs</span><br><span class="line">|   `-- product</span><br><span class="line">`-- service</span><br><span class="line">    `-- deploy</span><br><span class="line">        |-- info</span><br><span class="line">        `-- product</span><br><span class="line"> </span><br><span class="line">        10 directories, 0 files</span><br><span class="line">[root@localhost scf]<span class="comment"># rmdir -p logs</span></span><br><span class="line">rmdir: logs: 目录非空</span><br><span class="line">[root@localhost scf]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">|-- bin</span><br><span class="line">|-- doc</span><br><span class="line">|-- lib</span><br><span class="line">|-- logs</span><br><span class="line">|   `-- product</span><br><span class="line">`-- service</span><br><span class="line">    `-- deploy</span><br><span class="line">        |-- info</span><br><span class="line">        `-- product</span><br><span class="line"> </span><br><span class="line">        9 directories, 0 files</span><br><span class="line">[root@localhost scf]<span class="comment"># rmdir -p logs/product</span></span><br><span class="line">[root@localhost scf]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">|-- bin</span><br><span class="line">|-- doc</span><br><span class="line">|-- lib</span><br><span class="line">`-- service</span><br><span class="line">`-- deploy</span><br><span class="line">        |-- info</span><br><span class="line">        `-- product</span><br><span class="line"> </span><br><span class="line">        7 directories, 0 files</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之rm</title>
      <link href="2019/04/30/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Brm/"/>
      <url>2019/04/30/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Brm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状</p></blockquote><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-f, --force#强制删除，不再二次确认，忽略文件不存在的错误。</span><br><span class="line">-i, --interactive#进行交互式删除</span><br><span class="line">-r, -R, --recursive#指示rm将参数中列出的全部目录和子目录均递归地删除。</span><br><span class="line">-v, --verbose#详细显示进行的步骤</span><br><span class="line">--help#显示此帮助信息并退出</span><br><span class="line">--version#输出版本信息并退出</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li>删除文件file，系统会先询问是否删除</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm 文件名 #二次确认时，输入y后就会删除文件，不想删除则数据n</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test1]<span class="comment"># ll</span></span><br><span class="line">总计 4</span><br><span class="line">-rw-r--r-- 1 root root 56 10-26 14:31 log.log</span><br><span class="line">root@localhost test1]<span class="comment"># rm log.log </span></span><br><span class="line">rm：是否删除 一般文件 “log.log”? y</span><br><span class="line">root@localhost test1]<span class="comment"># ll</span></span><br><span class="line">总计 0</span><br><span class="line">[root@localhost test1]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>强行删除file，系统不再提示</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f log1.log</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test1]<span class="comment"># ll</span></span><br><span class="line">总计 4</span><br><span class="line">-rw-r--r-- 1 root root 23 10-26 14:40 log1.log</span><br><span class="line">[root@localhost test1]<span class="comment"># rm -f log1.log </span></span><br><span class="line">[root@localhost test1]<span class="comment"># ll</span></span><br><span class="line">总计 0</span><br><span class="line">[root@localhost test1]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>将test1子目录及子目录中所有档案删除</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r test1</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ll</span></span><br><span class="line">总计 24drwxr-xr-x 7 root root 4096 10-25 18:07 scf</span><br><span class="line">drwxr-xr-x 2 root root 4096 10-26 14:51 test1</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:44 test2</span><br><span class="line">drwxrwxrwx 2 root root 4096 10-25 17:46 test3</span><br><span class="line">drwxr-xr-x 2 root root 4096 10-25 17:56 test4</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:56 test5</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># rm -r test1</span></span><br><span class="line">rm：是否进入目录 “test1”? y</span><br><span class="line">rm：是否删除 一般文件 “test1/log3.log”? y</span><br><span class="line">rm：是否删除 目录 “test1”? y</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ll</span></span><br><span class="line">总计 20drwxr-xr-x 7 root root 4096 10-25 18:07 scf</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:44 test2</span><br><span class="line">drwxrwxrwx 2 root root 4096 10-25 17:46 test3</span><br><span class="line">drwxr-xr-x 2 root root 4096 10-25 17:56 test4</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:56 test5</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>将test1子目录及子目录中所有档案删除 并不需要二次确认</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf test1</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ll</span></span><br><span class="line">总计 24drwxr-xr-x 7 root root 4096 10-25 18:07 scf</span><br><span class="line">drwxr-xr-x 2 root root 4096 10-26 14:51 test1</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:44 test2</span><br><span class="line">drwxrwxrwx 2 root root 4096 10-25 17:46 test3</span><br><span class="line">drwxr-xr-x 2 root root 4096 10-25 17:56 test4</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:56 test5</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># rm -r test1</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ll</span></span><br><span class="line">总计 20drwxr-xr-x 7 root root 4096 10-25 18:07 scf</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:44 test2</span><br><span class="line">drwxrwxrwx 2 root root 4096 10-25 17:46 test3</span><br><span class="line">drwxr-xr-x 2 root root 4096 10-25 17:56 test4</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:56 test5</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>-f为强制命令，若需要删除以-f开头的文件</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -- -f</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># touch -- -f</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ls -- -f</span></span><br><span class="line">-f</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># rm -- -f</span></span><br><span class="line">rm：是否删除 一般空文件 “-f”? y</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ls -- -f</span></span><br><span class="line">ls: -f: 没有那个文件或目录</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># touch ./-f</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ls ./-f</span></span><br><span class="line">./-f</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># rm ./-f</span></span><br><span class="line">rm：是否删除 一般空文件 “./-f”? y</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li>自定义回收站功能</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myrm()&#123; D&#x3D;&#x2F;tmp&#x2F;$(date +%Y%m%d%H%M%S); mkdir -p $D; mv &quot;$@&quot; $D &amp;&amp; echo &quot;moved to $D ok&quot;; &#125;</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># myrm()&#123; D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv &quot;$@&quot; $D &amp;&amp; echo &quot;moved to $D ok&quot;; &#125;</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># alias rm=&#x27;myrm&#x27;</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># touch 1.log 2.log 3.log</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ll</span></span><br><span class="line">总计 16</span><br><span class="line">-rw-r--r-- 1 root root    0 10-26 15:08 1.log</span><br><span class="line">-rw-r--r-- 1 root root    0 10-26 15:08 2.log</span><br><span class="line">-rw-r--r-- 1 root root    0 10-26 15:08 3.log</span><br><span class="line">drwxr-xr-x 7 root root 4096 10-25 18:07 scf</span><br><span class="line">drwxrwxrwx 2 root root 4096 10-25 17:46 test3</span><br><span class="line">drwxr-xr-x 2 root root 4096 10-25 17:56 test4</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:56 test5</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># rm [123].log</span></span><br><span class="line">moved to /tmp/20121026150901 ok</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ll</span></span><br><span class="line">总计 16drwxr-xr-x 7 root root 4096 10-25 18:07 scf</span><br><span class="line">drwxrwxrwx 2 root root 4096 10-25 17:46 test3</span><br><span class="line">drwxr-xr-x 2 root root 4096 10-25 17:56 test4</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:56 test5</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ls /tmp/20121026150901/</span></span><br><span class="line">1.log  2.log  3.log</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之mkdir</title>
      <link href="2019/04/30/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bmkdir/"/>
      <url>2019/04/30/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bmkdir/</url>
      
        <content type="html"><![CDATA[<blockquote><p>mkdir 命令用来创建指定的名称的目录，要求当前目录中具有写权限，并且创建的目录名不能与已有的目录重名</p></blockquote><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项] 目录</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-m, --mode&#x3D;模式# 设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask</span><br><span class="line">-p, --parents# 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多层目录</span><br><span class="line">-v, --verbose#每次创建新目录都显示信息</span><br><span class="line">--help#显示此帮助信息并退出</span><br><span class="line">--version#输出版本信息并退出</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li>创建一个空目录</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir test1</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost soft]<span class="comment"># cd test</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># mkdir test1</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ll</span></span><br><span class="line">总计 4drwxr-xr-x 2 root root 4096 10-25 17:42 test1</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>递归创建多个目录</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p test2&#x2F;test22</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># mkdir -p test2/test22</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ll</span></span><br><span class="line">总计 8drwxr-xr-x 2 root root 4096 10-25 17:42 test1</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:44 test2</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># cd test2/</span></span><br><span class="line">[root@localhost test2]<span class="comment"># ll</span></span><br><span class="line">总计 4drwxr-xr-x 2 root root 4096 10-25 17:44 test22</span><br><span class="line">[root@localhost test2]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>创建权限为777的目录</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -m 777 test3</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># mkdir -m 777 test3</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ll</span></span><br><span class="line">总计 12drwxr-xr-x 2 root root 4096 10-25 17:42 test1</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:44 test2</span><br><span class="line">drwxrwxrwx 2 root root 4096 10-25 17:46 test3</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>创建新目录都显示信息</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -v test4</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># mkdir -v test4</span></span><br><span class="line">mkdir: 已创建目录 “test4”</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># mkdir -vp test5/test5-1</span></span><br><span class="line">mkdir: 已创建目录 “test5”</span><br><span class="line">mkdir: 已创建目录 “test5/test5-1”</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>一个命令创建项目的目录结构</li></ol><ul><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -vp scf&#x2F;&#123;lib&#x2F;,bin&#x2F;,doc&#x2F;&#123;info,product&#125;,logs&#x2F;&#123;info,product&#125;,service&#x2F;deploy&#x2F;&#123;info,product&#125;&#125; #&#x2F; 后的&#123;&#125;表示下一层目录  ,号表示同级目录</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># mkdir -vp scf/&#123;lib/,bin/,doc/&#123;info,product&#125;,logs/&#123;info,product&#125;,service/deploy/&#123;info,product&#125;&#125;</span></span><br><span class="line">mkdir: 已创建目录 “scf”</span><br><span class="line">mkdir: 已创建目录 “scf/lib”</span><br><span class="line">mkdir: 已创建目录 “scf/bin”</span><br><span class="line">mkdir: 已创建目录 “scf/doc”</span><br><span class="line">mkdir: 已创建目录 “scf/doc/info”</span><br><span class="line">mkdir: 已创建目录 “scf/doc/product”</span><br><span class="line">mkdir: 已创建目录 “scf/logs”</span><br><span class="line">mkdir: 已创建目录 “scf/logs/info”</span><br><span class="line">mkdir: 已创建目录 “scf/logs/product”</span><br><span class="line">mkdir: 已创建目录 “scf/service”</span><br><span class="line">mkdir: 已创建目录 “scf/service/deploy”</span><br><span class="line">mkdir: 已创建目录 “scf/service/deploy/info”</span><br><span class="line">mkdir: 已创建目录 “scf/service/deploy/product”</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># tree scf/</span></span><br><span class="line">scf/</span><br><span class="line">|-- bin</span><br><span class="line">|-- doc</span><br><span class="line">|   |-- info</span><br><span class="line">|   `-- product</span><br><span class="line">|-- lib</span><br><span class="line">|-- logs</span><br><span class="line">|   |-- info</span><br><span class="line">|   `-- product</span><br><span class="line">`-- service</span><br><span class="line">    `-- deploy</span><br><span class="line">      |-- info</span><br><span class="line">        `-- product</span><br><span class="line">        12 directories, 0 files</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之pwd</title>
      <link href="2019/04/30/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bpwd/"/>
      <url>2019/04/30/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bpwd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pwd 命令用来查看”当前工作目录“的完整路径，当不太确定当前位置时，可以使用pwd来判定当前目录在文件系统内的确切位置</p></blockquote><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd [选项]</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-P 显示出实际路径，而非使用连接（link）路径</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li>目录连接链接时，<code>pwd -P</code> 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost soft]<span class="comment"># cd /etc/init.d </span></span><br><span class="line">[root@localhost init.d]<span class="comment"># pwd</span></span><br><span class="line">/etc/init.d</span><br><span class="line">[root@localhost init.d]<span class="comment"># pwd -P</span></span><br><span class="line">/etc/rc.d/init.d</span><br><span class="line">[root@localhost init.d]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ol start="2"><li>/bin/pwd</li></ol><ul><li><p>命令<br>/bin/pwd [选项]  (-L 目录连接链接时，输出连接路径| -P 输出物理路径)</p></li><li><p>输出</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost init.d]<span class="comment"># /bin/pwd </span></span><br><span class="line">/etc/rc.d/init.d</span><br><span class="line">[root@localhost init.d]<span class="comment"># /bin/pwd --help</span></span><br><span class="line">[root@localhost init.d]<span class="comment"># /bin/pwd -P</span></span><br><span class="line">/etc/rc.d/init.d</span><br><span class="line">[root@localhost init.d]<span class="comment"># /bin/pwd -L</span></span><br><span class="line">/etc/init.d</span><br><span class="line">[root@localhost init.d]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ol start="3"><li>当前目录被删除了，而pwd命令仍然显示那个目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost init.d]<span class="comment"># cd /opt/soft</span></span><br><span class="line">[root@localhost soft]<span class="comment"># mkdir removed</span></span><br><span class="line">[root@localhost soft]<span class="comment"># cd removed/</span></span><br><span class="line">[root@localhost removed]<span class="comment"># pwd</span></span><br><span class="line">/opt/soft/removed</span><br><span class="line">[root@localhost removed]<span class="comment"># rm ../removed -rf</span></span><br><span class="line">[root@localhost removed]<span class="comment"># pwd</span></span><br><span class="line">/opt/soft/removed</span><br><span class="line">[root@localhost removed]<span class="comment"># /bin/pwd</span></span><br><span class="line">/bin/<span class="built_in">pwd</span>: couldn<span class="string">&#x27;t find directory entry in “..” with matching i-node</span></span><br><span class="line"><span class="string">[root@localhost removed]# cd </span></span><br><span class="line"><span class="string">[root@localhost ~]# pwd</span></span><br><span class="line"><span class="string">/root</span></span><br><span class="line"><span class="string">[root@localhost ~]#</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之cd</title>
      <link href="2019/04/29/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bcd/"/>
      <url>2019/04/29/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bcd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>切换当前目录至dirName</p></blockquote><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [目录名]</span><br></pre></td></tr></table></figure><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><ol><li>进入系统根目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F; </span><br></pre></td></tr></table></figure><ol start="2"><li>返回上一层</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd .. 或者 cd .. &#x2F;&#x2F;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 cd 命令进入当前用户主目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 或者 cd ~</span><br></pre></td></tr></table></figure><ol start="4"><li>返回进入此目录之前所在的目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd -</span><br></pre></td></tr></table></figure><ol start="5"><li>把上个命令的参数作为cd参数使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd !$</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之ls</title>
      <link href="2019/04/28/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bls/"/>
      <url>2019/04/28/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bls/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ls命令就是list的缩写缺省下ls用来打印出当前目录的清单如果ls指定其他目录那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等，具体用法是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [选项] [目录名]</span><br></pre></td></tr></table></figure><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">-a #–all 列出目录下的所有文件，包括以 . 开头的隐含文件</span><br><span class="line">-A #同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。</span><br><span class="line">-c #配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序</span><br><span class="line">-C #每栏由上至下列出项目</span><br><span class="line">–color[&#x3D;WHEN] #控制是否使用色彩分辨文件。WHEN 可以是&#39;never&#39;、&#39;always&#39;或&#39;auto&#39;其中之一</span><br><span class="line">-d #–directory 将目录象文件一样显示，而不是显示其下的文件。</span><br><span class="line">-D #–dired 产生适合 Emacs 的 dired 模式使用的结果</span><br><span class="line">-f #对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</span><br><span class="line">-g #类似 -l,但不列出所有者</span><br><span class="line">-G #–no-group 不列出任何有关组的信息</span><br><span class="line">-h #–human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)</span><br><span class="line">–si #类似 -h,但文件大小取 1000 的次方而不是 1024</span><br><span class="line">-H #–dereference-command-line 使用命令列中的符号链接指示的真正目的地</span><br><span class="line">–indicator-style&#x3D;方式 #指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</span><br><span class="line">-i #–inode 印出每个文件的 inode 号</span><br><span class="line">-I #–ignore&#x3D;样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目</span><br><span class="line">-k #即 –block-size&#x3D;1K,以 k 字节的形式表示文件的大小。</span><br><span class="line">-l #除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</span><br><span class="line">-L #–dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息</span><br><span class="line">-m #所有项目以逗号分隔，并填满整行行宽</span><br><span class="line">-o #类似 -l,显示文件的除组信息外的详细信息。   </span><br><span class="line">-r #–reverse 依相反次序排列</span><br><span class="line">-R #–recursive 同时列出所有子目录层</span><br><span class="line">-s #–size 以块大小为单位列出所有文件的大小</span><br><span class="line">-S #根据文件大小排序</span><br><span class="line"></span><br><span class="line">–sort&#x3D;WORD 以下是可选用的 WORD 和它们代表的相应选项：</span><br><span class="line"></span><br><span class="line">extension -X status -c</span><br><span class="line">none -U time -t</span><br><span class="line">size -S atime -u</span><br><span class="line">time -t access -u</span><br><span class="line">version -v use -u</span><br><span class="line"></span><br><span class="line">-t #以文件修改时间排序</span><br><span class="line">-u #配合 -lt:显示访问时间而且依访问时间排序 配合 -l:显示访问时间但根据名称排序 否则：根据访问时间排序</span><br><span class="line">-U #不进行排序;依文件系统原有的次序列出项目</span><br><span class="line">-v #根据版本进行排序</span><br><span class="line">-w, –width&#x3D;COLS   #自行指定屏幕宽度而不使用目前的数值</span><br><span class="line">-x #逐行列出项目而不是逐栏列出</span><br><span class="line">-X #根据扩展名排序</span><br><span class="line">-1 #每行只列出一个文件</span><br><span class="line">–help #显示此帮助信息并离开</span><br><span class="line">–version #显示版本信息并离开</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><ol><li><p>列出/home/peidachang文件夹下的所有文件和目录的详细资料<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l -R /home/peidachang</span><br></pre></td></tr></table></figure><br>　　在使用 ls 命令时要注意命令的格式：在命令提示符后，首先是命令的关键字，接下来是命令参数，在命令参数之前要有一短横线<code>-</code>，所有的命令参数都有特定的作用，自己可以根据需要选用一个或者多个参数，在命令参数的后面是命令的操作对象。在以上这条命令<code>ls -l -R /home/peidachang</code>中，<code>ls</code>是命令关键字，<code>-l -R</code>是参数，<code>/home/peidachang</code>是命令的操作对象。在这条命令中，使用到了两个参数，分别为<code>l</code>和<code>R</code>，当然，你也可以把他们放在一起使用，如下所示<br><code>ls -lR /home/peidachang</code></p></li><li><p>列出当前目录中所有以“t”开头的目录的详细内容<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l t*</span><br></pre></td></tr></table></figure><br> 可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单</p></li><li><p>只列出文件下的子目录<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -F /opt/soft |grep /$ </span><br></pre></td></tr></table></figure><br> 输出<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># ls -F /opt/soft |grep /$</span></span><br><span class="line">jdk1.6.0_16/</span><br><span class="line">subversion-1.6.1/</span><br><span class="line">tomcat6.0.32/</span><br></pre></td></tr></table></figure></p></li><li><p>列出 /opt/soft 文件下面的子目录详细情况<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /opt/soft | grep <span class="string">&quot;^d&quot;</span></span><br></pre></td></tr></table></figure><br> 输出<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment">#  ls -l /opt/soft | grep &quot;^d&quot;</span></span><br><span class="line">drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16</span><br><span class="line">drwxr-xr-x 16 1016 1016      4096 10-11 03:25 subversion-1.6.1</span><br><span class="line">drwxr-xr-x  9 root root      4096 2011-11-01 tomcat6.0.32</span><br></pre></td></tr></table></figure></p></li><li><p>列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ltr s*</span><br></pre></td></tr></table></figure><br> 输出<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># ls -ltr s*</span></span><br><span class="line">src:</span><br><span class="line">总计 0</span><br><span class="line">script:</span><br><span class="line">总计 0</span><br><span class="line">soft:</span><br><span class="line">总计 350644</span><br><span class="line">drwxr-xr-x  9 root root      4096 2011-11-01 tomcat6.0.32</span><br><span class="line">-rwxr-xr-x  1 root root  81871260 09-17 18:15 jdk-6u16-linux-x64.bin</span><br><span class="line">drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16</span><br><span class="line">-rw-r--r--  1 root root 205831281 09-17 18:33 apache-tomcat-6.0.32.tar.gz</span><br><span class="line">-rw-r--r--  1 root root   5457684 09-21 00:23 tomcat6.0.32.tar.gz</span><br><span class="line">-rw-r--r--  1 root root   4726179 10-10 11:08 subversion-deps-1.6.1.tar.gz</span><br><span class="line">-rw-r--r--  1 root root   7501026 10-10 11:08 subversion-1.6.1.tar.gz</span><br><span class="line">drwxr-xr-x 16 1016 1016      4096 10-11 03:25 subversion-1.6.1</span><br></pre></td></tr></table></figure></p></li><li><p>列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加”*”<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -AF</span><br></pre></td></tr></table></figure><br> 输出<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># ls -AF</span></span><br><span class="line"><span class="built_in">log</span>/  script/  soft/  src/  svndata/  web/ artisan*</span><br></pre></td></tr></table></figure></p></li><li><p>计算当前目录下的文件数和目录数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l * |grep &quot;^-&quot;|wc -l    ---文件个数  </span><br><span class="line">ls -l * |grep &quot;^d&quot;|wc -l    ---目录个数</span><br></pre></td></tr></table></figure></li><li><p>在ls中列出文件的绝对路径<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | sed <span class="string">&quot;s:^:`pwd`/:&quot;</span></span><br></pre></td></tr></table></figure><br> 输出<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># ls | sed &quot;s:^:`pwd`/:&quot; </span></span><br><span class="line">/opt/<span class="built_in">log</span></span><br><span class="line">   /opt/script</span><br><span class="line">   /opt/soft</span><br><span class="line">   /opt/src</span><br><span class="line">   /opt/svndata</span><br><span class="line">   /opt/web</span><br></pre></td></tr></table></figure></p></li><li><p>列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="variable">$PWD</span> -maxdepth 1 | xargs ls -ld</span><br></pre></td></tr></table></figure><br> 输出<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># find $PWD -maxdepth 1 | xargs ls -ld</span></span><br><span class="line">drwxr-xr-x 8 root root 4096 10-11 03:43 /opt</span><br><span class="line">drwxr-xr-x 2 root root 4096 2012-03-08 /opt/<span class="built_in">log</span></span><br><span class="line">drwxr-xr-x 2 root root 4096 2012-03-08 /opt/script</span><br><span class="line">drwxr-xr-x 5 root root 4096 10-11 03:21 /opt/soft</span><br><span class="line">drwxr-xr-x 2 root root 4096 2012-03-08 /opt/src</span><br><span class="line">drwxr-xr-x 4 root root 4096 10-11 05:22 /opt/svndata</span><br><span class="line">drwxr-xr-x 4 root root 4096 10-09 00:45 /opt/web</span><br></pre></td></tr></table></figure></p></li><li><p>递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="variable">$PWD</span> | xargs ls -ld</span><br></pre></td></tr></table></figure></p></li><li><p>指定文件时间输出格式</p></li></ol><ul><li>方法1<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -tl --time-style=full-iso</span><br></pre></td></tr></table></figure><br>  输出<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost soft]<span class="comment"># ls -tl --time-style=full-iso </span></span><br><span class="line">总计 350644</span><br><span class="line">drwxr-xr-x 16 1016 1016 4096 2012-10-11 03:25:58.000000000 +0800 subversion-1.6.1</span><br></pre></td></tr></table></figure></li><li>方法2<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ctl --time-style=long-iso</span><br></pre></td></tr></table></figure><br>  输出<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost soft]<span class="comment"># ls -ctl --time-style=long-iso</span></span><br><span class="line">总计 350644</span><br><span class="line">drwxr-xr-x 16 1016 1016      4096 2012-10-11 03:25 subversion-1.6.1</span><br></pre></td></tr></table></figure><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4></li></ul><ol><li>显示彩色目录列表<br> 打开/etc/bashrc, 加入如下一行:<br> <code>alias ls=&quot;ls --color&quot;</code><br> 下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下:<pre><code> 1. 蓝色--&gt;目录 2. 绿色--&gt;可执行文件 3. 红色--&gt;压缩文件 4. 浅蓝色--&gt;链接文件 5. 灰色--&gt;其他文件</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的设计原则</title>
      <link href="2019/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>2019/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从今天开始，计划把设计模式整理一下，主要是学习 秦小波的《设计模式之禅》中的内容，加上自己的一点想法。</p></blockquote><h3 id="单一职责原则（Single-Responsibility-Principle-简称SRP）"><a href="#单一职责原则（Single-Responsibility-Principle-简称SRP）" class="headerlink" title="单一职责原则（Single Responsibility Principle 简称SRP）"></a>单一职责原则（Single Responsibility Principle 简称SRP）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>应该有且仅有一个原因引起类的变更（There should never be more than one reason for a class to change）</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li><li>可读性提高，复杂性降低，那当然可读性提高了；</li><li>可维护性提高，可读性提高，那当然更容易维护了；</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助，单一职责适用于接口、类，同时也适用于方法</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>关于职责的定义比较模糊，没有量化的标准</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>对于单一职责原则，建议接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。</p><h3 id="里氏替换原则（Liskov-Substitution-Principle-简称LSP）"><a href="#里氏替换原则（Liskov-Substitution-Principle-简称LSP）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle 简称LSP）"></a>里氏替换原则（Liskov Substitution Principle 简称LSP）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><p>第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）</p></li><li><p>第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）</p></li></ul><blockquote><p>即：只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应</p></blockquote><p>里氏替换原则为良好的继承定义了一个规范，包括一下四点</p><ol><li>子类必须完全实现父类的方法</li><li>子类可以有自己的个性</li><li>覆盖或实现父类的方法时输入参数可以被放大（就是输入参数的类型宽于父类的类型覆盖范围）</li><li>覆写或实现父类的方法时输出结果可以被缩小</li></ol><h4 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准</p><h3 id="依赖倒置原则（Dependence-Inversion-Principle-简称DIP）"><a href="#依赖倒置原则（Dependence-Inversion-Principle-简称DIP）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle 简称DIP）"></a>依赖倒置原则（Dependence Inversion Principle 简称DIP）</h3><blockquote><p>每一个逻辑的实现都是由原子逻辑组成的，不可分割的 原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化</p></blockquote><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li><li>抽象不应该依赖细节；</li><li>细节应该依赖抽象。</li></ul><p>依赖倒置原则在PHP语言中的表现为</p><ul><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；</li><li>接口或抽象类不依赖于实现类；</li><li>实现类依赖接口或抽象类</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风 险，提高代码的可读性和可维护性</p><h4 id="依赖的三种实现方式"><a href="#依赖的三种实现方式" class="headerlink" title="依赖的三种实现方式"></a>依赖的三种实现方式</h4><ol><li>构造函数传递依赖对象，在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入，按照这种方式的注入</li><li>Setter方法传递依赖对象，在抽象中设置Setter方法声明依赖关系，依照依赖注入的说法，这是Setter依赖注入，按 照这种方式的注入</li><li>接口声明依赖对象，在接口的方法中声明依赖对象，该方法也 叫做接口注入。</li></ol><h4 id="最佳实践-2"><a href="#最佳实践-2" class="headerlink" title="最佳实践"></a>最佳实践</h4><ol><li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备</li><li>变量的表面类型尽量是接口或者是抽象类</li><li>任何类都不应该从具体类派生</li><li>尽量不要覆写基类的方法（如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响）</li><li>结合里氏替换原则使用</li></ol><h3 id="接口隔离原则（Interface-Segregation-Principle-简称ISP）"><a href="#接口隔离原则（Interface-Segregation-Principle-简称ISP）" class="headerlink" title="接口隔离原则（Interface Segregation Principle 简称ISP）"></a>接口隔离原则（Interface Segregation Principle 简称ISP）</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上<br>客户端依赖它需要的接口，客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，那就需要对接口进行细化，保证其纯洁性<br>接口隔离原则与单一职责的审视角度是不相同的，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少，根据接口隔离原则拆分接口时，首先必须满足单一职责原则<br>接口隔离原则是对接口进行规范约束，其包含以下4层含义：</p><ol><li>接口要尽量小</li><li>接口要高内聚</li><li>定制服务</li><li>接口设计是有限度的<h4 id="最佳实践-3"><a href="#最佳实践-3" class="headerlink" title="最佳实践"></a>最佳实践</h4>一个接口只服务于一个模块或业务逻辑；<br>通过业务逻辑压缩接口中的public方法；<br>已经被污染的接口，尽量去修改，如风险大，则采用适配器模式转化处理；<br>了解环境，拒绝盲从。</li></ol><h3 id="迪米特法则（Law-of-Demeter-简称LoD）"><a href="#迪米特法则（Law-of-Demeter-简称LoD）" class="headerlink" title="迪米特法则（Law of Demeter 简称LoD）"></a>迪米特法则（Law of Demeter 简称LoD）</h3><p>也称为最少知识原则（Least Knowledge Principle，LKP）<br>一个对象应该对其他对象有最少的了解<br>只和朋友交流，出现在成员变量、方法的输入输出参数中的类称为朋友类，方法体内的不算。类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象。<br>朋友间也是有距离的，一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此设计时需要反复衡量是否可以减少public方法或属性。<br>是自己的就是自己的，如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。<br>谨慎使用Serializable</p><h3 id="开闭原则（Open-Closed-Principle-简称OCP）"><a href="#开闭原则（Open-Closed-Principle-简称OCP）" class="headerlink" title="开闭原则（Open Closed Principle 简称OCP）"></a>开闭原则（Open Closed Principle 简称OCP）</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>定义：一个软件实体如类、模块、和函数应该对扩展开放，对修改关闭。<br>前面五个原则就是指导设计的工具和方法，而开闭原则才是其精神领袖。</p><h4 id="重要性："><a href="#重要性：" class="headerlink" title="重要性："></a>重要性：</h4><p>扩展操作，避免修改单元测试，及回归测试；<br>提高代码复用性，缩小逻辑粒度，直到一个逻辑不可再拆分为止；<br>提高可维护性；<br>面向对象开发的要求。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>抽象约束<br>通过接口或抽象类约束扩展，对扩展进行限定，不允许出现在接口或抽象类不存在的public方法；<br>参数类型、引用对象尽量使用接口或抽象类，而不是实现类；<br>抽象层尽量保持稳定，一旦确定不允许修改。<br>元数据控制模块行为，通过扩展一个子类，修改配置文件完成业务变化，如依赖注入；<br>制定项目章程；<br>封装变化，找出预计有变化或不稳定的点，为这些变化点创建稳定的接口<br>将相同变化封装到一个接口或抽象类中；<br>不应该有两个不同的变化出现在同一个接口或抽象类中</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDL与DML</title>
      <link href="2019/01/30/DDL%E4%B8%8EDML/"/>
      <url>2019/01/30/DDL%E4%B8%8EDML/</url>
      
        <content type="html"><![CDATA[<h3 id="DML-data-manipulation-language）数据操纵语言"><a href="#DML-data-manipulation-language）数据操纵语言" class="headerlink" title="DML (data manipulation language）数据操纵语言"></a>DML (data manipulation language）数据操纵语言</h3><p>就是我们最经常用到的 SELECT、UPDATE、INSERT、DELETE。 主要用来对数据库的数据进行一些操作。<br>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名称 <span class="keyword">FROM</span> 表名称</span><br><span class="line"><span class="keyword">UPDATE</span> 表名称 <span class="keyword">SET</span> 列名称 = 新值 <span class="keyword">WHERE</span> 列名称 = 某值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (列<span class="number">1</span>, 列<span class="number">2</span>,...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....)</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列名称 = 值</span><br></pre></td></tr></table></figure><h3 id="DDL（data-definition-language）数据库定义语言："><a href="#DDL（data-definition-language）数据库定义语言：" class="headerlink" title="DDL（data definition language）数据库定义语言："></a>DDL（data definition language）数据库定义语言：</h3><p>在创建表的时候用到的一些sql，比如说：CREATE、ALTER、DROP等。DDL主要是用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上。<br>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(列名称<span class="number">1</span> 数据类型,列名称<span class="number">2</span> 数据类型,列名称<span class="number">3</span> 数据类型,....)<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_nameALTER <span class="keyword">COLUMN</span> column_name datatypeDROP <span class="keyword">TABLE</span> 表名称<span class="keyword">DROP</span> <span class="keyword">DATABASE</span> 数据库名称</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之crontab</title>
      <link href="2018/10/08/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bcrontab/"/>
      <url>2018/10/08/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bcrontab/</url>
      
        <content type="html"><![CDATA[<blockquote><p>crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务</p></blockquote><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Linux下的任务调度分为两类，系统任务调度和用户任务调度</p><p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在<code>/etc</code>目录下有一个<code>crontab</code>文件，这个就是系统任务调度的配置文件。<br><code>/etc/crontab</code>文件包括下面几行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/crontab </span></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=<span class="string">&quot;&quot;</span>HOME=/</span><br><span class="line"><span class="comment"># run-parts</span></span><br><span class="line">51 * * * * root run-parts /etc/cron.hourly</span><br><span class="line">24 7 * * * root run-parts /etc/cron.daily</span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly</span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly</span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。<br>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致</p><h4 id="使用者权限文件"><a href="#使用者权限文件" class="headerlink" title="使用者权限文件"></a>使用者权限文件</h4><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td><code>/etc/cron.deny</code></td><td>该文件中所列用户不允许使用crontab命令</td></tr><tr><td><code>/etc/cron.allow </code></td><td>该文件中所列用户允许使用crontab命令</td></tr><tr><td><code>/var/spool/cron/</code></td><td>所有用户crontab文件存放的目录,以用户名命名</td></tr></tbody></table><h4 id="crontab文件的含义"><a href="#crontab文件的含义" class="headerlink" title="crontab文件的含义"></a>crontab文件的含义</h4><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minute   hour   day   month   week   command </span><br></pre></td></tr></table></figure><p>其中 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">minute： 表示分钟，可以是从0到59之间的任何整数。</span><br><span class="line">hour：表示小时，可以是从0到23之间的任何整数。</span><br><span class="line">day：表示日期，可以是从1到31之间的任何整数。</span><br><span class="line">month：表示月份，可以是从1到12之间的任何整数。</span><br><span class="line">week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件</span><br></pre></td></tr></table></figure><p>在以上各个字段中，还可以使用以下特殊字符：</p><ul><li>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</li><li>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</li><li>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</li><li>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</li></ul><h4 id="crond服务"><a href="#crond服务" class="headerlink" title="crond服务"></a>crond服务</h4><ul><li>安装crontab：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install crontabs</span><br></pre></td></tr></table></figure></li><li>服务操作说明：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/sbin/service crond start //启动服务</span><br><span class="line">/sbin/service crond stop //关闭服务</span><br><span class="line">/sbin/service crond restart //重启服务</span><br><span class="line">/sbin/service crond reload //重新载入配置</span><br></pre></td></tr></table></figure></li><li>查看crontab服务状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond status</span><br></pre></td></tr></table></figure></li><li>手动启动crontab服务：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond start</span><br></pre></td></tr></table></figure></li><li>查看crontab服务是否已设置为开机启动，执行命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntsysv</span><br></pre></td></tr></table></figure></li><li>加入开机自动启动：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig –level 35 crond on</span><br></pre></td></tr></table></figure><h4 id="crontab命令详解"><a href="#crontab命令详解" class="headerlink" title="crontab命令详解"></a>crontab命令详解</h4></li></ul><ol><li><p>命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] file</span><br><span class="line">crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure></li><li><p>命令功能：<br>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</p></li><li><p>命令参数：</p><ul><li><code>-u user</code>：用来设定某个用户的crontab服务，例如 <code>-u ixdba</code>表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</li><li><code>file</code>：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li><li><code>-e</code>：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li><li><code>-l</code>：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li><li><code>-r</code>：从<code>/var/spool/cron</code>目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li><li><code>-i</code>：在删除用户的crontab文件时给确认提示。</li></ul></li><li><p>常用方法：</p><ol><li><p>创建一个新的crontab文件</p><p>在考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。99 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$ HOME目录下的. profile文件，在其中加入这样一行：<code>EDITOR=vi; export EDITOR</code> 然后保存并退出。不妨创建一个名为<code>&lt;user&gt;</code> cron的文件，其中<code>&lt;user&gt;</code>是用户名，例如， davecron。在该文件中加入如下的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># (put your own initials here)echo the date to the console every</span><br><span class="line"># 15minutes between 6pm and 6am</span><br><span class="line">0,15,30,45 18-06 * * * &#x2F;bin&#x2F;echo &#39;date&#39; &gt; &#x2F;dev&#x2F;console</span><br></pre></td></tr></table></figure><p> 保存并退出。确信前面5个域用空格分隔。<br>在上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab davecron</span><br></pre></td></tr></table></figure><p> 现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。同时，新创建文件的一个副本已经被放在<code>/var/spool/cron</code>目录中，文件名就是用户名(即dave)。</p></li><li><p>列出crontab文件</p><p> 为了列出crontab文件，可以用：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br><span class="line">0,15,30,45,18-06 * * * &#x2F;bin&#x2F;echo &#96;date&#96; &gt; dev&#x2F;tty1</span><br></pre></td></tr></table></figure><p> 你将会看到和上面类似的内容。可以使用这种方法在$HOME目录中对crontab文件做一备份：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l &gt; $HOME&#x2F;mycron</span><br></pre></td></tr></table></figure><p> 这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。</p></li><li><p>编辑crontab文件<br>如果希望添加、删除或编辑crontab文件中的条目，而EDITOR环境变量又设置为vi，那么就可以用vi来编辑crontab文件，相应的命令为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure><p> 可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， cron会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。<br>我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</span><br><span class="line">30 3 1,7,14,21,26 * * &#x2F;bin&#x2F;find -name &#39;core&#39; -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p> 现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。<br>现在让我们使用前面讲过的<code>crontab -l</code>命令列出它的全部信息：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> $ crontab -l </span><br><span class="line"> # (crondave installed on Tue May 4 13:07:43 1999)</span><br><span class="line"> # DT:ech the date to the console every 30 minites</span><br><span class="line">0,15,30,45 18-06 * * * &#x2F;bin&#x2F;echo &#96;date&#96; &gt; &#x2F;dev&#x2F;tty1</span><br><span class="line"> # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</span><br><span class="line"> 30 3 1,7,14,21,26 * * &#x2F;bin&#x2F;find -name &#39;core&#39; -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure></li><li><p>删除crontab文件<br> 要删除crontab文件，可以用：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -r</span><br></pre></td></tr></table></figure></code></pre></li><li><p>恢复丢失的crontab文件<br>如果不小心误删了crontab文件，假设你在自己的$HOME目录下还有一个备份，那么可以将其拷贝到<code>/var/spool/cron/&lt;username&gt;</code>，其中<code>&lt;username&gt;</code>是用户名。如果由于权限问题无法完成拷贝，可以用：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab &lt;filename&gt;</span><br></pre></td></tr></table></figure><p> 其中，<filename>是你在$HOME目录中副本的文件名。<br>建议在自己的$HOME目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。<br>有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按<Ctrl-D>，否则你将丢失crontab文件。</p></li></ol></li></ol><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><ul><li>实例1：每1分钟执行一次command<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command</span><br></pre></td></tr></table></figure></li><li>实例2：每小时的第3和第15分钟执行<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 * * * * command</span><br></pre></td></tr></table></figure></li><li>实例3：在上午8点到11点的第3和第15分钟执行<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * * command</span><br></pre></td></tr></table></figure></li><li>实例4：每隔两天的上午8点到11点的第3和第15分钟执行<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 *&#x2F;2 * * command</span><br></pre></td></tr></table></figure></li><li>实例5：每个星期一的上午8点到11点的第3和第15分钟执行<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * 1 command</span><br></pre></td></tr></table></figure></li><li>实例6：每晚的21:30重启smb<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 21 * * * &#x2F;etc&#x2F;init.d&#x2F;smb restart</span><br></pre></td></tr></table></figure></li><li>实例7：每月1、10、22日的4 : 45重启smb<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45 4 1,10,22 * * &#x2F;etc&#x2F;init.d&#x2F;smb restart</span><br></pre></td></tr></table></figure></li><li>实例8：每周六、周日的1 : 10重启smb<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 * * 6,0 &#x2F;etc&#x2F;init.d&#x2F;smb restart</span><br></pre></td></tr></table></figure></li><li>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,30 18-23 * * * &#x2F;etc&#x2F;init.d&#x2F;smb restart</span><br></pre></td></tr></table></figure></li><li>实例10：每星期六的晚上11 : 00 pm重启smb<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 23 * * 6 &#x2F;etc&#x2F;init.d&#x2F;smb restart</span><br></pre></td></tr></table></figure></li><li>实例11：每一小时重启smb<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* *&#x2F;1 * * * &#x2F;etc&#x2F;init.d&#x2F;smb restart</span><br></pre></td></tr></table></figure></li><li>实例12：晚上11点到早上7点之间，每隔一小时重启smb<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 23-7&#x2F;1 * * * &#x2F;etc&#x2F;init.d&#x2F;smb restart</span><br></pre></td></tr></table></figure></li><li>实例13：每月的4号与每周一到周三的11点重启smb<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 11 4 * mon-wed &#x2F;etc&#x2F;init.d&#x2F;smb restart</span><br></pre></td></tr></table></figure></li><li>实例14：一月一号的4点重启smb<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 4 1 jan * &#x2F;etc&#x2F;init.d&#x2F;smb restart</span><br></pre></td></tr></table></figure></li><li>实例15：每小时执行/etc/cron.hourly目录内的脚本<br>命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 * * * * root run-parts&#x2F;etc&#x2F;cron.hourly</span><br></pre></td></tr></table></figure>说明：<br>run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了</li></ul><h4 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h4><ol><li><p>注意环境变量问题<br>有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。<br>在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。<br>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p><ol><li>脚本中涉及文件路径时写全局路径；</li><li>脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat start_cbp.sh</span><br><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">export RUN_CONF&#x3D;&#x2F;home&#x2F;d139&#x2F;conf&#x2F;platform&#x2F;cbp&#x2F;cbp_jboss.conf</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;jboss-4.0.5&#x2F;bin&#x2F;run.sh -c mev &amp;</span><br></pre></td></tr></table></figure></li><li>当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 * * * * . &#x2F;etc&#x2F;profile;&#x2F;bin&#x2F;sh &#x2F;var&#x2F;www&#x2F;java&#x2F;audit_no_count&#x2F;bin&#x2F;restart_audit.sh</span><br></pre></td></tr></table></figure></li></ol></li><li><p>注意清理系统用户的邮件日志</p><p> 每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。<br>例如，可以在crontab文件中设置如下形式，忽略日志输出：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 *&#x2F;3 * * * &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;apachectl restart &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p> <code>/dev/null 2&gt;&amp;1</code>表示先将标准输出重定向到<code>/dev/null</code>，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了<code>/dev/null</code>，因此标准错误也会重定到<code>/dev/null</code>，这样日志输出问题就解决了。</p></li><li><p>系统级任务调度与用户级任务调度<br>系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过<code>crontab –uroot –e</code>来设置，也可以将调度任务直接写入<code>/etc/crontab</code>文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到<code>/etc/crontab</code>文件，即使在root用户下创建一个定时重启系统的任务也是无效的。</p></li><li><p>其他注意事项</p><p> 新创建的<code>cron job</code>，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p><p> 当crontab突然失效时，可以尝试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;crond restart</span><br></pre></td></tr></table></figure><p> 解决问题。或者查看日志看某个job有没有执行/报错</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;cron</span><br></pre></td></tr></table></figure><p> 千万别乱运行<code>crontab -r</code>。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</p><p> 在crontab中<code>%</code>是有特殊含义的，表示换行的意思。如果要用的话必须进行转义<code>\%</code>，如经常用的date <code>+%Y%m%d</code>在crontab里是不会执行的，应该换成date <code>+\%Y\%m\%d</code>。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之grep</title>
      <link href="2018/10/08/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bgrep/"/>
      <url>2018/10/08/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bgrep/</url>
      
        <content type="html"><![CDATA[<blockquote><p>grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来</p></blockquote><h4 id="grep正则表达式元字符集"><a href="#grep正则表达式元字符集" class="headerlink" title="grep正则表达式元字符集"></a>grep正则表达式元字符集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">^  锚定行的开始 如：&#39;^grep&#39;匹配所有以grep开头的行。</span><br><span class="line"></span><br><span class="line">$  锚定行的结束 如：&#39;grep$&#39;匹配所有以grep结尾的行。</span><br><span class="line"></span><br><span class="line">.   匹配一个非换行符的字符 如：&#39;gr.p&#39;匹配gr后接一个任意字符，然后是p。</span><br><span class="line"></span><br><span class="line">*  匹配零个或多个先前字符 如：&#39; *grep&#39;匹配所有一个或多个空格后紧跟grep的行。 .*一起用代表任意字符。</span><br><span class="line"></span><br><span class="line">[] 匹配一个指定范围内的字符，如&#39;[Gg]rep&#39;匹配Grep和grep。</span><br><span class="line"></span><br><span class="line">[^]  匹配一个不在指定范围内的字符，如：&#39;[^A-FH-Z]rep&#39;匹配不包含A-F和H-Z的一个字母开头，紧跟rep的行。</span><br><span class="line"></span><br><span class="line">\(..\)  标记匹配字符，如：&#39;\(love\)&#39;，love被标记为1。</span><br><span class="line"></span><br><span class="line">\&lt;  锚定单词的开始，如：&#39;\&lt;grep&#39;匹配包含以grep开头的单词的行。</span><br><span class="line"></span><br><span class="line">\&gt;  锚定单词的结束，如&#39;grep\&gt;&#39;匹配包含以grep结尾的单词的行。</span><br><span class="line"></span><br><span class="line">x\&#123;m\&#125; 连续重复字符x，m次，如：&#39;o\&#123;5\&#125;&#39;匹配包含连续5个o的行。</span><br><span class="line"></span><br><span class="line">x\&#123;m,\&#125; 连续重复字符x,至少m次，如：&#39;o\&#123;5,\&#125;&#39;匹配至少连续有5个o的行。</span><br><span class="line"></span><br><span class="line">x\&#123;m,n\&#125; 连续重复字符x，至少m次，不多于n次，如：&#39;o\&#123;5,10\&#125;&#39;匹配连续5--10个o的行。</span><br><span class="line"></span><br><span class="line">\w  匹配一个文字和数字字符，也就是[A-Za-z0-9]，如：&#39;G\w*p&#39;匹配以G后跟零个或多个文字或数字字符，然后是p。</span><br><span class="line"></span><br><span class="line">\W  w的反置形式，匹配一个非单词字符，如点号句号等。\W*则可匹配多个。</span><br><span class="line"></span><br><span class="line">\b  单词锁定符，如: &#39;\bgrep\b&#39;只匹配grep，即只能是grep这个单词，两边均为空格。</span><br></pre></td></tr></table></figure><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-? #同时显示匹配行上下的？行，如：grep -2 pattern filename同时显示匹配行的上下2行。</span><br><span class="line">-b，--byte-offset #打印匹配行前面打印该行所在的块号码。</span><br><span class="line">-c,--count #只打印匹配的行数，不显示匹配的内容。</span><br><span class="line">-f File，--file&#x3D;File         #从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。</span><br><span class="line">-h，--no-filename #当搜索多个文件时，不显示匹配文件名前缀。</span><br><span class="line">-i，--ignore-case #忽略大小写差别。</span><br><span class="line">-q，--quiet #取消显示，只返回退出状态。0则表示找到了匹配的行。</span><br><span class="line">-l，--files-with-matches         #打印匹配模板的文件清单。</span><br><span class="line">-L，--files-without-match         #打印不匹配模板的文件清单。</span><br><span class="line">-n，--line-number #在匹配的行前面打印行号。</span><br><span class="line">-s，--silent #不显示关于不存在或者无法读取文件的错误信息。</span><br><span class="line">-v，--revert-match #反检索，只显示不匹配的行。</span><br><span class="line">-w，--word-regexp #如果被\&lt;和\&gt;引用，就把表达式做为一个单词搜索。</span><br><span class="line">-V，--version #显示软件版本信息。</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ls -l | grep <span class="string">&#x27;^a&#x27;</span> <span class="comment">#通过管道过滤ls -l输出的内容，只显示以a开头的行。</span></span><br><span class="line">grep <span class="string">&#x27;test&#x27;</span> d* <span class="comment">#显示所有以d开头的文件中包含test的行。</span></span><br><span class="line">grep <span class="string">&#x27;test&#x27;</span> aa bb cc <span class="comment">#显示在aa，bb，cc文件中匹配test的行。</span></span><br><span class="line">grep <span class="string">&#x27;[a-z]&#x27;</span> aa <span class="comment">#显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</span></span><br><span class="line">grep <span class="string">&#x27;w(es)t.*&#x27;</span> aa <span class="comment">#如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.*)，这些字符后面紧跟着另外一个es()，找到就显示该行。如果用egrep或grep -E，就不用&quot;&quot;号进行转义，直接写成&#x27;w(es)t.*&#x27;就可以了。</span></span><br><span class="line">grep -i pattern files <span class="comment">#不区分大小写地搜索。默认情况区分大小写</span></span><br><span class="line">grep -l pattern files <span class="comment">#只列出匹配的文件名，</span></span><br><span class="line">grep -L pattern files <span class="comment">#列出不匹配的文件名，</span></span><br><span class="line">grep -w pattern files <span class="comment">#只匹配整个单词，而不是字符串的一部分(如匹配‘magic’，而不是‘magical’)，</span></span><br><span class="line">grep -C number pattern files         <span class="comment">#匹配的上下文分别显示[number]行，</span></span><br><span class="line">grep pattern1 | pattern2 files         <span class="comment">#显示匹配 pattern1 或 pattern2 的行，</span></span><br><span class="line">grep pattern1 files | grep pattern2             <span class="comment">#显示既匹配 pattern1 又匹配 pattern2 的行</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC硬盘文件变灰不可操作的解决方法</title>
      <link href="2018/10/07/MAC%E7%A1%AC%E7%9B%98%E6%96%87%E4%BB%B6%E5%8F%98%E7%81%B0%E4%B8%8D%E5%8F%AF%E6%93%8D%E4%BD%9C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>2018/10/07/MAC%E7%A1%AC%E7%9B%98%E6%96%87%E4%BB%B6%E5%8F%98%E7%81%B0%E4%B8%8D%E5%8F%AF%E6%93%8D%E4%BD%9C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>MAC硬盘文件变灰不可操作一般是文件属性问题，在终端中可以看到文件多了个@属性。需要用xattr删掉@属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xattr -l XXX.txt</span><br></pre></td></tr></table></figure><p>可以看到类似<code>com.apple.FinderInfo</code>的属性，然后执行以下删除命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xattr -d com.apple.FinderInfo XXX.txt</span><br></pre></td></tr></table></figure><p>就ok了</p>]]></content>
      
      
      <categories>
          
          <category> MAC使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MAC使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC破解程序出现“程序已损坏”解决方式</title>
      <link href="2018/10/06/MAC%E7%A0%B4%E8%A7%A3%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E2%80%9C%E7%A8%8B%E5%BA%8F%E5%B7%B2%E6%8D%9F%E5%9D%8F%E2%80%9D%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"/>
      <url>2018/10/06/MAC%E7%A0%B4%E8%A7%A3%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E2%80%9C%E7%A8%8B%E5%BA%8F%E5%B7%B2%E6%8D%9F%E5%9D%8F%E2%80%9D%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>mac破解软件安装后就会出现，“程序已损坏，请移到废纸篓的提示”解决方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MAC使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MAC使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之find</title>
      <link href="2018/10/05/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bfind/"/>
      <url>2018/10/05/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bfind/</url>
      
        <content type="html"><![CDATA[<blockquote><p>find命令是一个无处不在命令，是linux中最有用的命令之一。find命令用于：在一个目录（及子目录）中搜索文件，你可以指定一些匹配条件，如按文件名、文件类型、用户甚至是时间戳查找文件</p></blockquote><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]</span><br><span class="line"></span><br><span class="line">-path: find命令所查找的目录路径。例如用.来表示当前目录，用&#x2F;来表示系统根目录</span><br><span class="line">-expression: expression可以分为——“-options [-print -exec -ok ...]”</span><br><span class="line">-options: 指定find命令的常用选项，下节详细介绍</span><br><span class="line">-print: find命令将匹配的文件输出到标准输出。</span><br><span class="line">-exec: find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#39;command&#39; &#123; &#125; \;，注意&#123; &#125;和\；之间的空格。</span><br><span class="line">-ok: 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行</span><br></pre></td></tr></table></figure><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-name   filename            #查找名为filename的文件</span><br><span class="line">-perm                       #按执行权限来查找</span><br><span class="line">-user    username           #按文件属主来查找</span><br><span class="line">-group groupname            #按组来查找</span><br><span class="line">-mtime   -n +n              #按文件更改时间来查找文件，-n指n天以内，+n指n天以前</span><br><span class="line">-atime    -n +n             #按文件访问时间来查GIN: 0px&quot;&gt;</span><br><span class="line">-ctime    -n +n             #按文件创建时间来查找文件，-n指n天以内，+n指n天以前</span><br><span class="line">-nogroup                    #查无有效属组的文件，即文件的属组在&#x2F;etc&#x2F;groups中不存在</span><br><span class="line">-nouser                     #查无有效属主的文件，即文件的属主在&#x2F;etc&#x2F;passwd中不存</span><br><span class="line">-newer   f1 !f2             #找文件，-n指n天以内，+n指n天以前 </span><br><span class="line">-ctime    -n +n             #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 </span><br><span class="line">-nogroup                    #查无有效属组的文件，即文件的属组在&#x2F;etc&#x2F;groups中不存在</span><br><span class="line">-nouser                     #查无有效属主的文件，即文件的属主在&#x2F;etc&#x2F;passwd中不存</span><br><span class="line">-newer   f1 !f2             #查更改时间比f1新但比f2旧的文件</span><br><span class="line">-type    b&#x2F;d&#x2F;c&#x2F;p&#x2F;l&#x2F;f        #查是块设备、目录、字符设备、管道、符号链接、普通文件</span><br><span class="line">-size      n[c]             #查长度为n块[或n字节]的文件</span><br><span class="line">-depth                      #使查找在进入子目录前先行查找完本目录</span><br><span class="line">-fstype                     #查更改时间比f1新但比f2旧的文件</span><br><span class="line">-type    b&#x2F;d&#x2F;c&#x2F;p&#x2F;l&#x2F;f        #查是块设备、目录、字符设备、管道、符号链接、普通文件</span><br><span class="line">-size      n[c]             #查长度为n块[或n字节]的文件</span><br><span class="line">-depth                      #使查找在进入子目录前先行查找完本目录</span><br><span class="line">-fstype                     #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在&#x2F;etc&#x2F;fstab中找到</span><br><span class="line">-mount                      #查文件时不跨越文件系统mount点</span><br><span class="line">-follow                     #如果遇到符号链接文件，就跟踪链接所指的文件</span><br><span class="line">-cpio                %;     #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在&#x2F;etc&#x2F;fstab中找到</span><br><span class="line">-mount                      #查文件时不跨越文件系统mount点</span><br><span class="line">-follow                     #如果遇到符号链接文件，就跟踪链接所指的文件</span><br><span class="line">-cpio                       #对匹配的文件使用cpio命令，将他们备份到磁带设备中</span><br><span class="line">-prune                      #忽略某个目录</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">find ~ -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span> <span class="comment">#在HOME中查.txt文件并显示</span></span><br><span class="line">find / -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span> <span class="comment">#/HOME中查.txt文件并显示</span></span><br><span class="line">find / -name <span class="string">&quot;[A-Z]*&quot;</span> -<span class="built_in">print</span> <span class="comment">#查以大写字母开头的文件</span></span><br><span class="line">find /etc -name <span class="string">&quot;host*&quot;</span> -<span class="built_in">print</span> <span class="comment">#查以host开头的文件</span></span><br><span class="line">find / -name <span class="string">&quot;[a-z][a-z][0–9][0–9].txt&quot;</span> -<span class="built_in">print</span> <span class="comment">#查以两个小写字母和两个数字开头的txt文件</span></span><br><span class="line">find / -perm 755 -<span class="built_in">print</span> <span class="comment">#检查755权限的文件并显示</span></span><br><span class="line">find / -perm -007 -<span class="built_in">exec</span> ls -l &#123;&#125; \;         <span class="comment">#查所有用户都可读写执行的文件同-perm 777</span></span><br><span class="line">find / -<span class="built_in">type</span> d -<span class="built_in">print</span> <span class="comment">#查找类型为目录的文件，并打印</span></span><br><span class="line">find / ! -<span class="built_in">type</span> d -<span class="built_in">print</span> <span class="comment">#查找类型不为目录的文件，并打印</span></span><br><span class="line">find / -<span class="built_in">type</span> l -<span class="built_in">print</span> <span class="comment">#查找类型为链接的文件，并打印</span></span><br><span class="line">find / -size +1000000c -<span class="built_in">print</span>         <span class="comment">#查长度大于1Mb的文件</span></span><br><span class="line">find / -size 100c -<span class="built_in">print</span> <span class="comment">#查长度为100c的文件</span></span><br><span class="line">find / -size +10 -<span class="built_in">print</span> <span class="comment">#查长度超过期作废10块的文件（1块=512字节）</span></span><br><span class="line">find /etc home apps -depth -<span class="built_in">print</span> | cpio -ivcdC65536 -o /dev/rmt0</span><br><span class="line">find /etc -name <span class="string">&quot;passwd*&quot;</span> -<span class="built_in">exec</span> grep <span class="string">&quot;cnscn&quot;</span> &#123;&#125; \; <span class="comment">#看是否存在cnscn用户</span></span><br><span class="line">find / -name <span class="string">&quot;yao*&quot;</span> | xargs file</span><br><span class="line">find / -name <span class="string">&quot;yao*&quot;</span> | xargs <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; /tmp/core.log</span><br><span class="line">find / -name <span class="string">&quot;yao*&quot;</span> | xargs chmod o-w</span><br><span class="line">find -name april* <span class="comment">#在当前目录下查找以april开始的文件</span></span><br><span class="line">find -name april* fprint file <span class="comment">#在当前目录下查找以april开始的文件，并把结果输出到file中</span></span><br><span class="line">find -name ap* -o -name may* <span class="comment">#查找以ap或may开头的文件</span></span><br><span class="line">find /mnt -name tom.txt -ftype vfat <span class="comment">#在/mnt下查找名称为tom.txt且文件系统类型为vfat的文件</span></span><br><span class="line">find /mnt -name t.txt ! -ftype vfat <span class="comment">#在/mnt下查找名称为tom.txt且文件系统类型不为vfat的文件</span></span><br><span class="line">find /tmp -name wa* -<span class="built_in">type</span> l         <span class="comment">#在/tmp下查找名为wa开头且类型为符号链接的文件</span></span><br><span class="line">find /home -mtime -2 <span class="comment">#在/home下查最近两天内改动过的文件</span></span><br><span class="line">find /home -atime -1 <span class="comment">#查1天之内被存取过的文件</span></span><br><span class="line">find /home -mmin +60 <span class="comment">#在/home下查60分钟前改动过的文件</span></span><br><span class="line">find /home -amin +30 <span class="comment">#查最近30分钟前被存取过的文件</span></span><br><span class="line">find /home -newer tmp.txt <span class="comment">#在/home下查更新时间比tmp.txt近的文件或目录</span></span><br><span class="line">find /home -anewer tmp.txt <span class="comment">#在/home下查存取时间比tmp.txt近的文件或目录</span></span><br><span class="line">find /home -used -2 <span class="comment">#列出文件或目录被改动过之后，在2日内被存取过的文件或目录</span></span><br><span class="line">find /home -user cnscn <span class="comment">#列出/home目录内属于用户cnscn的文件或目录</span></span><br><span class="line">find /home -uid +501 <span class="comment">#列出/home目录内用户的识别码大于501的文件或目录</span></span><br><span class="line">find /home -group cnscn         <span class="comment">#列出/home内组为cnscn的文件或目录</span></span><br><span class="line">find /home -gid 501 <span class="comment">#列出/home内组id为501的文件或目录</span></span><br><span class="line">find /home -nouser <span class="comment">#列出/home内不属于本地用户的文件或目录</span></span><br><span class="line">find /home -nogroup <span class="comment">#列出/home内不属于本地组的文件或目录</span></span><br><span class="line">find /home -name tmp.txt -maxdepth 4 <span class="comment">#列出/home内的tmp.txt 查时深度最多为3层</span></span><br><span class="line">find /home -name tmp.txt -mindepth 3 <span class="comment">#从第2层开始查</span></span><br><span class="line">find /home -empty <span class="comment">#查找大小为0的文件或空目录</span></span><br><span class="line">find /home -size +512k <span class="comment">#查大于512k的文件</span></span><br><span class="line">find /home -size -512k <span class="comment">#查小于512k的文件</span></span><br><span class="line">find /home -links +2 <span class="comment">#查硬连接数大于2的文件或目录</span></span><br><span class="line">find /home -perm 0700 <span class="comment">#查权限为700的文件或目录</span></span><br><span class="line">find /tmp -name tmp.txt -<span class="built_in">exec</span> cat &#123;&#125; \;</span><br><span class="line">find /tmp -name tmp.txt -ok rm &#123;&#125; \;</span><br><span class="line">find / -amin -10 <span class="comment">#查找在系统中最后10分钟访问的文件</span></span><br><span class="line">find / -atime -2 <span class="comment">#查找在系统中最后48小时访问的文件</span></span><br><span class="line">find / -empty <span class="comment">#查找在系统中为空的文件或者文件夹</span></span><br><span class="line">find / -group cat <span class="comment">#查找在系统中属于 groupcat的文件</span></span><br><span class="line">find / -mmin -5 <span class="comment">#查找在系统中最后5分钟里修改过的文件</span></span><br><span class="line">find / -mtime -1 <span class="comment">#查找在系统中最后24小时里修改过的文件</span></span><br><span class="line">find / -nouser <span class="comment">#查找在系统中属于作废用户的文件</span></span><br><span class="line">find / -user fred <span class="comment">#查找在系统中属于FRED这个用户的文件</span></span><br></pre></td></tr></table></figure><h4 id="find与xargs"><a href="#find与xargs" class="headerlink" title="find与xargs"></a>find与xargs</h4><p>在使用find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。</p><p>find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</p><p>在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高；</p><p>而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。</p><p>来看看xargs命令是如何同find命令一起使用的，并给出一些例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">print</span> | xargs file <span class="comment">#查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件</span></span><br><span class="line">find / -name <span class="string">&quot;core&quot;</span> -<span class="built_in">print</span> | xargs <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt;/tmp/core.log <span class="comment">#在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中</span></span><br><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">print</span> | xargs grep <span class="string">&quot;hostname&quot;</span> <span class="comment">#用grep命令在所有的普通文件中搜索hostname这个词</span></span><br><span class="line">find ./ -mtime +3 -<span class="built_in">print</span>|xargs rm -f –r <span class="comment">#删除3天以前的所有东西 （find . -ctime +3 -exec rm -rf &#123;&#125; \;）</span></span><br><span class="line">find ./ -size 0 | xargs rm -f &amp; <span class="comment">#删除文件大小为零的文件</span></span><br></pre></td></tr></table></figure><p>find命令配合使用exec和xargs可以使用户对所匹配到的文件执行几乎所有的命令</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复Nginx 502错误：upstream sent too big header while reading response header from upstream</title>
      <link href="2018/10/04/%E4%BF%AE%E5%A4%8DNginx-502%E9%94%99%E8%AF%AF%EF%BC%9Aupstream-sent-too-big-header-while-reading-response-header-from-upstream/"/>
      <url>2018/10/04/%E4%BF%AE%E5%A4%8DNginx-502%E9%94%99%E8%AF%AF%EF%BC%9Aupstream-sent-too-big-header-while-reading-response-header-from-upstream/</url>
      
        <content type="html"><![CDATA[<p>最近发现Nginx+Laravel 搭建的网站搜索某些关键字时返回502错误。</p><p>查了一下Nginx的错误日志，发现如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015&#x2F;03&#x2F;19 10:46:40 [error] 6412#0: *16436265 upstream sent too big header while reading response header from upstream, client: 192.168.101.100, server: localhost, request: &quot;GET &#x2F;search_rst.html?word&#x3D;%E7%88%B1%E6%82%A0 HTTP&#x2F;1.1&quot;, upstream: &quot;fastcgi:&#x2F;&#x2F;127.0.0.1:9000&quot;, host: ......</span><br></pre></td></tr></table></figure><p>看来还是Nginx的配置问题。</p><p>在Nginx配置文件的的http段，加入下面的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_buffer_size  128k;</span><br><span class="line">proxy_buffers   32 32k;</span><br><span class="line">proxy_busy_buffers_size 128k;</span><br></pre></td></tr></table></figure><p>重启Nginx错误依旧。再在host配置的php段加入下面配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_buffer_size 128k;</span><br><span class="line">fastcgi_buffers 4 256k;</span><br><span class="line">fastcgi_busy_buffers_size 256k;</span><br></pre></td></tr></table></figure><p>重启Nginx就不再报错了。</p>]]></content>
      
      
      <categories>
          
          <category> NGINX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGINX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之cat</title>
      <link href="2018/09/18/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bcat/"/>
      <url>2018/09/18/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bcat/</url>
      
        <content type="html"><![CDATA[<blockquote><p>cat 显示文件连接文件内容的工具</p></blockquote><p>cat 是一个文本文件查看和连接工具。查看一个文件的内容，用cat比较简单，就是cat 后面直接接文件名。</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/abc.txt</span></span><br></pre></td></tr></table></figure><p>为了便于新手弟兄灵活掌握这个工具，我们多说一点常用的参数</p><h4 id="cat-语法结构"><a href="#cat-语法结构" class="headerlink" title="cat 语法结构"></a>cat 语法结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] [文件]</span><br></pre></td></tr></table></figure><p> 选项:</p><ul><li>-A, –show-all 等价于 -vET</li><li>-b, –number-nonblank 对非空输出行编号</li><li>-e 等价于 -vE</li><li>-E, –show-ends 在每行结束处显示 $</li><li>-n, –number 对输出的所有行编号</li><li>-s, –squeeze-blank 不输出多行空行</li><li>-t 与 -vT 等价</li><li>-T, –show-tabs 将跳 字符显示为 ^I</li><li>-u (被忽略)</li><li>-v, –show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外</li><li>–help 显示此帮助信息并离开</li></ul><h4 id="cat-查看文件内容实例"><a href="#cat-查看文件内容实例" class="headerlink" title="cat 查看文件内容实例"></a>cat 查看文件内容实例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/profile    // 注：查看/etc/目录下的profile文件内容；</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat -b /etc/fstab   // 注：查看/etc/目录下的profile内容，并且对非空白行进行编号，行号从1开始；</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat -n /etc/profile    // 注：对/etc目录中的profile的所有的行(包括空白行）进行编号输出显示；</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat  -E /etc/profile     // 注：查看/etc/下的profile内容，并且在每行的结尾处附加$符号;</span></span><br></pre></td></tr></table></figure><p>cat 加参数-n 和nl工具差不多，文件内容输出的同时，都会在每行前面加上行号；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat -n /etc/profile</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nl  /etc/profilede</span></span><br></pre></td></tr></table></figure><p>cat 可以同时显示多个文件的内容，比如我们可以在一个cat命令上同时显示两个文件的内容；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/fstab /etc/profilede</span></span><br></pre></td></tr></table></figure><p>cat 对于内容极大的文件来说，可以通过管道|传送到more 工具，然后一页一页的查看；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/fstab /etc/profile | more</span></span><br></pre></td></tr></table></figure><h4 id="cat-的创建、连接文件功能实例"><a href="#cat-的创建、连接文件功能实例" class="headerlink" title="cat 的创建、连接文件功能实例"></a>cat 的创建、连接文件功能实例</h4><p>cat 有创建文件的功能，创建文件后，要以EOF或STOP结束；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat &gt; linuxsir.org.txt  &lt;&lt; EOF // 注：创建linuxsir.org.txt文件；</span></span><br><span class="line">heredoc&gt; 我来测试 cat 创建文件，并且为文件输入内容；</span><br><span class="line">heredoc&gt; 北南南北 测试</span><br><span class="line">heredoc&gt; EOF   //注：退出编辑状态；</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat linuxsir.org.txt  // 注：我们查看一下linuxsir.org.txt文件的内容；</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我来测试 cat 创建文件，并且为文件输入内容；</span><br><span class="line">北南南北 测试；</span><br></pre></td></tr></table></figure><p>cat 还有向已存在的文件追加内容的功能；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat  linuxsir.txt // 注：查看已存在的文件linuxsir.txt 内容；</span></span><br><span class="line">I am BeiNanNanBei From LinuxSir.Org .    // 注：内容行</span><br></pre></td></tr></table></figure><p>我正在为cat命令写文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat &gt;&gt; linuxsir.txt &lt;&lt; EOF   // 注：我们向linuxsir.txt文件追加内容；</span></span><br><span class="line">&gt; 我来测试cat向文档追加内容的功能；       // 注：这是追加的内容</span><br><span class="line">&gt; OK？</span><br><span class="line">&gt; OK～</span><br><span class="line">&gt; 北南 呈上</span><br><span class="line">&gt; EOF   // 注：以EOF退出；</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat linuxsir.txt  // 注：查看文件内容，看是否追回成功。</span></span><br><span class="line">I am BeiNanNanBei From LinuxSir.Org .</span><br><span class="line">我正在为cat命令写文档</span><br><span class="line">我来测试cat向文档追加内容的功能；  </span><br><span class="line">OK？</span><br><span class="line">OK～</span><br><span class="line">北南 呈上</span><br></pre></td></tr></table></figure><p>cat 连接多个文件的内容并且输出到一个新文件中；<br>假设我们有sir01.txt、sir02.tx和sir03.txt ，并且内容如下；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat sir01.txt  </span></span><br><span class="line">123456</span><br><span class="line">i am testing</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat sir02.txt</span></span><br><span class="line">56789</span><br><span class="line">BeiNan Tested</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat sir03.txt</span></span><br><span class="line">09876</span><br><span class="line">linuxsir.org testing</span><br></pre></td></tr></table></figure><p>我想通过cat 把sir01.txt、sir02.txt及sir03.txt 三个文件连接在一起（也就是说把这三个文件的内容都接在一起）并输出到一个新的文件sir04.txt 中。</p><p>注意：其原理是把三个文件的内容连接起来，然后创建sir04.txt文件，并且把几个文件的内容同时写入sir04.txt中。特别值得一提的是，如果您输入到一个已经存在的sir04.txt 文件，会把sir04.txt内容清空。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat sir01.txt sir02.txt sir03.txt &gt; sir04.txt</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># more sir04.txt</span></span><br><span class="line">123456</span><br><span class="line">i am testing</span><br><span class="line">56789</span><br><span class="line">BeiNan Tested</span><br><span class="line">09876</span><br><span class="line">linuxsir.org testing</span><br></pre></td></tr></table></figure><p>cat 把一个或多个已存在的文件内容，追加到一个已存在的文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat sir00.txt</span></span><br><span class="line">linuxsir.org forever</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat sir01.txt sir02.txt sir03.txt &gt;&gt; sir00.txt</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat sir00.txt</span></span><br><span class="line">linuxsir.org forever</span><br><span class="line">123456</span><br><span class="line">i am testing</span><br><span class="line">56789</span><br><span class="line">BeiNan Tested</span><br><span class="line">09876</span><br><span class="line">linuxsir.org testing</span><br></pre></td></tr></table></figure><p><em>警告：我们要知道&gt;意思是创建，&gt;&gt;是追加。千万不要弄混了。造成失误可不是闹着玩的</em></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之awk</title>
      <link href="2018/09/12/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bawk/"/>
      <url>2018/09/12/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bawk/</url>
      
        <content type="html"><![CDATA[<blockquote><p>awk是linux下的一个命令，他对其他命令的输出、对文件的处理都十分强大，其实他更像一门编程语言，可以自定义变量、条件语句、循环、数组、正则、函数等。可以读取输出，读取文件的方式是一行一行的读，根据给出的条件进行查找，并在找出来的行中进行操作。awk有三种形势，awk，gawk，nawk</p></blockquote><h4 id="awk中的记录，域，分割符"><a href="#awk中的记录，域，分割符" class="headerlink" title="awk中的记录，域，分割符"></a>awk中的记录，域，分割符</h4><p>读取输出或者读取文件时，读取一行就是一个记录。记录分割符默认是回车符，保存在RS，ORS中。</p><p>从记录中分割出需要单词或者词组时，行中的每个字符串定义为域，域分割符默认是空格和TAB符，保存在ORS中。</p><p>举个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaaa:bbbb:ccccccc</span><br><span class="line">1111:2343:5t43343</span><br></pre></td></tr></table></figure><p>上面有二行，这二行就是二个记录，每行后面的回车呢，就是记录分割符，里面冒号呢，就是域分割符，分割出来的aaaa、1111这类东西就是域了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> testfile</span><br></pre></td></tr></table></figure><h4 id="awk的内建变量和运算符"><a href="#awk的内建变量和运算符" class="headerlink" title="awk的内建变量和运算符"></a>awk的内建变量和运算符</h4><ol><li>变量</li></ol><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>$n</td><td>当前记录的第n个字段，字段间由 FS分隔</td></tr><tr><td>$0</td><td>完整的输入记录</td></tr><tr><td>ARGC</td><td>命令行参数的数目</td></tr><tr><td>ARGIND</td><td>命令行中当前文件的位置(从0开始算)</td></tr><tr><td>ARGV</td><td>包 含命令行参数的数组</td></tr><tr><td>CONVFMT</td><td>数字转换格式(默认值为%.6g)</td></tr><tr><td>ENVIRON</td><td>环境变量关联数组</td></tr><tr><td>ERRNO</td><td>最后一个系统错误的描述</td></tr><tr><td>FIELDWIDTHS</td><td>字 段宽度列表(用空格键分隔)</td></tr><tr><td>FILENAME</td><td>当前文件名</td></tr><tr><td>FNR</td><td>同<code>NR</code>但相对于当前文件</td></tr><tr><td>FS</td><td>字段分隔符(默认是任何空格)</td></tr><tr><td>IGNORECASE</td><td>如果为真，则进行忽略大小写的匹配</td></tr><tr><td>NF</td><td>当前记录中的字段数</td></tr><tr><td>NR</td><td>当前记录数</td></tr><tr><td>OFMT</td><td>数字的输出格式(默认值是%.6g)</td></tr><tr><td>OFS</td><td>输出字段分隔符(默认值是一个空格)</td></tr><tr><td>ORS</td><td>输出记录分隔符(默认值是一个换行符)</td></tr><tr><td>RLENGTH</td><td>由<code>match</code>函数所匹配的字符串的长度</td></tr><tr><td>RS</td><td>记录分隔符(默认是一个换行符)</td></tr><tr><td>RSTART</td><td>由<code>match</code>函数所匹配的字符串的第一个位置</td></tr><tr><td>SUBSEP</td><td>数组下标分隔符(默认值是\034)</td></tr></tbody></table><ol start="2"><li>运算符</li></ol><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>= += -= *= /= %= ^= **=</td><td>赋值</td></tr><tr><td>?:</td><td>C条件表达式</td></tr><tr><td>&#124;&#124;</td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>~ ~!</td><td>匹配正则表达式和不匹配正则表达式</td></tr><tr><td>&lt; &lt;= &gt; &gt;= != ==</td><td>关系运算符</td></tr><tr><td>空格</td><td>连接</td></tr><tr><td>+ -</td><td>加 减</td></tr><tr><td>* / &amp;</td><td>乘，除与求余</td></tr><tr><td>!</td><td>逻辑非</td></tr><tr><td>^ ***</td><td>求幂</td></tr><tr><td>++ –</td><td>增加或减少，作为前缀或后缀</td></tr><tr><td>$</td><td>字段引用</td></tr><tr><td>in</td><td>数组成员</td></tr></tbody></table><h4 id="awk的正则"><a href="#awk的正则" class="headerlink" title="awk的正则"></a>awk的正则</h4><table><thead><tr><th align="center">匹配符</th><th>描述</th></tr></thead><tbody><tr><td align="center">\Y</td><td>匹配一个单词开头或者末尾的空字符串</td></tr><tr><td align="center">\B</td><td>匹配单词内的空字符串</td></tr><tr><td align="center">&lt;</td><td>匹配一个单词的开头的空字符串，锚定开始</td></tr><tr><td align="center">&gt;</td><td>匹配一个单词的末尾的空字符串，锚定末尾</td></tr><tr><td align="center">\W</td><td>匹配一个非字母数字组成的单词</td></tr><tr><td align="center">\w</td><td>匹配一个字母数字组成的单词</td></tr><tr><td align="center">&#39;</td><td>匹配字符串末尾的一个空字符串</td></tr><tr><td align="center">\‘</td><td>匹配字符串开头的一个空字符串</td></tr></tbody></table><h4 id="awk的函数"><a href="#awk的函数" class="headerlink" title="awk的函数"></a>awk的函数</h4><ol><li>字符串函数</li></ol><table><thead><tr><th align="center">函数名</th><th>描述</th></tr></thead><tbody><tr><td align="center">sub</td><td>匹配记录中最大、最靠左边的子字符串的正则表达式，并用替换字符串替换这些字符串。如果没有指定目标字符串就默认使用整个记录。替换只发生在第一次匹配的 时候</td></tr><tr><td align="center">gsub</td><td>整个文档中进行匹配</td></tr><tr><td align="center">index</td><td>返回子字符串第一次被匹配的位置，偏移量从位置1开始</td></tr><tr><td align="center">substr</td><td>返回从位置1开始的子字符串，如果指定长度超过实际长度，就返回整个字符串</td></tr><tr><td align="center">split</td><td>可按给定的分隔符把字符串分割为一个数组。如果分隔符没提供，则按当前FS值进行分割</td></tr><tr><td align="center">length</td><td>返回记录的字符数</td></tr><tr><td align="center">match</td><td>返回在字符串中正则表达式位置的索引，如果找不到指定的正则表达式则返回0。match函数会设置内建变量RSTART为字符串中子字符串的开始位 置，RLENGTH为到子字符串末尾的字符个数。substr可利于这些变量来截取字符串</td></tr><tr><td align="center">toupper和tolower</td><td>可用于字符串大小间的转换，该功能只在gawk中有效</td></tr></tbody></table><ol start="2"><li>数学函数</li></ol><table><thead><tr><th align="center">函数名</th><th>返回值</th></tr></thead><tbody><tr><td align="center">atan2(x,y)</td><td>y,x 范围内的余切</td></tr><tr><td align="center">cos(x)</td><td>余弦函数</td></tr><tr><td align="center">exp(x)</td><td>求幂</td></tr><tr><td align="center">int(x)</td><td>取整</td></tr><tr><td align="center">log(x)</td><td>自然对数</td></tr><tr><td align="center">rand()</td><td>随机数</td></tr><tr><td align="center">sin(x)</td><td>正弦</td></tr><tr><td align="center">sqrt(x)</td><td>平方根</td></tr><tr><td align="center">srand(x)</td><td>x是rand()函数的种子</td></tr><tr><td align="center">int(x)</td><td>取整，过程没有舍入</td></tr><tr><td align="center">rand()</td><td>产生一个大于等于0而小于1的随机数</td></tr></tbody></table><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>学习awk的时候，做了一个例子，学东西，不要光看，光看是记不住东西的。光看的话，也许你知道怎么回事，真正实际操作，不是这儿有问题，就是那儿有问题。所以一定要动手亲自操作一下。</p><ol><li>测试文件test</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;bin&#x2F;false</span><br><span class="line">daemon:x:2:2:daemon:&#x2F;sbin:&#x2F;bin&#x2F;false</span><br><span class="line">mail:x:8:12:mail:&#x2F;var&#x2F;spool&#x2F;mail:&#x2F;bin&#x2F;false</span><br><span class="line">ftp:x:14:11:ftp:&#x2F;home&#x2F;ftp:&#x2F;bin&#x2F;false</span><br><span class="line">&amp;nobody:$:99:99:nobody:&#x2F;:&#x2F;bin&#x2F;false</span><br><span class="line">zhangy:x:1000:100:,,,:&#x2F;home&#x2F;zhangy:&#x2F;bin&#x2F;bash</span><br><span class="line">http:x:33:33::&#x2F;srv&#x2F;http:&#x2F;bin&#x2F;false</span><br><span class="line">dbus:x:81:81:System message bus:&#x2F;:&#x2F;bin&#x2F;false</span><br><span class="line">hal:x:82:82:HAL daemon:&#x2F;:&#x2F;bin&#x2F;false</span><br><span class="line">mysql:x:89:89::&#x2F;var&#x2F;lib&#x2F;mysql:&#x2F;bin&#x2F;false</span><br><span class="line">aaa:x:1001:1001::&#x2F;home&#x2F;aaa:&#x2F;bin&#x2F;bash</span><br><span class="line">ba:x:1002:1002::&#x2F;home&#x2F;zhangy:&#x2F;bin&#x2F;bash</span><br><span class="line">test:x:1003:1003::&#x2F;home&#x2F;test:&#x2F;bin&#x2F;bash</span><br><span class="line">@zhangying:*:1004:1004::&#x2F;home&#x2F;test:&#x2F;bin&#x2F;bash</span><br><span class="line">policykit:x:102:1005:Po</span><br></pre></td></tr></table></figure><p>例1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">test</span> | awk -F: <span class="string">&#x27;&#123;\</span></span><br><span class="line"><span class="string">if ($1 == &quot;root&quot;)&#123;\</span></span><br><span class="line"><span class="string">print $1;\</span></span><br><span class="line"><span class="string">&#125;else if($1 == &quot;bin&quot;)&#123;\</span></span><br><span class="line"><span class="string">print $2;\</span></span><br><span class="line"><span class="string">&#125;else&#123;\</span></span><br><span class="line"><span class="string">print $3;\</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;\</span></span><br><span class="line"><span class="string">for(i=0;i&lt;NF;i++)&#123;\</span></span><br><span class="line"><span class="string">if ($i ~/^root/)&#123;\</span></span><br><span class="line"><span class="string">print $i;\</span></span><br><span class="line"><span class="string">&#125;else if($i ~/zhangy/)&#123;\</span></span><br><span class="line"><span class="string">print $i;continue;\</span></span><br><span class="line"><span class="string">&#125;else if($i ~/mysql/)&#123;\</span></span><br><span class="line"><span class="string">print $i;next;\</span></span><br><span class="line"><span class="string">&#125;else if($i ~/^test/)&#123;\</span></span><br><span class="line"><span class="string">print $i;break;\</span></span><br><span class="line"><span class="string">&#125; \</span></span><br><span class="line"><span class="string">&#125;\</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>例3：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail <span class="built_in">test</span> | awk <span class="string">&#x27;BEGIN&#123;while(getline d)&#123; split(d,test);for(i in test)&#123;\</span></span><br><span class="line"><span class="string">print test[i]\</span></span><br><span class="line"><span class="string">&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>例4:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/<span class="built_in">test</span> | awk <span class="string">&#x27;BEGIN&#123;while(getline d)&#123; split(d,test);\</span></span><br><span class="line"><span class="string">print test[9] ;&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>例5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;32:34&quot;</span> |awk -F: <span class="string">&#x27;&#123;print &quot;max = &quot;,max($1,$2)&#125;\</span></span><br><span class="line"><span class="string">function max(one,two)&#123;\</span></span><br><span class="line"><span class="string">if(one &gt; two)&#123;\</span></span><br><span class="line"><span class="string">return one;\</span></span><br><span class="line"><span class="string">&#125;else&#123;\</span></span><br><span class="line"><span class="string">return two;\</span></span><br><span class="line"><span class="string">&#125;\</span></span><br><span class="line"><span class="string">&#125;\</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>例6：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#awk &#x27;BEGIN&#123;print &quot;what is your name&quot;; getline name &lt; &quot;/dev/tty&quot;&#125;$1 ~name&#123;print</span></span><br><span class="line"><span class="comment">#&quot;found name on line&quot; NR&#125;END&#123;print &quot;see you&quot; name&#125;&#x27; test</span></span><br><span class="line"><span class="comment">#awk &#x27;&#123;sub(/daemon/,&quot;tankzhang&quot;);print&#125;&#x27; test</span></span><br><span class="line"><span class="comment">#awk &#x27;&#123; &#123;sub(/zhangy/,&quot;tankzhang&quot;);$1&#125;;print&#125;&#x27; test</span></span><br><span class="line"><span class="comment">#awk &#x27;&#123; &#123;gsub(/zhangy/,&quot;tankzhang&quot;);$1&#125;;print&#125;&#x27; test</span></span><br><span class="line"><span class="comment">#awk -F: &#x27;&#123;print index(&quot;zhangy&quot;,$1)&#125;&#x27; test</span></span><br><span class="line"><span class="comment">#awk -F: &#x27;&#123;print substr($1,1,2)&#125;&#x27; test</span></span><br><span class="line">awk -F: <span class="string">&#x27;&#123;mat=match($1,/^[a-zA-Z]+$/);print mat,RSTART,RLENGTH&#125;&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>例7：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">test</span> |awk -F: <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">NF != 7&#123;\</span></span><br><span class="line"><span class="string">printf(&quot;line %d,does not have 7 fields:%s\n&quot;,NR,$0)&#125;\</span></span><br><span class="line"><span class="string">$1 !~ /^[A-Za-z0-9]/&#123;printf(&quot;line %d,non alpha and numeric user id:%s: %s\n&quot;,NR,$1,$0)&#125;\</span></span><br><span class="line"><span class="string">$2 == &quot;*&quot; &#123;printf(&quot;lind %d,no password:%s\n&quot;,NR,$0)&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之ln</title>
      <link href="2018/09/06/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bln/"/>
      <url>2018/09/06/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bln/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s，具体用法是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln –s 源文件 目标文件</span><br></pre></td></tr></table></figure><p>　　当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。例如：<code>../intv_vendor ./vendor</code></p><h4 id="这里有两点要注意"><a href="#这里有两点要注意" class="headerlink" title="这里有两点要注意"></a>这里有两点要注意</h4><ol><li>__ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化__；</li><li>ln的链接分软链接和硬链接两种<ol><li>软链接就是<code>ln –s ** **</code>，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间</li><li>硬链接<code>ln ** **</code>，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</li><li>不论是硬连结或软链结都不会将原本的档案复制一份，只会占用非常少量的磁碟空间</li></ol></li></ol><p>　　如果用<code>ls</code>察看一个目录时，发现有的文件后面有一个<code>@</code>的符号，那就是一个用ln命令生成的文件，用<code>ls –l</code>命令去察看，就可以看到显示的link的路径了。</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ln [options] source dist</span><br><span class="line">&#x2F;&#x2F;option 的格式为</span><br><span class="line">[-bdfinsvF] </span><br><span class="line">[-S backup-suffix] </span><br><span class="line">[-V &#123;numbered,existing,simple&#125;]</span><br><span class="line">[--help]</span><br><span class="line">[--version]</span><br><span class="line">[--]</span><br><span class="line"></span><br><span class="line">-f : 链结时先将与 dist 同档名的档案删除</span><br><span class="line">-d : 允许系统管理者硬链结自己的目录</span><br><span class="line">-i : 在删除与dist同档名的档案时先进行询问</span><br><span class="line">-n : 在进行软连结时，将 dist视为一般的档案</span><br><span class="line">-s : 进行软链结(symbolic link)</span><br><span class="line">-v : 在连结之前显示其档名</span><br><span class="line">-b : 将在链结时会被覆写或删除的档案进行备份</span><br><span class="line">-S SUFFIX : 将备份的档案都加上 SUFFIX 的字尾</span><br><span class="line">-V METHOD : 指定备份的方式</span><br><span class="line">--help : 显示辅助说明</span><br><span class="line">--version : 显示版本</span><br></pre></td></tr></table></figure><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><p>　　将档案 yy 产生一个 symbolic link : zz<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s yy zz</span><br></pre></td></tr></table></figure><br>　　将档案 yy 产生一个 hard link : zz<br>　　<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln yy xx</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令篇之scp</title>
      <link href="2018/04/11/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bscp/"/>
      <url>2018/04/11/Linux%E5%91%BD%E4%BB%A4%E7%AF%87%E4%B9%8Bscp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux scp命令用于Linux之间复制文件和目录。</p></blockquote><p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file][-l limit] [-o ssh_option] [-P port] [-S program] [[user@]host1:]file1 [...] [[user@]host2:]file2</span><br></pre></td></tr></table></figure><p>简易写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [可选参数] file_source file_target </span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-1： 强制scp命令使用协议ssh1</span><br><span class="line">-2： 强制scp命令使用协议ssh2</span><br><span class="line">-4： 强制scp命令只使用IPv4寻址</span><br><span class="line">-6： 强制scp命令只使用IPv6寻址</span><br><span class="line">-B： 使用批处理模式（传输过程中不询问传输口令或短语）</span><br><span class="line">-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</span><br><span class="line">-p：保留原文件的修改时间，访问时间和访问权限。</span><br><span class="line">-q： 不显示传输进度条。</span><br><span class="line">-r： 递归复制整个目录。</span><br><span class="line">-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</span><br><span class="line">-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</span><br><span class="line">-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</span><br><span class="line">-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</span><br><span class="line">-l limit： 限定用户所能使用的带宽，以Kbit&#x2F;s为单位。</span><br><span class="line">-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，</span><br><span class="line">-P port：注意是大写的P, port是指定数据传输用到的端口号</span><br><span class="line">-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</span><br></pre></td></tr></table></figure><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ol><li>从本地文件复制到远程</li></ol><ul><li>命令格式：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder </span><br><span class="line"># 或者 </span><br><span class="line">scp local_file remote_username@remote_ip:remote_file </span><br><span class="line"># 或者 </span><br><span class="line">scp local_file remote_ip:remote_folder </span><br><span class="line"># 或者 </span><br><span class="line">scp local_file remote_ip:remote_file </span><br></pre></td></tr></table></figure><ul><li>第1、2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；</li><li>第3、4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</li></ul></li><li>应用实例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3 </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music </span><br><span class="line">scp &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music&#x2F;001.mp3 </span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>复制目录</li></ol><ul><li>命令格式：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder </span><br><span class="line"># 或者 </span><br><span class="line">scp -r local_folder remote_ip:remote_folder </span><br></pre></td></tr></table></figure><ul><li>第1个指定了用户名，命令执行后需要再输入密码；</li><li>第2个没有指定用户名，命令执行后需要输入用户名和密码；</li></ul></li><li>应用实例：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; </span><br><span class="line">scp -r &#x2F;home&#x2F;space&#x2F;music&#x2F; www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; </span><br></pre></td></tr></table></figure>  上面命令将本地 music 目录复制到远程 others 目录下。</li></ul><ol start="3"><li>从远程复制到本地<br>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例</li></ol><ul><li>应用实例：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3 </span><br><span class="line">scp -r www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; &#x2F;home&#x2F;space&#x2F;music&#x2F;</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4></li></ul><ol><li>如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#scp 命令使用端口号 4588</span><br><span class="line">scp -P 4588 remote@www.runoob.com:&#x2F;usr&#x2F;local&#x2F;sin.sh &#x2F;home&#x2F;administrator</span><br></pre></td></tr></table></figure></li><li>使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL远程连接</title>
      <link href="2018/04/11/MySQL%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
      <url>2018/04/11/MySQL%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>导语：有位客户的机器需要开放MySQL的远程连接，当配置完账号权限后，却发现远程连接的时候出现Can’t connect to MySQL server on (111 “Connection refused”)的问题，经过排查解决了这个问题。下面是步骤。</p></blockquote><h3 id="开放Mysql的远程连接"><a href="#开放Mysql的远程连接" class="headerlink" title="开放Mysql的远程连接"></a>开放Mysql的远程连接</h3><p>在服务器上登录mysql，然后执行以下的命令。</p><p>登录mysql：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>执行赋权的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span> WITH GRANT OPTION; </span><br><span class="line">MySQL&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>也可以直接重启mysql。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h3 id="远程连接MySQL"><a href="#远程连接MySQL" class="headerlink" title="远程连接MySQL"></a>远程连接MySQL</h3><p>在本地连接mysql，我们可以使用mysql workbench，这是一款英文的mysql的客户端。</p><p>连接的时候出现错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Can&#39;t connect to MySQL server on Ip地址 (111 &quot;Connection refused&quot;)</span><br></pre></td></tr></table></figure><h4 id="检查-my-cnf"><a href="#检查-my-cnf" class="headerlink" title="检查 my.cnf"></a>检查 my.cnf</h4><p>在my.cnf的配置文件中，有参数控制它是否运行在网络上。例如查看这个 my.cnf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi my.cnf</span><br></pre></td></tr></table></figure><p>如果是老的版本，使用 #屏蔽 skip-networking，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#skip-networking</span></span><br></pre></td></tr></table></figure><p>如果是新的版本，使用 # 屏蔽 bind-address。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#bind-address  &#x3D; 127.0.0.1</span><br></pre></td></tr></table></figure><p>或者指定允许访问的ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#bind-address &#x3D; 192.168.1.2</span><br></pre></td></tr></table></figure><h4 id="重启mysql。"><a href="#重启mysql。" class="headerlink" title="重启mysql。"></a>重启mysql。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><p>在屏蔽 <code> #skip-networking</code> 后，再远程连接mysql就OK了。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
